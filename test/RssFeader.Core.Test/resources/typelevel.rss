<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Typelevel.scala</title>
    <description>Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.</description>    
    <link>https://typelevel.org</link>
    <copyright>CC BY 3.0</copyright>
    
      <item>
        <title>Update About Sustainability Program</title>
                
        <description><![CDATA[
<p>Six months ago, we launched the <a href="https://github.com/typelevel/general/blob/master/sustainability_program.md">Typelevel sustainability program</a> to provide more ways for our community to help support Typelevel projects. Since then, we received numerous donations from individuals as well as corporations, now bringing our estimated annual budget to over $18,000. We are incredibly grateful for the generosity of our community. From the bottom of our hearts, thank you!</p>

<p>Our original plan was to use the donation to hire a part-time dedicated maintainer to help support participating projects. That plan requires a higher annual budget, namely $150,000. We decided that we are going to adjust this plan to be more aligned with the current level of donations. We will start to distribute money received from donations directly to maintainers through <a href="https://opencollective.com/typelevel">OpenCollective</a>. 
Maintainers of <a href="https://github.com/typelevel/general/blob/master/sustainability_program.md#typelevel-libraries-in-the-program">pariticpating projects</a> who are interested in being paid report their hours to the <a href="mailto:sponsor-contact@typelevel.org">program admin</a> each month. 
If non-maintainer contributors are interested in contributing paid work, please request approvals from maintainers ahead of time. 
At the end of the month, we calculate how much each maintainer can invoice based on total recorded hours and monthly budget received. Invoices can then be <a href="https://opencollective.com/typelevel/expenses/new">submitted to opencollective</a> as expenses and paid.</p>

<p>We believe that this new plan will support the long-term sustainability of our projects in a more budget flexible way. Please reach out to us if you have any concerns or feedback. We’ll happily refund donors who prefer their donations not being distributed this way.</p>

<p>From now on, please donate through the <a href="https://opencollective.com/typelevel">Typelevel sustainability program’s opencollective page</a>. The old donorbox portal will be shut down. If you haven’t, please consider talking to your employer about supporting the OSS libraries they are using. Our sponsor levels remain unchanged: annual donation from $2,000 to $5,000 for silver, from $5,000 to $10,000 for gold, and from $10,000 to $50,000 for platinum. Individual donations are much much appreciated too. The more budget we have, the more supported office hours the maintainers can have.</p>

<p>Thanks again for your support! We look forward to continuing building a strong and active community for Functional programming in Scala.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2019/11/13/Update-about-sustainability-program.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2019/11/13/Update-about-sustainability-program.html</guid>
      </item>
    
      <item>
        <title>Contributors and Community</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>Effective today, John De Goes has been indefinitely barred from participation in Typelevel projects. This most directly impacts Cats Effect, but applies to our other repositories as well. The cause is John’s combative style of interaction in Typelevel channels. His interactions when in agreement are always cordial, but when he disagrees with something or someone, the results are inevitably drawn out, intensely aggressive, and stressful. We have tried for the past three years, via one-on-one discussions and multiple warnings, to arrive at a style of respectful collaboration that we can all live with. These attempts have consistently failed, despite considerable time-consuming effort.</p>

<p>Our overriding goal is the well-being of our contributors. Too much of their energy and enthusiasm is being drained away by these conflicts, and we’re concerned about the potential chilling effect on new contributors as well. While we appreciate John’s technical insight and expertise and the time he devotes to sharing those things, neither outweigh the well-being of our contributors and community.</p>

<p>We are very much aware that, particularly with actions such as this, a lot of questions and concerns naturally arise. We want to be as open and as transparent as we can be, and we invite anyone who has concerns to engage with us in the <a href="https://gitter.im/typelevel/admin">Typelevel Admin</a> channel on Gitter. If you prefer private correspondence for any reason, please feel free to directly contact the Typelevel leadership directly at info@typelevel.org.</p>

<p><em>While we are aware that the timing of this announcement is likely to be conflated with the recent action by Skills Matter, that timing is completely coincidental. This action by Typelevel has been independently in process for a considerable period of time.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 05 Sep 2019 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2019/09/05/jdg.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2019/09/05/jdg.html</guid>
      </item>
    
      <item>
        <title>Support Typelevel thanks to Triplequote Hydra and compile Scala faster!</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>Hello Community!</p>

<p>As you all know, back in April we announced the <a href="https://typelevel.org/blog/2019/04/24/typelevel-sustainability-program-announcement.html">Typelevel Sustainability Program</a> and we have been delighted by the overwhelming support we received both from companies and individuals: thank you all!</p>

<p>In just a little bit more than one month we reached 10% of the fundraising goal we set to $150,000. While this is an excellent start, to successfully support the long term sustainability of our ecosystem, we need you to keep advocating for us.</p>

<p>One difficulty we are aware of is that it can be hard to convince a company to donate money even if it benefits extensively from our ecosystem. This, despite developers knowing how important it is to sustain the maintenance and development of the open source libraries they love and use every day.</p>

<h3 id="announcing-give-25-get-25-compile-scala-75-faster">Announcing: Give 25%, Get 25%, Compile Scala 75% faster!</h3>

<p>To help us get over this hurdle, we are stoked to announce that <a href="https://triplequote.com/">Triplequote</a>, the creator of <a href="https://triplequote.com/hydra">Triplequote Hydra</a> - the only multicore Scala compiler with built-in compile-time monitoring - has kindly offered to donate 25% of each yearly Hydra license <a href="https://triplequote.com/hydra/pricing/">purchased online</a> until June 30th using the discount code <strong>TYPELEVEL25</strong>. But that’s not it, by using the discount code you also benefit from a 25% discount on their list pricing!</p>

<p>Using Hydra has proven to be incredibly valuable for Scala projects that rely on our ecosystem, and it delivered impressive compilation speedups. Nowadays, even <a href="https://github.com/typelevel/cats/pull/2848">Cats is compiled with Hydra</a>. Therefore, if you are looking for a way to help us reach our fundraising goal, while also profiting from a great product, don’t let this opportunity slip away. Head over to the <a href="https://triplequote.com/hydra/trial">Hydra trial page</a> and get started with it in no time using your preferred development tool, whether that is sbt, Maven, Gradle, or IntelliJ IDEA! Just don’t forget to use the discount code <strong>TYPELEVEL25</strong></p>

<p><a class="dbox-donation-button" href="https://triplequote.com/hydra/checkout" style="background:#F95A66 url(https://d1iczxrky3cnb2.cloudfront.net/white_logo.png) no-repeat 37px center; color: #fff;text-decoration: none;font-family: Verdana,sans-serif;display: inline-block;font-size: 16px;padding: 15px 38px 15px 75px; -webkit-border-radius: 2px; -moz-border-radius: 2px; border-radius: 2px; box-shadow: 0 1px 0 0 #ae3e47; text-shadow: 0 1px rgba(0, 0, 0, 0.3);">DO THE THING</a></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2019/05/29/support-typelevel-thanks-to-triplequote-hydra.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2019/05/29/support-typelevel-thanks-to-triplequote-hydra.html</guid>
      </item>
    
      <item>
        <title>Typelevel Switches to the Scala Code of Conduct</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>Typelevel is pleased to announce that we are retiring the Typelevel Code of
Conduct in favour of the <a href="/code-of-conduct.html">Scala Code of Conduct</a>. Many of the major projects
under the Typelevel umbrella have already made the switch and we will be asking
new projects that join Typelevel to adopt the new code.</p>

<p>The Scala Code of Conduct was developed by the Scala Center with input from
Typelevel and Lightbend, and improves on Typelevel’s original in several ways.
It can be thought of as the “Typelevel code of conduct 2.0”. We <a href="https://typelevel.org/blog/2016/12/17/scala-coc.html">endorsed it
from the outset</a> and have
decided that now the time is right to simplify things and move to the new code
wholesale.</p>

<p>A shared code of conduct means a shared standard of good behaviour. Having a
single code smooths the path for participants moving between different
organizations, projects, and events in the Scala ecosystem.</p>

<p>The Scala Code of Conduct is supported by key Scala organizations and events,
both community and commercial: the Scala Center, Lightbend, ScalaBridge, Scala
Days amongst many others. And now Typelevel and the Typelevel Summits.</p>

<p>We’d love you to join us.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2019/05/01/typelevel-switches-to-scala-code-of-conduct.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2019/05/01/typelevel-switches-to-scala-code-of-conduct.html</guid>
      </item>
    
      <item>
        <title>Typelevel Sustainability Program Announcement</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>We are excited to announce the Typelevel sustainability program.
The ultimate goal for this program is to provide ways for the user community to ensure the long-term sustainability of the development and maintenance of some Typelevel libraries.
Currently, these libraries are maintained in their contributors’ spare time. This arrangement has worked so far but we want to firmly secure their long term sustainability with an institution dedicated to supporting the maintenance of these mission critical libraries.</p>

<p>Based on our <a href="https://typelevel.org/blog/2019/01/30/cats-ecosystem-community-survey-results.html">Cats ecosystem community survey</a>, roughly 70% of the users will gain more confidence
in the future of the ecosystem if there are compensated maintainers. We believe that our pure FP
Scala ecosystem should have an institution supporting it, somewhat like the Scala Center
supporting the language, and Lightbend supporting language as well as ecosystem libs.</p>

<p>There are also some concerns, 3% of users suggested paid maintainers will reduce their confidence, the remainder are not sure one way or another. Given these numbers, we believe that the gain of confidence will outweigh the concerns especially if we design our paid maintainership program with deliberations to address them. The worries we received fall into four categories:</p>

<ul>
  <li>Vendor favoritism and influence</li>
  <li>Conflicts of interest</li>
  <li>Discouraging non-compensated maintainers and contributors</li>
  <li>Paid maintainer over contributing unnecessary features</li>
</ul>

<h3 id="we-believe-we-can-mitigate-these-concerns-by-adopting-the-following-principles">We believe we can mitigate these concerns by adopting the following principles:</h3>

<ul>
  <li>Paid maintainers focus on supporting the community contributors. In another sentence, 
paid maintainers’ first task is to maintain the community-driven development. 
More specific responsibilities are listed <a href="https://github.com/typelevel/general/blob/master/sustainability_program.md#responsibilities-for-paid-maintainers">here</a>.</li>
  <li>Main obligations to sponsors (individual or corporate) are limited to
    <ul>
      <li>The existing license remains unchanged.</li>
      <li>Timely security patches and mission critical bug fixes.</li>
      <li>Monetary contributions will NOT grant contributors extra influence over the development.</li>
      <li>Monetary contributors can influence how their contribution is distributed among projects.</li>
    </ul>
  </li>
  <li>The program is governed by an independent committee.</li>
  <li>As part of our community, sponsors hold values compatible with the <a href="https://www.scala-lang.org/conduct/">Scala Code of Conduct</a>.</li>
</ul>

<p>For more details, including goals and responsibilities for maintainers, funding sources, please go to the <a href="https://github.com/typelevel/general/blob/master/sustainability_program.md">program’s main document</a>.</p>

<p>Today we are launching the program with the help of several founding sponsors.</p>

<p><a href="http://47deg.com"><img src="/img/media/sponsors/47_degrees.png" width="80px" height="80px" /></a>
<a href="https://commercetools.com/"><img src="/img/media/sponsors/commercetools_2.png" width="150px" style="margin-top:5px; margin-left: 10px; margin-right: 10px" /></a>
<a href="https://www.inner-product.com/"><img src="/img/media/sponsors/inner-product.png" width="170px" style="margin-bottom:15px; margin-right: 10px" /></a>
<a href="https://triplequote.com/"><img src="/img/media/sponsors/triplequote.png" width="170px" style="margin-bottom:21px; margin-right: 10px" /></a>
<a href="http://underscore.io"><img src="/img/media/sponsors/underscore_2.png" width="150px" style="margin-bottom:8px;" /></a></p>

<p>Thanks to their generosity we are on an excellent start for the sustainability program. However, to successfully support the long term sustainability for our ecosystem, we need every bit of help we can get. For 2019, we have the following initiatives that require a significant investment of maintainer time.</p>

<ul>
  <li>Refactor build configuration</li>
  <li>Continue support Scala 2.11 through backporting</li>
  <li>Complete Scala 2.13 migration</li>
  <li>Support for Scala 3.0 and Scala native</li>
  <li>Revamp guidance documentation for contributors</li>
  <li>Revamp Documentations Navigation</li>
  <li>More tutorial/example documentation</li>
  <li>Complete cats-tagless’ migration away from scala-meta</li>
  <li>Merge in typelevel/algebra</li>
  <li>A community build for the ecosystem</li>
</ul>

<p>Our initial fundraising goal is $150,000. Among other things, achieving this goal will allow us to have a dedicated half-time (20 hr/week) maintainer for at least 2019. Why half time? We want to start with a committed maintainer to bring some certainties for our projects, and yet we are not sure how much support we will be getting from the community. Hence a half-time maintainer for the year is a minimum viable solution for the program.</p>

<p>Please consider talking to your employer about supporting the OSS libraries they are using. Any amount, either $5 per month from a one-person start-up or $5000 per month from a billion dollar corporation, will bring us closer to our goal.</p>

<p>Aside from monetary assistance, your company can also support us by:</p>

<ul>
  <li>Providing computing resources/tools such as CI systems, communication platforms, development tools, etc.</li>
  <li>Paid employees’ time for code contributions</li>
  <li>Sponsoring events such as free training, conferences, by providing the venue, food, etc.</li>
  <li>Donations of training/support services or coupons that we can then exchange for monetary contributions.</li>
</ul>

<p>For individual developers, another way to support us monetarily is to help our fundraising effort by:</p>

<ul>
  <li>spreading the news about our fundraising campaign</li>
  <li>mentioning and linking to our donation page when you write a blog post or give a talk about one of these libraries</li>
  <li>advocating for the sustainable OSS development</li>
</ul>

<p>Please don’t hesitate to reach out with questions. Our contact address is sponsor-contact@typelevel.org.
Thank you for reading this and considering supporting us.</p>

<p><a class="dbox-donation-button" href="https://donorbox.org/typelevel-sustainability-program-2019?default_interval=m" style="background:#F95A66 url(https://d1iczxrky3cnb2.cloudfront.net/white_logo.png) no-repeat 37px center; color: #fff;text-decoration: none;font-family: Verdana,sans-serif;display: inline-block;font-size: 16px;padding: 15px 38px 15px 75px; -webkit-border-radius: 2px; -moz-border-radius: 2px; border-radius: 2px; box-shadow: 0 1px 0 0 #ae3e47; text-shadow: 0 1px rgba(0, 0, 0, 0.3);">Donate</a></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2019/04/24/typelevel-sustainability-program-announcement.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2019/04/24/typelevel-sustainability-program-announcement.html</guid>
      </item>
    
      <item>
        <title>Algebraic API Design - Types, Functions, Properties</title>
        
          <dc:creator>battermann</dc:creator>
                
        <description><![CDATA[<p>In this post we are going to explore the concept of <em>algebraic API design</em> which is based on types, pure functions, and the relationships between them known as domain rules or properties. We will do this based on a complete, self-contained example using Cats and Cats Effect and walk through the process of designing and implementing the domain of solving complex, deterministic single player games.</p>

<p>An API in this context describes the types and operations that a module exposes to the user.</p>

<p>SameGame is a deterministic single player game with perfect information. It has a game-tree complexity of $10^{82}$. In other words it is extremely hard to solve. Exhaustive search strategies and traditional path finding algorithms do not perform well. Monte Carlo tree search which is based on random sampling on the other hand is a promising approach. We will go into more details on these concepts below.</p>

<p>But how can we implement this with functional programming? How can we express algorithms that are based on randomness, mutable state, and side effects in a purely functional way?</p>

<p>All the code in this post is interpreted with <a href="https://github.com/tpolecat/tut">tut</a> to make sure everything type-checks so that the reader gets a complete picture rather than simplistic code samples that don’t actually work. As a downside some of the code is quite lengthy. Please note that it is not required to read and understand every single line.</p>

<p>Let’s have a quick recap on the definition of algebraic structures and how they relate to programming and domain modeling.</p>

<h2 id="algebraic-structures">Algebraic Structures</h2>

<p>An algebraic structure consists of:</p>

<ul>
  <li>One or more <em>sets</em></li>
  <li>A set of <em>operators</em></li>
  <li>A collection of <em>axioms</em> (which the operators are required to satisfy)</li>
</ul>

<p>A prototypical example of an algebraic structure from mathematics is a group. A concrete example of a group is the set $\mathbb{Z}$ of integers together with the addition operator denoted as $(\mathbb{Z}, +)$ that satisfy the group axioms.</p>

<p>A group can be defined in an abstract way like this:</p>

<ul>
  <li><em>Set</em> and <em>operator</em>: $(G, \circ)$</li>
  <li><em>Axioms</em>:
    <ul>
      <li>Closure: $\forall a, b \in G:a \circ b \in G$</li>
      <li>Associativity: $\forall a, b, c \in G: a \circ (b \circ c) = (a \circ b) \circ c$</li>
      <li>Identity: $\exists e \in G: \forall a \in G:e \circ a = a = a \circ e$</li>
      <li>Inverse: $\forall a \in G: \exists b \in G:a \circ b = e = b \circ a$</li>
    </ul>
  </li>
</ul>

<h2 id="programming">Programming</h2>

<p>There is an analogy in programming where:</p>

<ul>
  <li>Sets are <em>types</em> (specifically algebraic data types)</li>
  <li>Operators are <em>functions</em></li>
  <li>Axioms are <em>properties</em> (predicates expressed in terms of the algebra backed up by property-based tests)</li>
</ul>

<p>The <a href="https://typelevel.org/cats/typeclasses.html">type classes provided by Cats</a> follow exactly this pattern. Cats provides representations of many algebraic structures, one of which is <code class="language-plaintext highlighter-rouge">Group[A]</code>. It is defined by a <em>type</em> <code class="language-plaintext highlighter-rouge">A</code> and an <em>operator</em> <code class="language-plaintext highlighter-rouge">combine</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Group</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">inverse</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Group</code> additionally has an empty and an inverse element. Closure is already enforced by the types of the operators. The axioms are expressed as properties.</p>

<p>E.g. for all objects <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">z</code> of type <code class="language-plaintext highlighter-rouge">A</code>, the (<a href="https://github.com/typelevel/cats/blob/master/kernel-laws/src/main/scala/cats/kernel/laws/SemigroupLaws.scala#L8">associative property</a>) must hold:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">semigroupAssociative</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IsEq</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">S</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">S</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nv">S</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">S</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">))</span>
</code></pre></div></div>

<p>We can create a concrete instance of <code class="language-plaintext highlighter-rouge">Group[A]</code>, e.g. according to $(\mathbb{Z}, +)$:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Group</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">group</span><span class="k">:</span> <span class="kt">Group</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Group</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">inverse</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>         <span class="o">=</span> <span class="o">-</span><span class="n">a</span>
  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Int</span>                   <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The verification of the <code class="language-plaintext highlighter-rouge">Group</code> properties for the instance we created can be done with the help of <a href="https://github.com/typelevel/discipline">discipline</a>.</p>

<p>Please note that, while property-based testing is a very powerful tool, it is not the only way to verify properties. There are other methods like dependant types, formal verification, or example-based testing. However, property-based testing works really well and has a huge return on investment.</p>

<h2 id="domain-modeling">Domain Modeling</h2>

<p>Algebraic design is not exclusively applicable to modeling algebraic structures from mathematics such as groups from the example above. We can use exactly the same technique to model the API of any domain.</p>

<p>The elements of algebraic structures can be related to domain driven design as follows:</p>

<ul>
  <li>Sets are <em>types of entities or value objects</em></li>
  <li>Operators are <em>business behavior</em></li>
  <li>Axioms are <em>business rules</em></li>
</ul>

<p>Here is an overview of how algebraic structures, programming, and domain modeling relate to each other:</p>

<table>
  <thead>
    <tr>
      <th>Algebraic Structure</th>
      <th>Programming</th>
      <th>Domain Modeling</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Sets</td>
      <td>Algebraic data types</td>
      <td>Types of entities/value objects</td>
    </tr>
    <tr>
      <td>Operators</td>
      <td>Functions</td>
      <td>Business behavior</td>
    </tr>
    <tr>
      <td>Axioms</td>
      <td>Properties</td>
      <td>Business rules</td>
    </tr>
  </tbody>
</table>

<h2 id="programs">Programs</h2>

<p>Once we’ve defined the algebras that model the API of our domain, we can describe <em>programs</em> in terms of one or more of these algebras. Algebras in programming are also sometimes referred to as embedded domain specific languages (EDSLs). Programs that are composed of algebras or EDSLs are parametrically polymorphic and they know nothing about the algebras’ concrete implementations other than that they satisfy certain properties.</p>

<p>Programs are therefore flexible and constrained at the same time. Flexible in the sense that they can be used with any lawful implementation of the given algebra. And constrained because they can only use the operators provided by the algebra to manipulate values of the types that the algebra is expressed with.</p>

<p>To give a crude, concrete example, a program $p$ is expressed in terms of the algebra of <code class="language-plaintext highlighter-rouge">Group[A]</code>. $p$ can only produce a result by using the operators <code class="language-plaintext highlighter-rouge">combine</code> and <code class="language-plaintext highlighter-rouge">inverse</code> on given input parameters of type <code class="language-plaintext highlighter-rouge">A</code>. Those parameters cannot be manipulated in any other way. Which leaves less room for mistakes and leads to correct programs. The caller of $p$ decides which concrete implementation of <code class="language-plaintext highlighter-rouge">Group[A]</code> they want to provide. Which makes $p$ reusable in multiple different contexts.</p>

<p>We could define a program as follows:</p>

<blockquote>
  <p>A program is a pure polymorphic function that uses algebras by combining their operators with other input parameters to produce a pure value.</p>
</blockquote>

<h2 id="interpreters">Interpreters</h2>

<p>The concrete implementation of an algebra is also know as the <em>interpreter</em> of the algebra. In the example from above the value <code class="language-plaintext highlighter-rouge">group</code> of type <code class="language-plaintext highlighter-rouge">Group[Int]</code> is an interpreter of the algebra of <code class="language-plaintext highlighter-rouge">Group[A]</code>.</p>

<p>This might all sound a bit abstract and theoretical at first. In fact, talking about the concept of algebraic design is one thing, but applying this concept to a real business domain is another.</p>

<p>Let’s look at a concrete and self-contained example.</p>

<h2 id="solving-single-player-games">Solving single player games</h2>

<p><img src="/img/media/samegame.png" alt="SameGame" style="float: right;width: 40%;min-width: 200px;" /></p>

<p>We will write a program that finds solutions for deterministic single player games with a high game-tree complexity like SameGame.</p>

<p>SameGame is played on a $15 \times 15$ board initially filled with blocks of 5 colors. The goal of the game is to remove as many blocks from the board as possible while maximising the score. See <a href="https://en.wikipedia.org/wiki/SameGame">https://en.wikipedia.org/wiki/SameGame</a> for detailed rules. You can play the game at <a href="http://www.js-games.de/eng/games/samegame/lx/play">js-games.de</a> or <a href="https://samegame.surge.sh">https://samegame.surge.sh</a>.</p>

<p>SameGame is a game with perfect information that is very difficult to solve. Given an initial starting position, we can construct a complete game-tree for SameGame as follows:</p>

<ul>
  <li>The nodes of the tree are board positions</li>
  <li>The edges are moves</li>
  <li>Each position (node) contains all possible moves (edges)</li>
  <li>The root node represents the starting position</li>
  <li>The leafs are terminal game states</li>
</ul>

<p>The total number of leafs is the game-tree complexity. The game-tree complexity of Tic-Tac-Toe e.g. is about $10^5$. Tic-Tac-Toe is easy to solve by doing an exhaustive search. Whereas SameGame has a complexity of approximately $10^{82}$. This makes it impossible to solve with a brute-force approach or other traditional algorithms in a reasonable amount of time. Smaller SameGame boards are relatively easy to solve. As the size of the board increases we observe a <em>combinatorial explosion</em>. The time required to find the best solution increases so rapidly that we hit a solvability limit.</p>

<h2 id="monte-carlo-tree-search">Monte Carlo tree search</h2>

<p>When we encounter a combinatorial explosion, <em>stochastic optimization algorithms</em> come to the rescue. Instead of exploring the complete search tree these algorithms sample the search space and can find very good solutions. It is very unlikely, however, that they reach a global maximum and find the best solution in a reasonable amount of time.</p>

<p>A stochastic optimization algorithm that has successfully been employed to game play is known as <em>Monte Carlo tree search</em>. The basic idea of Monte Carlo tree search is to determine the most promising move based on random simulations at each node in the game-tree. In a random simulation the game is played out to the very end by selecting uniformly distributed random moves.</p>

<p>Here is a very simple version of a Monte Carlo tree search:</p>

<ol>
  <li>Choose the root node as the current node $n$ of the game-tree</li>
  <li>For the current node $n$, determine all legal moves $ms$
    <ul>
      <li>If no legal moves exist, the algorithm terminates</li>
    </ul>
  </li>
  <li>Determine all child nodes $cs$ of $n$ by applying each of the moves $ms$ to the current state $n$</li>
  <li>Perform a random simulation for each of the child nodes $cs$</li>
  <li>From the child nodes $cs$ choose the node with the best simulation result, and continue with step 2.</li>
</ol>

<p>A way to improve on this basic algorithm is to add a nested (lower level) search at step 4. such that a random simulation is performed if the current level equals 1, otherwise a <code class="language-plaintext highlighter-rouge">level - 1</code> search is performed.</p>

<p>That’s all we need to know so let’s implement this in a purely functional way using algebraic API design.</p>

<h2 id="game-algebra">Game algebra</h2>

<p>First we define a type that represents the game state:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">GameState</span><span class="o">[</span><span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">](</span>
    <span class="n">playedMoves</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Move</span><span class="o">],</span>
    <span class="n">score</span><span class="k">:</span> <span class="kt">Score</span><span class="o">,</span>
    <span class="n">position</span><span class="k">:</span> <span class="kt">BoardPosition</span><span class="o">,</span>
<span class="o">)</span>
<span class="c1">// defined class GameState
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">GameState</code> consists of <code class="language-plaintext highlighter-rouge">playedMoves</code> (the list of moves that have been played), <code class="language-plaintext highlighter-rouge">score</code> (the current score), and <code class="language-plaintext highlighter-rouge">position</code> (the current board position).</p>

<p>With <code class="language-plaintext highlighter-rouge">GameState</code> we can now express a game algebra like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Game</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">GS</span> <span class="o">=</span> <span class="nc">GameState</span><span class="o">[</span><span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">applyMove</span><span class="o">(</span><span class="n">gameState</span><span class="k">:</span> <span class="kt">GS</span><span class="o">,</span> <span class="n">move</span><span class="k">:</span> <span class="kt">Move</span><span class="o">)</span><span class="k">:</span> <span class="kt">GS</span>
  <span class="k">def</span> <span class="nf">legalMoves</span><span class="o">(</span><span class="n">gameState</span><span class="k">:</span> <span class="kt">GS</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Move</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">simulation</span><span class="o">(</span><span class="n">gameState</span><span class="k">:</span> <span class="kt">GS</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">GS</span><span class="o">]</span>
<span class="o">}</span>
<span class="c1">// defined trait Game
</span></code></pre></div></div>

<p>The type alias <code class="language-plaintext highlighter-rouge">GS</code> only serves better readability.</p>

<p>Note that by parameterizing <code class="language-plaintext highlighter-rouge">Game</code> with <code class="language-plaintext highlighter-rouge">Move</code>, <code class="language-plaintext highlighter-rouge">BoardPosition</code>, and <code class="language-plaintext highlighter-rouge">Score</code> there are no dependencies. It is completely decoupled from any specific domain models. We can fully focus on the contract of the operations rather than having to deal with the implementation or cumbersome domain models.</p>

<p>Furthermore, <code class="language-plaintext highlighter-rouge">Game</code> is defined for any type constructor <code class="language-plaintext highlighter-rouge">F[_]</code> which we use to model effects. By making this type abstract we can defer the decision of which effects we need to a later point in time, respectively at the entry point of the application. Common effect types that could be used are <code class="language-plaintext highlighter-rouge">IO</code>, <code class="language-plaintext highlighter-rouge">Task</code>, <code class="language-plaintext highlighter-rouge">Option</code>, <code class="language-plaintext highlighter-rouge">State</code>, <code class="language-plaintext highlighter-rouge">List</code> etc. or combinations of them. Having an abstract effect type additionally serves better reusability in different contexts like in tests.</p>

<p>While <code class="language-plaintext highlighter-rouge">applyMove</code> and <code class="language-plaintext highlighter-rouge">legalMoves</code> have no effects, <code class="language-plaintext highlighter-rouge">simulation</code> returns an effect <code class="language-plaintext highlighter-rouge">F</code>. Even though one could think of implementations without effects, the implementation of <code class="language-plaintext highlighter-rouge">simulation</code> will use a generator for uniformly distributed random numbers. This can be done by describing a side effect or by using the State Monad. With an abstract effect we are able to choose a specific effect later and make <code class="language-plaintext highlighter-rouge">simulation</code> referentially transparent.</p>

<h2 id="game-properties">Game properties</h2>

<p>Just as an algebraic structure has certain axioms, we can also define properties for the <code class="language-plaintext highlighter-rouge">Game</code> algebra that all interpreters have to satisfy. These properties can be generic or they can be driven by the business rules of the domain.</p>

<p>It is often challenging to come up with meaningful properties for an algebra. However, more and better constraints allow significantly fewer possible implementations of the algebra. Which leads to correct programs because there is less room for errors.</p>

<p>For the sake of brevity let’s consider only two properties:</p>

<ul>
  <li>For all game states, a simulation will lead to a terminal board position</li>
  <li>For all game states, given a move <code class="language-plaintext highlighter-rouge">m</code>, <code class="language-plaintext highlighter-rouge">m</code> is either illegal or when applied leads to a new game state and it increments the number of played moves</li>
</ul>

<p>These rules are expressed as predicates inside the companion object of <code class="language-plaintext highlighter-rouge">Game</code> like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Game</span> <span class="o">{</span>
  <span class="c1">// let's follow the naming convention used by Cats and call this 'laws'
</span>  <span class="k">object</span> <span class="nc">laws</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">cats.Functor</span>
    <span class="k">import</span> <span class="nn">cats.implicits._</span>

    <span class="k">def</span> <span class="nf">simulationIsTerminal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span>, <span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">](</span>
        <span class="n">gameState</span><span class="k">:</span> <span class="kt">GameState</span><span class="o">[</span><span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">])(</span>
        <span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Game</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">ev</span><span class="o">.</span><span class="py">simulation</span><span class="o">(</span><span class="n">gameState</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">ev</span><span class="o">.</span><span class="py">legalMoves</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">legalMoveModifiesGameState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">](</span>
        <span class="n">gameState</span><span class="k">:</span> <span class="kt">GameState</span><span class="o">[</span><span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">],</span>
        <span class="n">move</span><span class="k">:</span> <span class="kt">Move</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Game</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Move</span>, <span class="kt">BoardPosition</span>, <span class="kt">Score</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">legalMoves</span>    <span class="k">=</span> <span class="nv">ev</span><span class="o">.</span><span class="py">legalMoves</span><span class="o">(</span><span class="n">gameState</span><span class="o">)</span>
      <span class="k">val</span> <span class="nv">nextGameState</span> <span class="k">=</span> <span class="nv">ev</span><span class="o">.</span><span class="py">applyMove</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">move</span><span class="o">)</span>
      <span class="o">!</span><span class="nv">legalMoves</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="n">move</span><span class="o">)</span> <span class="o">||</span>
        <span class="o">(</span><span class="nv">nextGameState</span><span class="o">.</span><span class="py">position</span> <span class="o">!=</span> <span class="nv">gameState</span><span class="o">.</span><span class="py">position</span> <span class="o">&amp;&amp;</span> <span class="nv">nextGameState</span><span class="o">.</span><span class="py">playedMoves</span><span class="o">.</span><span class="py">length</span> <span class="o">==</span> <span class="nv">gameState</span><span class="o">.</span><span class="py">playedMoves</span><span class="o">.</span><span class="py">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>There is an additional constraint that we discover while implementing the predicates that define the properties of <code class="language-plaintext highlighter-rouge">Game</code>. <code class="language-plaintext highlighter-rouge">F</code> must have a <code class="language-plaintext highlighter-rouge">Functor</code> instance. <code class="language-plaintext highlighter-rouge">Functor</code> is the least powerful abstraction that allows us to access the value inside <code class="language-plaintext highlighter-rouge">F</code> and express the property related to <code class="language-plaintext highlighter-rouge">simulation</code>. In the next section we will see that the program we are going to write will imply additional constraints for <code class="language-plaintext highlighter-rouge">F</code>.</p>

<p>The properties of <code class="language-plaintext highlighter-rouge">Game</code> are tightly coupled to the algebra as any implementation must satisfy them. This is why they are defined inside the companion object of <code class="language-plaintext highlighter-rouge">Game</code> as part of the library code.</p>

<p>Later we will see how to implement property-based tests to verify the properties.</p>

<h2 id="programs-1">Programs</h2>

<p>The <code class="language-plaintext highlighter-rouge">Game</code> properties are expressed solely in terms of the <code class="language-plaintext highlighter-rouge">Game</code> algebra. We have no idea how <code class="language-plaintext highlighter-rouge">Game</code> is implemented or what the types <code class="language-plaintext highlighter-rouge">Move</code>, <code class="language-plaintext highlighter-rouge">BoardPosition</code>, or <code class="language-plaintext highlighter-rouge">Score</code> look like. In a similar fashion we will only use the algebra to implement programs such as the search algorithm described above.</p>

<p>Before we do this, we will define another algebra that describes logging, simply for convenience. Especially during long running searches it is useful to be able to output intermediate results and search states:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Show</span>

<span class="k">trait</span> <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">log</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Show</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Logger</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]()(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="n">ev</span>
<span class="o">}</span>
</code></pre></div></div>

<p>With the two algebras <code class="language-plaintext highlighter-rouge">Game</code> and <code class="language-plaintext highlighter-rouge">Logger</code> we can now implement the nested Monte Carlo tree search.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>
<span class="c1">// import cats.Monad
</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="k">def</span> <span class="nf">nestedSearch</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Logger</span>, <span class="kt">Move</span>, <span class="kt">Position</span>, <span class="kt">Score</span><span class="o">](</span>
    <span class="n">numLevels</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">level</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">gameState</span><span class="k">:</span> <span class="kt">GameState</span><span class="o">[</span><span class="kt">Move</span>, <span class="kt">Position</span>, <span class="kt">Score</span><span class="o">])(</span>
    <span class="k">implicit</span> <span class="n">g</span><span class="k">:</span> <span class="kt">Game</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Move</span>, <span class="kt">Position</span>, <span class="kt">Score</span><span class="o">],</span>
    <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Score</span><span class="o">],</span>
    <span class="n">show</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">GameState</span><span class="o">[</span><span class="kt">Move</span>, <span class="kt">Position</span>, <span class="kt">Score</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">GameState</span><span class="o">[</span><span class="kt">Move</span>, <span class="kt">Position</span>, <span class="kt">Score</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">legalMoves</span> <span class="k">=</span> <span class="nv">g</span><span class="o">.</span><span class="py">legalMoves</span><span class="o">(</span><span class="n">gameState</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">numLevels</span><span class="o">)</span> <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">log</span><span class="o">(</span><span class="n">gameState</span><span class="o">)</span> <span class="nf">else</span> <span class="o">().</span><span class="py">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="n">result</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">legalMoves</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span>
      <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="n">gameState</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">legalMoves</span>
        <span class="o">.</span><span class="py">traverse</span> <span class="o">{</span> <span class="n">move</span> <span class="k">=&gt;</span>
          <span class="nf">if</span> <span class="o">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">val</span> <span class="nv">nextGameState</span> <span class="k">=</span> <span class="nv">g</span><span class="o">.</span><span class="py">applyMove</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">move</span><span class="o">)</span>
            <span class="nv">g</span><span class="o">.</span><span class="py">simulation</span><span class="o">(</span><span class="n">nextGameState</span><span class="o">).</span><span class="py">map</span><span class="o">((</span><span class="n">move</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">val</span> <span class="nv">nextState</span> <span class="k">=</span> <span class="nv">g</span><span class="o">.</span><span class="py">applyMove</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">move</span><span class="o">)</span>
            <span class="n">nestedSearch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Move</span>, <span class="kt">Position</span>, <span class="kt">Score</span><span class="o">](</span><span class="n">numLevels</span><span class="o">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nextState</span><span class="o">).</span><span class="py">map</span><span class="o">((</span><span class="n">move</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
          <span class="o">}</span>
        <span class="o">}</span>
        <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">maxBy</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">_2</span><span class="o">.</span><span class="py">score</span><span class="o">))</span>
        <span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span>
          <span class="nf">case</span> <span class="o">(</span><span class="n">move</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">nestedSearch</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Move</span>, <span class="kt">Position</span>, <span class="kt">Score</span><span class="o">](</span><span class="n">numLevels</span><span class="o">,</span> <span class="n">level</span><span class="o">,</span> <span class="nv">g</span><span class="o">.</span><span class="py">applyMove</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="n">move</span><span class="o">))</span>
        <span class="o">}</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="o">}</span>
<span class="c1">// nestedSearch: [F[_], Move, Position, Score](numLevels: Int, level: Int, gameState: GameState[Move,Position,Score])(implicit evidence$1: cats.Monad[F], implicit evidence$2: Logger[F], implicit g: Game[F,Move,Position,Score], implicit ord: Ordering[Score], implicit show: cats.Show[GameState[Move,Position,Score]])F[GameState[Move,Position,Score]]
</span></code></pre></div></div>

<p>This program describes the nested Monte Carlo tree search algorithm from above. The biggest difference is that this description is statically type checked by the Scala compiler. The effect of mutating the game state is modelled in a purely functional way with recursion. In fact, the state modifications could be modelled with the State Monad as well, but this makes things a bit more complicated especially when we try to parallelize the search.</p>

<p>Note that to implement the algorithm we need a <code class="language-plaintext highlighter-rouge">Monad</code> instance for <code class="language-plaintext highlighter-rouge">F</code>. Other than that we don’t care what <code class="language-plaintext highlighter-rouge">F</code> exactly is.</p>

<p>Moreover, the <code class="language-plaintext highlighter-rouge">nestedSearch</code> function implies additional constraints for <code class="language-plaintext highlighter-rouge">Score</code> and <code class="language-plaintext highlighter-rouge">GameState</code>. We need to pass instances of <code class="language-plaintext highlighter-rouge">Ordering[Score]</code> (because we want to compare scores) and <code class="language-plaintext highlighter-rouge">Show[GameState]</code> (which we need for logging) as implicit parameters.</p>

<h2 id="the-game-interpreter">The Game interpreter</h2>

<p>The game logic itself is defined in the object <code class="language-plaintext highlighter-rouge">SameGame</code> which is not shown here for the sake of brevity. You can find the implementation in <a href="https://gist.github.com/battermann/24d3318ec0cc3de84bfc7e696284aa60">this Gist</a>.</p>

<p>With <code class="language-plaintext highlighter-rouge">SameGame</code> we are able write to an interpreter for <code class="language-plaintext highlighter-rouge">Game</code> that implements the SameGame rules. For the type constructor <code class="language-plaintext highlighter-rouge">F[_]</code> we will choose <code class="language-plaintext highlighter-rouge">IO</code>, so that we can model the side effect of a random number generator in a referentially transparent way. There are other options, like <code class="language-plaintext highlighter-rouge">State</code> e.g. that we will not discuss here. The point is that we are free to use whatever effect type serves our needs, as long as the implementation is pure and the properties of the <code class="language-plaintext highlighter-rouge">Game</code> algebra hold.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="c1">// import cats.effect.IO
</span>
<span class="k">import</span> <span class="nn">SameGame._</span>
<span class="c1">// import SameGame._
</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">game</span><span class="k">:</span> <span class="kt">Game</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Game</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">applyMove</span><span class="o">(</span><span class="n">gameState</span><span class="k">:</span> <span class="kt">GameState</span><span class="o">[</span><span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">],</span>
                  <span class="n">move</span><span class="k">:</span> <span class="kt">Position</span><span class="o">)</span><span class="k">:</span> <span class="kt">GameState</span><span class="o">[</span><span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">gs</span> <span class="k">=</span> <span class="nv">SameGame</span><span class="o">.</span><span class="py">applyMove</span><span class="o">(</span><span class="n">move</span><span class="o">,</span> <span class="nv">gameState</span><span class="o">.</span><span class="py">position</span><span class="o">)</span>
      <span class="nc">GameState</span><span class="o">(</span><span class="n">move</span> <span class="o">::</span> <span class="nv">gameState</span><span class="o">.</span><span class="py">playedMoves</span><span class="o">,</span> <span class="nv">SameGame</span><span class="o">.</span><span class="py">score</span><span class="o">(</span><span class="n">gs</span><span class="o">),</span> <span class="n">gs</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">legalMoves</span><span class="o">(</span><span class="n">gameState</span><span class="k">:</span> <span class="kt">GameState</span><span class="o">[</span><span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Position</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">SameGame</span><span class="o">.</span><span class="py">legalMoves</span><span class="o">(</span><span class="nv">gameState</span><span class="o">.</span><span class="py">position</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">simulation</span><span class="o">(</span><span class="n">gameState</span><span class="k">:</span> <span class="kt">GameState</span><span class="o">[</span><span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">])</span>
      <span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">GameState</span><span class="o">[</span><span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">moves</span> <span class="k">=</span> <span class="nf">legalMoves</span><span class="o">(</span><span class="n">gameState</span><span class="o">)</span>
      <span class="nf">if</span> <span class="o">(</span><span class="nv">moves</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span>
        <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">gameState</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nc">IO</span><span class="o">(</span><span class="nv">scala</span><span class="o">.</span><span class="py">util</span><span class="o">.</span><span class="py">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="nv">moves</span><span class="o">.</span><span class="py">length</span><span class="o">))</span>
          <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">moves</span><span class="o">)</span>
          <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nf">applyMove</span><span class="o">(</span><span class="n">gameState</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
          <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">simulation</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="c1">// game: Game[cats.effect.IO,SameGame.Position,SameGame.SameGameState,Int] = $anon$1@5fffab3
</span></code></pre></div></div>

<p>We must not forget to also implement an interpreter for <code class="language-plaintext highlighter-rouge">Logger</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">logger</span><span class="k">:</span> <span class="kt">Logger</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Logger</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">log</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Show</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="nv">t</span><span class="o">.</span><span class="py">show</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">// logger: Logger[cats.effect.IO] = $anon$1@7b48b7f0
</span></code></pre></div></div>

<p>And some <code class="language-plaintext highlighter-rouge">Show</code> instances to create nicely formatted outputs in a type-safe way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">showCell</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">CellState</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Show</span><span class="o">.</span><span class="py">show</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Empty</span>         <span class="k">=&gt;</span> <span class="s">"-"</span>
  <span class="k">case</span> <span class="nc">Filled</span><span class="o">(</span><span class="nc">Green</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"0"</span>
  <span class="k">case</span> <span class="nc">Filled</span><span class="o">(</span><span class="nc">Blue</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="s">"1"</span>
  <span class="k">case</span> <span class="nc">Filled</span><span class="o">(</span><span class="nc">Red</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="s">"2"</span>
  <span class="k">case</span> <span class="nc">Filled</span><span class="o">(</span><span class="nc">Brown</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"3"</span>
  <span class="k">case</span> <span class="nc">Filled</span><span class="o">(</span><span class="nc">Gray</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="s">"4"</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">showMove</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">Position</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Show</span><span class="o">.</span><span class="py">show</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="n">show</span><span class="s">"(${p.col}, ${p.row})"</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">showList</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Position</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Show</span><span class="o">.</span><span class="py">show</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">show</span><span class="o">).</span><span class="py">mkString</span><span class="o">(</span><span class="s">"["</span><span class="o">,</span> <span class="s">", "</span><span class="o">,</span> <span class="s">"]"</span><span class="o">))</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">showBoard</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">Board</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Show</span><span class="o">.</span><span class="py">show</span><span class="o">(</span>
    <span class="nv">_</span><span class="o">.</span><span class="py">columns</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">col</span> <span class="k">=&gt;</span> <span class="nv">col</span><span class="o">.</span><span class="py">cells</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">show</span><span class="o">).</span><span class="py">reverse</span><span class="o">)</span>
      <span class="o">.</span><span class="py">transpose</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">"["</span><span class="o">,</span> <span class="s">","</span><span class="o">,</span> <span class="s">"]"</span><span class="o">))</span>
      <span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">"\n"</span><span class="o">))</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">showGame</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">SameGameState</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Show</span><span class="o">.</span><span class="py">show</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">InProgress</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">score</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">show</span><span class="s">"$board\n\nScore: $score (game in progress)"</span>
  <span class="k">case</span> <span class="nc">Finished</span><span class="o">(</span><span class="n">board</span><span class="o">,</span> <span class="n">score</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">show</span><span class="s">"$board\n\nScore: $score (game finished)"</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">showGameState</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">GameState</span><span class="o">[</span><span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Show</span><span class="o">.</span><span class="py">show</span><span class="o">(</span><span class="n">t</span> <span class="k">=&gt;</span> <span class="n">show</span><span class="s">"""
                        |${t.position}
                        |Moves: ${t.playedMoves.reverse}
                        |"""</span><span class="o">.</span><span class="py">stripMargin</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="verifying-the-game-properties">Verifying the Game properties</h2>

<p>Now that we have defined the interpreter for <code class="language-plaintext highlighter-rouge">Game</code>, it is time to ensure that <code class="language-plaintext highlighter-rouge">Game</code> properties are satisfied. We will do this with property-based testing and the library ScalaCheck. ScalaCheck uses a large number of randomly generated test cases to verify that the given properties hold.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.scalacheck.</span><span class="o">{</span><span class="nc">Arbitrary</span><span class="o">,</span> <span class="nc">Gen</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">org.scalacheck.Gen._</span>
<span class="k">import</span> <span class="nn">org.scalatest._</span>
<span class="k">import</span> <span class="nn">org.scalatest.prop.PropertyChecks</span>
</code></pre></div></div>

<p>To generate test cases, we have to define how to construct the test inputs. ScalaCheck provides numerous combinators that can be composed to create generators for our domain objects. Here are basic implementations of generators for <code class="language-plaintext highlighter-rouge">GameState</code> and <code class="language-plaintext highlighter-rouge">Postion</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">colEmpty</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">CellState</span><span class="o">]</span> <span class="k">=</span> <span class="nv">List</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="n">size</span><span class="o">)(</span><span class="nc">Empty</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">colNonEmpty</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">CellState</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">numFilled</span> <span class="k">&lt;-</span> <span class="nf">choose</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">size</span><span class="o">)</span>
    <span class="n">filled</span>    <span class="k">&lt;-</span> <span class="nf">listOfN</span><span class="o">(</span><span class="n">numFilled</span><span class="o">,</span> <span class="nf">choose</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="nc">Filled</span><span class="o">(</span><span class="nc">Color</span><span class="o">(</span><span class="n">c</span><span class="o">))))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">filled</span> <span class="o">++</span> <span class="nf">colEmpty</span><span class="o">(</span><span class="n">size</span> <span class="o">-</span> <span class="nv">filled</span><span class="o">.</span><span class="py">length</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">gameState</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">GameState</span><span class="o">[</span><span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">size</span>      <span class="k">&lt;-</span> <span class="nf">choose</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span>
    <span class="n">numFilled</span> <span class="k">&lt;-</span> <span class="nf">choose</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">size</span><span class="o">)</span>
    <span class="n">nonEmpty</span>  <span class="k">&lt;-</span> <span class="nf">listOfN</span><span class="o">(</span><span class="n">numFilled</span><span class="o">,</span> <span class="nf">colNonEmpty</span><span class="o">(</span><span class="n">size</span><span class="o">)).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Column</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
    <span class="n">empty</span>     <span class="k">&lt;-</span> <span class="nf">listOfN</span><span class="o">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">numFilled</span><span class="o">,</span> <span class="nf">const</span><span class="o">(</span><span class="nf">colEmpty</span><span class="o">(</span><span class="n">size</span><span class="o">))).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Column</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
    <span class="n">score</span>     <span class="k">&lt;-</span> <span class="nv">Arbitrary</span><span class="o">.</span><span class="py">arbitrary</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="o">}</span> <span class="k">yield</span>
    <span class="nc">GameState</span><span class="o">(</span>
      <span class="n">playedMoves</span> <span class="k">=</span> <span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">Position</span><span class="o">],</span>
      <span class="n">position</span> <span class="k">=</span> <span class="nv">SameGame</span><span class="o">.</span><span class="py">evaluateGameState</span><span class="o">(</span><span class="nc">Board</span><span class="o">(</span><span class="n">nonEmpty</span> <span class="o">++</span> <span class="n">empty</span><span class="o">),</span> <span class="n">score</span><span class="o">),</span>
      <span class="n">score</span> <span class="k">=</span> <span class="n">score</span>
    <span class="o">)</span>

<span class="k">def</span> <span class="nf">move</span><span class="o">(</span><span class="n">boardSize</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Position</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">col</span> <span class="k">&lt;-</span> <span class="nf">choose</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">boardSize</span><span class="o">)</span>
    <span class="n">row</span> <span class="k">&lt;-</span> <span class="nf">choose</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">boardSize</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="nc">Position</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="n">row</span><span class="o">)</span>
</code></pre></div></div>

<p>Implementing the property checks is now straight forward:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GameTests</span> <span class="k">extends</span> <span class="nc">PropSpec</span> <span class="k">with</span> <span class="nc">PropertyChecks</span> <span class="k">with</span> <span class="nc">Matchers</span> <span class="o">{</span>
  <span class="nf">property</span><span class="o">(</span><span class="s">"simulation is terminal"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nf">forAll</span><span class="o">(</span><span class="nf">gameState</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">))</span> <span class="o">{</span> <span class="n">gs</span> <span class="k">=&gt;</span>
      <span class="nv">Game</span><span class="o">.</span><span class="py">laws</span>
        <span class="o">.</span><span class="py">simulationIsTerminal</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">](</span><span class="n">gs</span><span class="o">)</span>
        <span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nf">property</span><span class="o">(</span><span class="s">"legal move modifies game state"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nf">forAll</span><span class="o">(</span><span class="nf">gameState</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">),</span> <span class="nf">move</span><span class="o">(</span><span class="mi">8</span><span class="o">))</span> <span class="o">{</span>
      <span class="nf">case</span> <span class="o">(</span><span class="n">gs</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">Game</span><span class="o">.</span><span class="py">laws</span>
          <span class="o">.</span><span class="py">legalMoveModifiesGameState</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">](</span><span class="n">gs</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// defined class GameTests
</span></code></pre></div></div>

<p>Finally we run our tests. In the Scala REPL this can be done like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">run</span><span class="o">(</span><span class="k">new</span> <span class="nc">GameTests</span><span class="o">)</span>
<span class="c1">// GameTests:
// - simulation is terminal
// - legal move modifies game state
</span></code></pre></div></div>

<p>Of course, there are additional test strategies that can be employed. In particular, it is useful to test not only the interpreters, but to test the program, too. However, this goes beyond the scope of this post. For more information on testing in the world of functional programming please, refer to the links in the resource section below.</p>

<h2 id="application">Application</h2>

<p>With <code class="language-plaintext highlighter-rouge">cats.effect.IOApp</code> we describe a purely functional program that performs a Monte Carlo tree search for a given initial board position. For demonstration purposes we use a smaller board of size $6 \times 6$ to shorten the search time.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="c1">// import cats.effect._
</span>
<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">board6x6</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
      <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
      <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
      <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
      <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
      <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span>
      <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">)</span>

    <span class="k">val</span> <span class="nv">initial</span> <span class="k">=</span>
      <span class="nc">GameState</span><span class="o">(</span><span class="n">playedMoves</span> <span class="k">=</span> <span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">Position</span><span class="o">],</span> <span class="n">score</span> <span class="k">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">position</span> <span class="k">=</span> <span class="nc">SameGame</span><span class="o">(</span><span class="n">board6x6</span><span class="o">))</span>

    <span class="k">val</span> <span class="nv">level</span> <span class="k">=</span> <span class="mi">4</span>

    <span class="n">nestedSearch</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Position</span>, <span class="kt">SameGameState</span>, <span class="kt">Int</span><span class="o">](</span><span class="n">level</span><span class="o">,</span> <span class="n">level</span><span class="o">,</span> <span class="n">initial</span><span class="o">)</span>
      <span class="o">.</span><span class="py">as</span><span class="o">(</span><span class="nv">ExitCode</span><span class="o">.</span><span class="py">Success</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// defined object Main
</span></code></pre></div></div>

<p>When we look at the code we cannot explicitly see that the instances of <code class="language-plaintext highlighter-rouge">Game</code>, <code class="language-plaintext highlighter-rouge">Logger</code>, <code class="language-plaintext highlighter-rouge">Ordering</code>, and <code class="language-plaintext highlighter-rouge">Show</code> are passed to the <code class="language-plaintext highlighter-rouge">nestedSearch</code> function as implicit parameters. They have been defined above and can be successfully resolved by the compiler because of the REPL style code, presented here. In a normal Scala application those instances are imported into the scope in the main method - at the entry point of the application.</p>

<p><code class="language-plaintext highlighter-rouge">nestedSearch</code> returns a value of type <code class="language-plaintext highlighter-rouge">IO[GameState[Position, SameGameState, Int]]</code>. The return value can be ignored in this case because all the interesting information is logged by the program. <code class="language-plaintext highlighter-rouge">IOApp</code> takes care of and hides the execution of the <code class="language-plaintext highlighter-rouge">IO</code>.</p>

<p>The truncated sample output from the application:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,4,4,-,-,-]
[1,0,4,-,-,-]
[0,0,1,-,-,-]

Score: 16 (game in progress)
Moves: [(1, 1), (3, 2), (2, 0), (0, 2), (1, 0), (1, 0), (2, 3), (1, 3), (0, 2), (0, 1)]


[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[1,0,-,-,-,-]
[0,0,1,-,-,-]

Score: 17 (game in progress)
Moves: [(1, 1), (3, 2), (2, 0), (0, 2), (1, 0), (1, 0), (2, 3), (1, 3), (0, 2), (0, 1), (1, 2)]


[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[1,1,-,-,-,-]

Score: 18 (game in progress)
Moves: [(1, 1), (3, 2), (2, 0), (0, 2), (1, 0), (1, 0), (2, 3), (1, 3), (0, 2), (0, 1), (1, 2), (0, 0)]


[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]
[-,-,-,-,-,-]

Score: 1018 (game finished)
Moves: [(1, 1), (3, 2), (2, 0), (0, 2), (1, 0), (1, 0), (2, 3), (1, 3), (0, 2), (0, 1), (1, 2), (0, 0), (0, 0)]
</code></pre></div></div>

<h2 id="improving-on-the-results">Improving on the results</h2>

<p><img src="/img/media/highscore.png" alt="SameGame Highscores" style="float: right;width: 40%;min-width: 200px;" /></p>

<p>The Monte Carlo tree search algorithm presented in this post has been intentionally kept simple. There are numerous different strategies of how to guide the tree search based on heuristics to influence the choice of moves which require multiple parameters that have to be fine tuned to maximize the outcomes.</p>

<p>A way to greatly improve on results of the algorithm presented here is to store best paths that were found in lower level searches which might otherwise be lost. We can apply domain-specific knowledge as well, as opposed to completely relying on random sampling. For SameGame e.g. there is a strategy called Tabu-Color which determines the most frequent color occurring at the start of each simulation. This predominat color is not allowed to be played because it is known to be advantageous to create large groups of blocks. Furthermore, parallelization can significantly shorten the search time.</p>

<p>Please refer to <a href="https://github.com/battermann/mcs">this GitHub repository</a> where the techniques mentioned above are applied. While still simple this implementation leads to very promising results. The algorithm was able to discover a solution with a top ten score at <a href="http://www.js-games.de/eng/highscores/samegame/lx">js-games.de</a>.</p>

<p>Another very promising strategy that can be combined with a Monte Carlo tree search is <a href="https://en.wikipedia.org/wiki/Simulated_annealing">simulated annealing</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We have covered a lot of things. Some of the details might have been challenging depending on your prior knowledge of the topics introduced in this post. The reason for presenting such extensive examples is to provide complete and compiling code and to make a point that we do not only get great benefits from functional programming techniques, but that they are also feasible for real world problems.</p>

<p>These are the key takeaways:</p>

<ul>
  <li>An algebra is defined in terms of sets, operators and axioms</li>
  <li>In functional programming algebras are expressed with types, functions and properties</li>
  <li>This relates nicely to types of entities and value objects, business behavior and business rules in the context of domain driven design</li>
  <li>Algebras are abstract and decoupled from any actual implementation which makes them more flexible and constrained at the same time</li>
  <li>Property-based tests and parametric polymorphism constrain the possible implementations and lead to correct programs</li>
  <li>Functional programming techniques are feasible and beneficial for real world programming</li>
</ul>

<p><em>The code has been interpreted with tut, using Scala 2.12.7, scalatest 3.0.5, scalacheck 1.14.0, and cats-effect 1.1.0.</em></p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.manning.com/books/functional-and-reactive-domain-modeling">Functional and Reactive Domain Modeling</a> by Debasish Ghosh</li>
  <li><a href="https://www.lamsade.dauphine.fr/~cazenave/papers/nested.pdf">Nested Monte-Carlo Search</a> by Tristan Cazenave</li>
  <li><a href="https://www.youtube.com/watch?v=cW5RY_x0Pbs">Testing in the world of Functional Programming</a> by Luka Jacobowitz</li>
  <li><a href="https://github.com/battermann/mcs">Sample code on GitHub</a></li>
</ul>

<p><em>Thanks to <a href="https://twitter.com/DgtlNmd">Jarrod Urban</a> who did a very thorough review of this post.</em></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2019/02/06/algebraic-api-design.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2019/02/06/algebraic-api-design.html</guid>
      </item>
    
      <item>
        <title>Cats Ecosystem Community Survey 2018 Results</title>
        
          <dc:creator>kailuowang</dc:creator>
                
        <description><![CDATA[<p>Overall we received 588 responses over the course of 30 days. This feedback is essential for us to make informed decisions on our 2019 plan. Thank you, everyone, who participated.</p>

<p>As promised, here are the results, as well as some quick reads from us.</p>

<p><br /><br /><br /></p>
<h3 id="q-how-long-have-you-been-using-the-cats-ecosystem-including-cats-and-cats-ecosystem-libraries">Q: How long have you been using the Cats ecosystem (including Cats and Cats ecosystem libraries)?</h3>
<h4 id="results">Results:</h4>
<p><img src="/img/media/2018-survey/5WuSHVP.png" alt="1" /></p>

<h4 id="our-read">Our read:</h4>
<p>46% of the respondents are relatively new (less than 1 year) users. Welcome!</p>

<p><br /><br /><br /></p>
<h3 id="q-do-you-feel-welcome-in-the-cats-ecosystem-community">Q: Do you feel welcome in the Cats ecosystem community?</h3>

<h4 id="results-1">Results:</h4>
<p><img src="/img/media/2018-survey/JjK3muU.png" alt="2" /></p>

<h4 id="our-read-1">Our read:</h4>
<p>83% of users gave the 4+ ratings on the welcomeness of the community. This is a promising sign. We should aim for having more 5 ratings (currently at 42.5%) and fewer 3- ones.</p>

<p><br /><br /><br /></p>
<h3 id="q-how-can-we-be-more-welcoming">Q: How can we be more welcoming?</h3>

<h4 id="responses-summary">Responses summary:</h4>
<p>We received 92 responses on this free-form question. The vast majority, 90+%, of them suggested that more documentation, tutorials, and real-world examples would help them feel more welcome. Some of them suggested that the learning curve could be less intimidating to them if there were more introductory resources.</p>

<h4 id="our-read-2">Our read:</h4>

<p>The learning curve for Cats ecosystem libraries could be steep for people new to pure functional programming. This is by far the most impactful area for us to work on to be more inclusive.</p>

<p><br /><br /><br /></p>
<h3 id="q-in-what-types-of-projects-do-you-primarily-use-the-cats-ecosystem">Q: In what types of projects do you primarily use the Cats ecosystem?</h3>

<h4 id="results-2">Results:</h4>
<p><img src="/img/media/2018-survey/uqUxPWf.png" alt="3" /></p>

<h4 id="our-read-3">Our read:</h4>
<p>83% of respondents are using Cats ecosystem libraries in production applications. We are honored to have that trust. In the meantime, it’s a great responsibility for us to maintain stability and robustness.</p>

<p><br /><br /><br /></p>
<h3 id="q-in-which-application-domain-do-you-primarily-use-the-cats-ecosystem">Q: In which application domain do you primarily use the Cats ecosystem?</h3>

<h4 id="results-3">Results:</h4>
<p><img src="/img/media/2018-survey/cOhZ8W3.png" alt="4" /></p>

<p>The free form <code class="language-plaintext highlighter-rouge">other</code> responses are omitted for the sake of conciseness.</p>

<p><br /><br /><br /></p>
<h3 id="q-if-you-use-cats-directly-how-is-your-overall-experience-using-cats">Q: If you use Cats directly, how is your overall experience using Cats?</h3>

<h4 id="results-4">Results:</h4>
<p><img src="/img/media/2018-survey/q2WjZ1d.png" alt="5" /></p>

<h3 id="q-what-would-significantly-improve-your-experience-using-cats">Q: What would significantly improve your experience using Cats?</h3>
<h4 id="results-5">Results:</h4>
<p><img src="/img/media/2018-survey/3ne70PU.png" alt="5" /></p>

<p>The free form <code class="language-plaintext highlighter-rouge">other</code> responses can be summarized as</p>
<ol>
  <li>better IDE support 10 (1.8%)</li>
  <li>better imports 7 (1.3%)</li>
  <li>better integration with other libs 3 (0.6%)</li>
</ol>

<h4 id="our-read-4">Our read:</h4>
<p>Overall the experience is mostly positive for our users. 73% of them believe there is space for improvements - they gave a rating less than 5. Again, more documentation and training will help most users. 25% of users are looking for more features.</p>

<p><br /><br /><br /></p>
<h3 id="q-if-you-are-contributing-to-cats-thank-you-how-is-your-overall-experience-contributing">Q: If you are contributing to Cats, thank you! How is your overall experience contributing?</h3>
<h4 id="results-6">Results:</h4>
<p><img src="/img/media/2018-survey/XpVHZar.png" alt="6" /></p>

<h3 id="q-what-would-significantly-improve-your-contributing-experience">Q: What would significantly improve your contributing experience?</h3>
<h4 id="results-7">Results:</h4>
<p><img src="/img/media/2018-survey/BA1ShtM.png" alt="6" /></p>

<h4 id="our-read-5">Our read:</h4>
<p>The contributing experience is good/okay but not really great. There is still a lot of work to be done here.</p>

<p><br /><br /><br /></p>
<h3 id="q-for-your-applications-what-would-be-a-good-time-line-for-the-cats-ecosystem-to-drop-scala-211-support">Q: For your applications, what would be a good time line for the Cats ecosystem to drop Scala 2.11 support?</h3>
<h4 id="results-8">Results:</h4>
<p><img src="/img/media/2018-survey/C5OdxEK.png" alt="6" /></p>

<h4 id="our-read-6">Our read:</h4>
<p>26% of our users still can’t migrate to Scala 2.12 before second half of 2019.</p>

<p><br /><br /><br /></p>
<h3 id="q-if-you-are-blocked-from-upgrading-to-scala-212-by-what">Q: If you are blocked from upgrading to Scala 2.12, by what?</h3>
<h4 id="results-9">Results:</h4>
<p><img src="/img/media/2018-survey/C60Td4Q.png" alt="6" /></p>

<p><br /><br /><br /></p>
<h3 id="q-what-would-be-a-good-cadence-for-cats-to-release-a-new-major-version-backward-incompatible-with-previous-ones">Q: What would be a good cadence for Cats to release a new major version (backward incompatible with previous ones)?</h3>
<h4 id="results-10">Results:</h4>
<p><img src="/img/media/2018-survey/slzrAHi.png" alt="6" /></p>

<h4 id="our-read-7">Our read:</h4>
<p>The community is split on this one. There are slightly more users that prefer a longer cadence (18-36 or in sync with Scala minor version) than those who prefer a shorter one (12-18 months).</p>

<p><br /><br /><br /></p>
<h3 id="q-how-are-you-using-cats-laws">Q: How are you using cats-laws?</h3>
<h4 id="results-11">Results:</h4>
<p><img src="/img/media/2018-survey/mNbUBxW.png" alt="6" /></p>

<h3 id="q-how-would-a-breaking-change-in-cats-laws-affect-you">Q: How would a breaking change in cats-laws affect you?</h3>
<h4 id="results-12">Results:</h4>
<p><img src="/img/media/2018-survey/TiDFfzZ.png" alt="6" /></p>

<h4 id="our-read-8">Our Read:</h4>
<p>Breaking Cats-laws’s backward compatibility might be blockers for roughly 6% of the users.</p>

<p><br /><br /><br /></p>
<h3 id="q-would-you-benefit-or-suffer-from-cats-laws-and-cats-testkit-being-updated-to-scalacheck-114-which-is-binary-breaking-with-scalacheck-113">Q: Would you benefit or suffer from cats-laws and cats-testkit being updated to Scalacheck 1.14 which is binary breaking with Scalacheck 1.13?</h3>
<h4 id="results-13">Results:</h4>
<p><img src="/img/media/2018-survey/xGjcmj6.png" alt="6" /></p>
<h4 id="our-read-9">Our Read:</h4>
<p>While most people are neutral on this one, there are significantly more users (14.2%) who would benefit from a Scalacheck 1.14 upgrade than those who would suffer (1%).</p>

<p><br /><br /><br /></p>
<h3 id="q-cats-and-most-of-its-ecosystem-libraries-are-maintained-by-hobbyists-on-their-spare-time-how-would-you-feel-about-the-future-of-the-cats-ecosystem-if-there-were-financial-backing-to-allow-full-time-or-part-time-maintainers">Q: Cats and most of its ecosystem libraries are maintained by hobbyists on their spare time. How would you feel about the future of the Cats ecosystem if there were financial backing to allow full-time or part-time maintainers?</h3>
<h4 id="results-14">Results:</h4>
<p><img src="/img/media/2018-survey/YDmhHTo.png" alt="6" /></p>

<h4 id="our-read-10">Our Read:</h4>
<p>In regards to financially backed full-time or part-time maintainers, it would give more confidence to 69.9% users while reducing it for 3% of the users.</p>

<p><br /><br /><br /></p>
<h3 id="q-if-you-are-against-having-compensated-maintainers-what-is-your-concern">Q: If you are against having compensated maintainers, what is your concern?</h3>
<h4 id="the-free-form-answers-can-be-summarized-as">The free form answers can be summarized as</h4>
<ul>
  <li>Vendor favoritism and influence</li>
  <li>Conflicts of interest</li>
  <li>Discouraging non compensated maintainers</li>
  <li>Paid maintainer over contributing unnecessary features</li>
</ul>

<h4 id="our-read-11">Our Read:</h4>
<p>These concerns will be taken into consideration when we, if we decide to, design an institution to support paid maintainership.</p>

<p><br /><br /><br /></p>
<h3 id="q-if-you-are-in-favor-of-compensated-maintainers-which-financial-sources-would-help-boost-your-confidence-in-the-ecosystem-the-most">Q: If you are in favor of compensated maintainers, which financial source(s) would help boost your confidence in the ecosystem the most?</h3>
<h4 id="results-15">Results:</h4>
<p><img src="/img/media/2018-survey/8VbOtFS.png" alt="6" /></p>

<p><br /><br /><br /></p>
<h3 id="q-if-you-are-in-favor-of-corporate-contribution-would-your-employer-be-interested">Q: If you are in favor of corporate contribution, would your employer be interested?</h3>
<h4 id="results-16">Results:</h4>
<p><img src="/img/media/2018-survey/evmpmZK.png" alt="6" /></p>

<p><br /><br /><br /></p>
<h3 id="q-would-you-like-to-participate-in-cats-ecosystem-community-surveys-going-forward">Q: Would you like to participate in Cats ecosystem community surveys going forward?</h3>
<h4 id="results-17">Results:</h4>
<p><img src="/img/media/2018-survey/DoZYt4i.png" alt="6" /></p>

<p><br /><br /><br /></p>
<h3 id="q-please-leave-any-additional-feedbacksuggestions-below">Q: Please leave any additional feedback/suggestions below.</h3>
<h4 id="we-received-many-kind-words-here-we-cant-list-all-of-them-but-here-are-a-few-examples">We received many kind words here, we can’t list all of them but here are a few examples</h4>
<ul>
  <li><em>Gitter support for the cats ecosystem is the best I’ve had in any language or toolset</em></li>
  <li><em>Great work, the progress in cats in the last year has had significant positive impact in my work. Thank you.</em></li>
  <li><em>Thanks for providing amazing libraries that are not only very solid but also a joy to use!</em></li>
</ul>

<p><br /><br /><br /><br />
Overall we are encouraged by the survey responses from the community, in the meantime, they also showed us many areas to improve. Our 2019 planning will be based on these remarkably valuable feedbacks. We hope to present it to the community soon.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2019/01/30/cats-ecosystem-community-survey-results.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2019/01/30/cats-ecosystem-community-survey-results.html</guid>
      </item>
    
      <item>
        <title>Error handling in Http4s with classy optics – Part 2</title>
        
          <dc:creator>gvolpe</dc:creator>
                
        <description><![CDATA[<p>This is a continuation of my <a href="https://typelevel.org/blog/2018/08/25/http4s-error-handling-mtl.html">previous blog post</a>. Make sure you have read that one before continuing here.</p>

<p>I recently gave a 20 minutes talk on <code class="language-plaintext highlighter-rouge">classy optics</code> at the unconference of <a href="http://scale.bythebay.io/">Scale by the Bay</a> where I also talked about this error handling technique and on my way back home I was still thinking of different ways of doing this. So, after some exploratory work, I came up with a few different alternatives.</p>

<h3 id="issues-with-first-approach">Issues with first approach</h3>

<p>Something that made me cringe and that a few of my colleagues at work were not happy with was that the algebras had no association with the error type defined in <code class="language-plaintext highlighter-rouge">HttpErrorHandler[F, E]</code> so the type-safety was down to the programmer’s discipline and in this case the compiler was not able to do much.</p>

<p>When working with <code class="language-plaintext highlighter-rouge">EitherT[F, E, A]</code> or a bifunctor <code class="language-plaintext highlighter-rouge">IO[E, A]</code> we have a clear error type whereas by just relying on a single <code class="language-plaintext highlighter-rouge">F[A]</code> with a <code class="language-plaintext highlighter-rouge">MonadError[F, Throwable]</code> instance we lose this property. There are a few issues with the first though:</p>

<ul>
  <li>It has a “double error channel”, meaning that can report errors via <code class="language-plaintext highlighter-rouge">Left</code> or via its effect type <code class="language-plaintext highlighter-rouge">IO</code>.</li>
  <li>As any other Monad Transformer in Scala, introduces a performance overhead due to the extra <code class="language-plaintext highlighter-rouge">flatMap</code> calls and extra allocations.</li>
  <li>Code becomes cumbersome as we need to lift effects and pure <code class="language-plaintext highlighter-rouge">Either</code> values into the transformer stack.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">IO[E, A]</code> model is naturally a better approach but I found out polymorphic code is more cumbersome than working with <code class="language-plaintext highlighter-rouge">F[A]</code>. Although this might change once <a href="https://github.com/typelevel/cats-effect/issues/321">Cats Effect 2.0</a> is out, it’ll take a while until we get there.</p>

<h4 id="errors-vs-failures">Errors vs Failures</h4>

<p>What I like about the <code class="language-plaintext highlighter-rouge">IO[E, A]</code> model is that we can distinguish between “business errors” and “unexpected failures” such as a database connection failure (learn more about <code class="language-plaintext highlighter-rouge">zio</code>’s error model <a href="https://scalaz.github.io/scalaz-zio/">here</a>). Eg: when working on a REST API, most of the time we only care about mapping a few business errors into the appropriate http responses. The unexpected failures should be handled by someone else. In this case <code class="language-plaintext highlighter-rouge">http4s</code> will convert any failure into a response with code 500 (internal server error).</p>

<p>And this is exactly what we want to achieve here. Writing polymorphic code using <code class="language-plaintext highlighter-rouge">cats-effect</code> while trying to keep it as simple as possible. Here’s an encoding I would like to explore further:</p>

<h3 id="error-channel">Error Channel</h3>

<p>In the previous blog post we defined the algebras as a single trait. In this case we are going to try a different encoding but first we need to introduce an <code class="language-plaintext highlighter-rouge">ErrorChannel[F, E]</code> typeclass where the error type is a subtype of <code class="language-plaintext highlighter-rouge">Throwable</code> to be compatible with the error type of the <code class="language-plaintext highlighter-rouge">cats-effect</code> typeclasses:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ErrorChannel</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">raise</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>An instance can be derived for any <code class="language-plaintext highlighter-rouge">ApplicativeError[F, Throwable]</code> so we don’t need to write it manually for every error type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.ApplicativeError</span>

<span class="k">object</span> <span class="nc">ErrorChannel</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ErrorChannel</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span> <span class="k">=</span> <span class="n">ev</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">instance</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">ApplicativeError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Throwable</span><span class="o">])</span><span class="k">:</span> <span class="kt">ErrorChannel</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ErrorChannel</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="nf">raise</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">object</span> <span class="nc">syntax</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ErrorChannelOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ErrorChannel</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">raise</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ErrorChannel</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">].</span><span class="py">raise</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="user-algebra">User Algebra</h3>

<p>Our <code class="language-plaintext highlighter-rouge">UserAlg</code> will now be defined as an <code class="language-plaintext highlighter-rouge">abstract class</code> instead in order to be able to add typeclass constraint.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserUpdateAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">UserAlg</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ErrorChannel</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">updateAge</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And here’s the ADT of the possible errors that may arise (notice the <code class="language-plaintext highlighter-rouge">extends Exception</code> part):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserError</span> <span class="k">extends</span> <span class="nc">Exception</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
</code></pre></div></div>

<p>We want to make sure our ADT is a subtype of <code class="language-plaintext highlighter-rouge">Throwable</code> and indeed <code class="language-plaintext highlighter-rouge">Exception &lt;: Throwable</code>.</p>

<h3 id="user-interpreter">User Interpreter</h3>

<p>Here’s a similar <code class="language-plaintext highlighter-rouge">UserAlg</code> interpreter to the one presented in the previous post. Note that in a real-life project an interpreter will more likely connect to a database instead of using an in-memory representation based on <code class="language-plaintext highlighter-rouge">Ref</code>.</p>

<p>The interesting part is that in order to construct a <code class="language-plaintext highlighter-rouge">UserAlg[F, UserError]</code> we now need an <code class="language-plaintext highlighter-rouge">ErrorChannel[F, UserError]</code> instance in scope. This will be the chosen strategy to report errors in the context of <code class="language-plaintext highlighter-rouge">F</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span> <span class="nc">Concurrent</span><span class="o">,</span> <span class="nc">Sync</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">object</span> <span class="nc">UserInterpreter</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">mkUserAlg</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="k">implicit</span> <span class="n">error</span><span class="k">:</span> <span class="kt">ErrorChannel</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nv">Ref</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">User</span><span class="o">]](</span><span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span> <span class="n">state</span> <span class="k">=&gt;</span>
      <span class="k">new</span> <span class="nc">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">private</span> <span class="k">def</span> <span class="nf">validateAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="nf">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">error</span><span class="o">.</span><span class="py">raise</span><span class="o">(</span><span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="o">))</span> <span class="nf">else</span> <span class="o">().</span><span class="py">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

        <span class="k">override</span> <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
          <span class="nv">state</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">username</span><span class="o">))</span>

        <span class="k">override</span> <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="nf">validateAge</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">age</span><span class="o">)</span> <span class="o">*&gt;</span>
            <span class="nf">find</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nv">error</span><span class="o">.</span><span class="py">raise</span><span class="o">(</span><span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">))</span>
<span class="c1">//                error.raise(new Exception("asd")) // Does not compile
//                Sync[F].raiseError(new Exception("")) // Should be considered an unrecoverable failure
</span>              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
                <span class="nv">state</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">,</span> <span class="n">user</span><span class="o">))</span>
            <span class="o">}</span>

        <span class="k">override</span> <span class="k">def</span> <span class="nf">updateAge</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="nf">validateAge</span><span class="o">(</span><span class="n">age</span><span class="o">)</span> <span class="o">*&gt;</span>
            <span class="nf">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nv">state</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="nv">user</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">age</span> <span class="k">=</span> <span class="n">age</span><span class="o">)))</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
                <span class="nv">error</span><span class="o">.</span><span class="py">raise</span><span class="o">(</span><span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="o">))</span>
            <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Notice that we could still call <code class="language-plaintext highlighter-rouge">Sync[F].raiseError(new Exception("boom"))</code> and it will still compile. However, if we choose to use <code class="language-plaintext highlighter-rouge">ErrorChannel</code> to signal business errors we will have the compiler on our side and it’ll warn us when we try to raise an error that is not part of the ADT we have declared. So signaling error in a different way should just be considered unrecoverable. These are the same semantics you get when working with <code class="language-plaintext highlighter-rouge">EitherT[IO, Throwable, ?]</code> as shown in the comparison table at the beginning.</p>

<h3 id="http-error-handler">Http Error Handler</h3>

<p>Here’s the same <code class="language-plaintext highlighter-rouge">HttpErrorHandler</code> defined in the previous blog post:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span> <span class="nc">ApplicativeError</span><span class="o">,</span> <span class="nc">MonadError</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.data.</span><span class="o">{</span> <span class="nc">Kleisli</span><span class="o">,</span> <span class="nc">OptionT</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">org.http4s._</span>

<span class="k">trait</span> <span class="nc">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">RoutesHttpErrorHandler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ApplicativeError</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span>
      <span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="o">)(</span><span class="n">handler</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Response</span><span class="o">[</span><span class="kt">F</span><span class="o">]])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span> <span class="o">{</span> <span class="n">req</span> <span class="k">=&gt;</span>
      <span class="nc">OptionT</span> <span class="o">{</span>
        <span class="nv">routes</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">req</span><span class="o">).</span><span class="py">value</span><span class="o">.</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">handler</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">HttpErrorHandler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span> <span class="k">=</span> <span class="n">ev</span>

  <span class="k">def</span> <span class="nf">mkInstance</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ApplicativeError</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span>
      <span class="n">handler</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Response</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="o">)</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">RoutesHttpErrorHandler</span><span class="o">(</span><span class="n">routes</span><span class="o">)(</span><span class="n">handler</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="http-routes-with-error-handling">Http Routes with error handling</h3>

<p>Now let’s look at the new implementation of <code class="language-plaintext highlighter-rouge">UserRoutes</code> using the error-type algebra:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.Sync</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>
<span class="k">import</span> <span class="nn">io.circe.generic.auto._</span>
<span class="k">import</span> <span class="nn">io.circe.syntax._</span>
<span class="k">import</span> <span class="nn">org.http4s._</span>
<span class="k">import</span> <span class="nn">org.http4s.circe.CirceEntityDecoder._</span>
<span class="k">import</span> <span class="nn">org.http4s.circe._</span>
<span class="k">import</span> <span class="nn">org.http4s.dsl.Http4sDsl</span>

<span class="k">class</span> <span class="nc">PreUserRoutesMTL</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">users</span><span class="k">:</span> <span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="nv">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">HttpRoutes</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">users</span><span class="o">.</span><span class="py">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span>       <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">User</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
        <span class="nv">users</span><span class="o">.</span><span class="py">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
        <span class="nv">users</span><span class="o">.</span><span class="py">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="nv">userUpdate</span><span class="o">.</span><span class="py">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">routes</span><span class="o">(</span><span class="k">implicit</span> <span class="n">H</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">H</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="n">httpRoutes</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Notice that in contrast to the example shown in the previous blog post there is now a relationship between <code class="language-plaintext highlighter-rouge">UserAlg</code> and <code class="language-plaintext highlighter-rouge">HttpErrorHandler</code>: the error type is the same. However, this is not enforced by the compiler. <em>Can we be more strict about it?</em></p>

<p>We could define a generic <code class="language-plaintext highlighter-rouge">Routes[F, E]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Routes</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">H</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="nf">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="k">val</span> <span class="nv">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">H</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="n">httpRoutes</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But we’ll also need something else to connect the error types of the algebra and the http error handler:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">UserRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span>
    <span class="n">users</span><span class="k">:</span> <span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Routes</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
</code></pre></div></div>

<p>That’s it! We are now enforcing this relationship at compile time. Let’s see how the <code class="language-plaintext highlighter-rouge">HttpRoutes</code> looks like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserRoutesAlt</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">UserError</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span>
    <span class="n">users</span><span class="k">:</span> <span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">UserRoutes</span><span class="o">(</span><span class="n">users</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">protected</span> <span class="k">val</span> <span class="nv">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">HttpRoutes</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">users</span><span class="o">.</span><span class="py">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span>       <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="n">req</span>
        <span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span>
        <span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
          <span class="nv">users</span><span class="o">.</span><span class="py">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
        <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="n">req</span>
        <span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">]</span>
        <span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
          <span class="nv">users</span><span class="o">.</span><span class="py">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="nv">userUpdate</span><span class="o">.</span><span class="py">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
        <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Neat! Right? If we try to change the error type of <code class="language-plaintext highlighter-rouge">UserAlg</code> it wouldn’t compile!</p>

<h3 id="more-than-one-algebra-per-http-route">More than one algebra per Http Route</h3>

<p>In most of my programs I tend to specify an <code class="language-plaintext highlighter-rouge">HttpRoute</code> per algebra. But what if we wanted to just define a single <code class="language-plaintext highlighter-rouge">HttpRoute</code> that uses multiple algebras? There are a couple of options.</p>

<p>Let’s first define a new ADT of errors and a new algebra to illustrate the problem:</p>

<h4 id="catalog-error">Catalog Error</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">CatalogError</span> <span class="k">extends</span> <span class="nc">Exception</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ItemAlreadyExists</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">CatalogError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">CatalogNotFound</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">CatalogError</span>
</code></pre></div></div>

<h4 id="catalogalg">CatalogAlg</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Item</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">CatalogAlg</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">ErrorChannel</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="httproutes-with-multiple-algebras">HttpRoutes with multiple algebras</h4>

<p>Here we have an <code class="language-plaintext highlighter-rouge">HttpRoutes</code> that makes use of two algebras with different error types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserRoutesMTL</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span>
    <span class="n">users</span><span class="k">:</span> <span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">],</span>
    <span class="n">catalog</span><span class="k">:</span> <span class="kt">CatalogAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">CatalogError</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="nv">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="nf">routes</span><span class="o">(</span>
    <span class="k">implicit</span> <span class="n">H1</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">],</span>
             <span class="n">H2</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">CatalogError</span><span class="o">]</span>
  <span class="o">)</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">H2</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="nv">H1</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="n">httpRoutes</span><span class="o">))</span>

<span class="o">}</span>
</code></pre></div></div>

<p>It works! But it’s not as elegant as we would like it to be and if we add more algebras this would quicky get out of control.</p>

<p><em>Can we generalize this pattern?</em></p>

<h3 id="shapeless-coproduct">Shapeless Coproduct</h3>

<p>We can define our error type as a coproduct of different errors, in our case <code class="language-plaintext highlighter-rouge">UserError</code> and <code class="language-plaintext highlighter-rouge">CatalogError</code>. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="k">def</span> <span class="nf">routes</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">H</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span> <span class="kt">:+:</span> <span class="kt">CatalogError</span> <span class="kt">:+:</span> <span class="kt">CNil</span><span class="o">])</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>However, this doesn’t compile because the error type is no longer a subtype of <code class="language-plaintext highlighter-rouge">Throwable</code>. It is now a <code class="language-plaintext highlighter-rouge">Coproduct</code>.</p>

<p>But we might be able to derive an instance for a coproduct of errors if we have an instance of <code class="language-plaintext highlighter-rouge">HttpErrorHandler[F, E]</code> for each error type. Let’s give it a try! We need to define a new typeclass <code class="language-plaintext highlighter-rouge">CoHttpErrorHandler</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="k">trait</span> <span class="nc">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Err</span> <span class="k">&lt;:</span> <span class="kt">Coproduct</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">CoHttpErrorHandler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Err</span> <span class="k">&lt;:</span> <span class="kt">Coproduct</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Err</span><span class="o">])</span> <span class="k">=</span> <span class="n">ev</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">cNilInstance</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">CNil</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">routes</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">consInstance</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Coproduct</span><span class="o">](</span>
      <span class="k">implicit</span> <span class="n">H</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">],</span>
      <span class="nc">CH</span><span class="k">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">T</span><span class="o">]</span>
  <span class="o">)</span><span class="k">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span> <span class="kt">:+:</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nv">CH</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="nv">H</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="n">routes</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Voilà! We introduced a <code class="language-plaintext highlighter-rouge">CoHttpErrorHandler</code> where the error type is a coproduct and the instance can only be derived if each type is a subtype of <code class="language-plaintext highlighter-rouge">Throwable</code> making it impossible to define an invalid coproduct. So it compiles! But how do we use it?</p>

<h3 id="httproutes-for-a-coproduct-of-errors">HttpRoutes for a coproduct of errors</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CoUserRoutesMTL</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span>
    <span class="n">users</span><span class="k">:</span> <span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">],</span>
    <span class="n">catalog</span><span class="k">:</span> <span class="kt">CatalogAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">CatalogError</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="nv">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="nf">routes</span><span class="o">(</span><span class="k">implicit</span> <span class="nc">CH</span><span class="k">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span> <span class="kt">:+:</span> <span class="kt">CatalogError</span> <span class="kt">:+:</span> <span class="kt">CNil</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">CH</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="n">httpRoutes</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Yay!!! Now this is more elegant and generic so we can re-use the same pattern in different routes. But now again we have lost the relationship between the error types of the algebras and the error type of <code class="language-plaintext highlighter-rouge">CoHttpErrorHandler</code>. So maybe we could do something similar to what we have done previously?</p>

<p>It’s possible but in the case of coproducts we need to introduce some boilerplate…</p>

<h4 id="coroutes">CoRoutes</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CoRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Coproduct</span><span class="o">](</span><span class="k">implicit</span> <span class="nc">CH</span><span class="k">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">protected</span> <span class="k">def</span> <span class="nf">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="k">val</span> <span class="nv">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">CH</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="n">httpRoutes</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This one is pretty basic and similar to <code class="language-plaintext highlighter-rouge">Routes</code> defined before.</p>

<h4 id="couserroutes">CoUserRoutes</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CoUserRoutes</span><span class="o">[</span>
    <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>,
    <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span>,
    <span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span>,
    <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Coproduct:</span> <span class="kt">=:=</span><span class="o">[</span><span class="kt">?</span>, <span class="kt">A</span> <span class="kt">:+:</span> <span class="kt">B</span> <span class="kt">:+:</span> <span class="kt">CNil</span><span class="o">]</span>
<span class="o">](</span>
    <span class="n">users</span><span class="k">:</span> <span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">],</span>
    <span class="n">catalog</span><span class="k">:</span> <span class="kt">CatalogAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">CoRoutes</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>

<span class="k">type</span> <span class="kt">CustomError</span> <span class="o">=</span> <span class="nc">UserError</span> <span class="o">:+:</span> <span class="nc">CatalogError</span> <span class="o">:+:</span> <span class="nc">CNil</span>
</code></pre></div></div>

<p>Here we have a couple of constraints:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">F[_]</code> needs to have an instance of <code class="language-plaintext highlighter-rouge">CoHttpErrorHandler[F, E]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are the error types of the two algebras.</li>
  <li><code class="language-plaintext highlighter-rouge">E</code> needs to be a <code class="language-plaintext highlighter-rouge">Coproduct</code> of type <code class="language-plaintext highlighter-rouge">A :+: B :+: CNil</code>.</li>
</ul>

<h4 id="httproutes-with-multiple-algebras---strict-version">HttpRoutes with multiple algebras - Strict version</h4>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CoUserRoutesMTL</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">CoHttpErrorHandler</span><span class="o">[</span><span class="kt">?</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">CustomError</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span>
    <span class="n">users</span><span class="k">:</span> <span class="kt">UserAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">],</span>
    <span class="n">catalog</span><span class="k">:</span> <span class="kt">CatalogAlg</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">CatalogError</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">CoUserRoutes</span><span class="o">(</span><span class="n">users</span><span class="o">,</span> <span class="n">catalog</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">protected</span> <span class="k">val</span> <span class="nv">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Now we are saying that the error type of our <code class="language-plaintext highlighter-rouge">CoHttpErrorHandler</code> is a coproduct of each error type of the algebras. And we wouldn’t be able to change the error type of any of them without getting a compiler error.</p>

<h3 id="source-code">Source code</h3>

<p>You can see all the compiling examples <a href="https://github.com/gvolpe/classy-optics">here</a>. Make sure you check out all the different branches.</p>

<h3 id="conclusion">Conclusion</h3>

<p>The last approach is probably too much but we have demonstrated that it’s possible to push the boundaries to make our application very type-safe. However, we also need to consider the trade-offs of writing more boilerplate.</p>

<p>Personally, I settle for the previous approach where the error type of the algebra matches the error type of the <code class="language-plaintext highlighter-rouge">HttpErrorHandler</code> even if it requires a bit more of discipline. The choice is yours! Just make sure you understand the trade-offs of every mechanism.</p>

<p>I hope you have enjoyed this post and please do let me know if you have other ideas to keep broadening my understanding!</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/11/28/http4s-error-handling-mtl-2.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/11/28/http4s-error-handling-mtl-2.html</guid>
      </item>
    
      <item>
        <title>A tale on Semirings</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p><em>Ever wondered why sum types are called sum types?
Or maybe you’ve always wondered why the <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> operator uses exactly these symbols?
And what do these things have to do with Semirings?
Read this article and find out!</em></p>

<p>Most of us know and use <code class="language-plaintext highlighter-rouge">Monoid</code>s and <code class="language-plaintext highlighter-rouge">Semigroup</code>s.
They’re super useful and come with properties that we can directly utilize to gain a higher level of abstractions at very little cost (In case you don’t know about them, check out the <a href="https://typelevel.org/cats/typeclasses/semigroup.html">Cats documentation</a> for some insight).
Sometimes, however, certain types can have multiple <code class="language-plaintext highlighter-rouge">Monoid</code> or <code class="language-plaintext highlighter-rouge">Semigroup</code> instances.
An easy example are the various numeric types where both multiplication and addition form two completely lawful monoid instances.</p>

<p>In abstract algebra there is a an algebraic class for types with two <code class="language-plaintext highlighter-rouge">Monoid</code> instances that interact in a certain way.
These are called <code class="language-plaintext highlighter-rouge">Semiring</code>s (sometimes also <code class="language-plaintext highlighter-rouge">Rig</code>) and they are defined as two <code class="language-plaintext highlighter-rouge">Monoid</code>s with some special laws that define the interactions between them.
Because they are often used to describe numeric data types we usually classify them as <em>Additive</em> and <em>Multiplicative</em>. 
Just like with numeric types the laws of <code class="language-plaintext highlighter-rouge">Semiring</code> state that multiplication has to distribute over addition and multiplying a value with the additive identity (i.e. zero) absorbs the value and becomes zero.</p>

<p>There are different ways to encode this as type classes and different libraries handle this differently, but let’s look at how the <a href="https://typelevel.org/algebra/">algebra</a> project handles this.
Specifically, it defines a separate <code class="language-plaintext highlighter-rouge">AdditiveSemigroup</code> and <code class="language-plaintext highlighter-rouge">MultiplicativeSemigroup</code> and goes from there.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">simulacrum._</span>

<span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">AdditiveSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">+</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AdditiveSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">MultiplicativeSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">*</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">MultiplicativeMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MultiplicativeSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">one</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">Semiring</code> is then just an <code class="language-plaintext highlighter-rouge">AdditiveMonoid</code> coupled with a <code class="language-plaintext highlighter-rouge">MultiplicativeMonoid</code> with the following extra laws:</p>

<ol>
  <li>Additive commutativity, i.e. <code class="language-plaintext highlighter-rouge">x + y === y + x</code></li>
  <li>Right distributivity, i.e. <code class="language-plaintext highlighter-rouge">(x + y) * z === (x * z) + (y * z)</code></li>
  <li>Left distributivity, i.e. <code class="language-plaintext highlighter-rouge">x * (y + z) === (x * y) + (x * z)</code></li>
  <li>Right absorption, i.e. <code class="language-plaintext highlighter-rouge">x * zero === zero</code></li>
  <li>Left absorption, i.e. <code class="language-plaintext highlighter-rouge">zero * x === zero</code></li>
</ol>

<p>To define it as a type class, we simply extend from both additive and multiplicative monoid:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Semiring</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MultiplicativeMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Now we have a <code class="language-plaintext highlighter-rouge">Semiring</code> class, that we can use with the various numeric types like <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Long</code>, <code class="language-plaintext highlighter-rouge">BigDecimal</code> etc, but what else is a <code class="language-plaintext highlighter-rouge">Semiring</code> and why dedicate a whole blog post to it?</p>

<p>It turns out a lot of interesting things can be <code class="language-plaintext highlighter-rouge">Semiring</code>s, including <code class="language-plaintext highlighter-rouge">Boolean</code>s, <code class="language-plaintext highlighter-rouge">Set</code>s and <a href="https://bkase.github.io/slides/algebra-driven-design/#/">animations</a>.</p>

<p>One very interesting thing I’d like to point out is that we can form a <code class="language-plaintext highlighter-rouge">Semiring</code> homomorphism from types to their number of possible inhabitants.
What the hell is that?
Well, bear with me for a while and I’ll try to explain step by step.</p>

<h3 id="cardinality">Cardinality</h3>

<p>Okay, so let’s start with what I mean by cardinality.
Every type has a specific number of values it can possibly have, e.g. a <code class="language-plaintext highlighter-rouge">Boolean</code> has cardinality of 2, because it has two possible values: <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>So <code class="language-plaintext highlighter-rouge">Boolean</code> has two, how many do other primitive types have?
<code class="language-plaintext highlighter-rouge">Byte</code> has 2^8, <code class="language-plaintext highlighter-rouge">Short</code> has 2^16, <code class="language-plaintext highlighter-rouge">Int</code> has 2^32 and <code class="language-plaintext highlighter-rouge">Long</code> has 2^64.
So far so good, that makes sense, what about something like <code class="language-plaintext highlighter-rouge">String</code>?
<code class="language-plaintext highlighter-rouge">String</code> is an unbounded type and therefore theoretically has infinite number of different inhabitants (practically of course, we don’t have infinite memory, so the actual number may vary depending on your system).</p>

<p>For what other types can we determine their cardinality?
Well a couple of easy ones are <code class="language-plaintext highlighter-rouge">Unit</code>, which has exactly one value it can take and also <code class="language-plaintext highlighter-rouge">Nothing</code>, which is the “bottom” type in Scala, which means being a subtype of every possible other type and has 0 possible values. I.e you can never instantiate a value of <code class="language-plaintext highlighter-rouge">Nothing</code>, which gives it a cardinality of 0.</p>

<p>That’s neat, maybe we can encode this in actual code.
We could create a type class that should be able to give us the number of inhabitants for any type we give it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Cardinality</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">of</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Cardinality</span><span class="o">]</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">cardinality</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Cardinality</span><span class="o">]</span><span class="k">:</span> <span class="kt">Cardinality</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Awesome!
Now let’s try to define some instances for this type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">booleanCardinality</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">longCardinality</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">pow</span><span class="o">(</span><span class="mi">64</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">intCardinality</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">pow</span><span class="o">(</span><span class="mi">32</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">shortCardinality</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Short</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">pow</span><span class="o">(</span><span class="mi">16</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">byteCardinality</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">pow</span><span class="o">(</span><span class="mi">8</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">unitCardinality</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">nothingCardinality</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Alright, this is cool, let’s try it out in the REPL!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">4294967296</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">18446744073709551616</span>
</code></pre></div></div>

<p>Cool, but this is all very simple, what about things like ADTs?
Can we encode them in this way as well?
Turns out, we can, we just have to figure out how to handle the basic product and sum types.
To do so, let’s look at an example of both types.
First, we’ll look at a simple product type: <code class="language-plaintext highlighter-rouge">(Boolean, Byte)</code>.</p>

<p>How many inhabitants does this type have? 
Well, we know <code class="language-plaintext highlighter-rouge">Boolean</code> has 2 and <code class="language-plaintext highlighter-rouge">Byte</code> has 256.
So we have the numbers from <code class="language-plaintext highlighter-rouge">-127</code> to <code class="language-plaintext highlighter-rouge">128</code> once with <code class="language-plaintext highlighter-rouge">true</code> and once again with <code class="language-plaintext highlighter-rouge">false</code>.
That gives us <code class="language-plaintext highlighter-rouge">512</code> unique instances.
Hmmm….</p>

<p><code class="language-plaintext highlighter-rouge">512</code> seems to be double <code class="language-plaintext highlighter-rouge">256</code>, so maybe the simple solution is to just multiply the number of inhabitants of the first type with the number of inhabitants of the second type.
If you try this with other examples, you’ll see that it’s exactly true, awesome!
Let’s encode that fact in a type class instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">tupleCardinality</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Cardinality</span>, <span class="kt">B:</span> <span class="kt">Cardinality</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">cardinality</span> <span class="o">*</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">B</span><span class="o">].</span><span class="py">cardinality</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Great, now let’s look at an example of a simple sum type: <code class="language-plaintext highlighter-rouge">Either[Boolean, Byte]</code>.
Here the answer seems even more straight forward, since a value of this type can either be one or the other, we should just be able to add the number of inhabitants of one side with the number of inhabitants of the other side.
So <code class="language-plaintext highlighter-rouge">Either[Boolean, Byte]</code> should have <code class="language-plaintext highlighter-rouge">2 + 256 = 258</code> number of inhabitants. Cool!</p>

<p>Let’s also code that up and try and confirm what we learned in the REPL:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">eitherCardinality</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Cardinality</span>, <span class="kt">B:</span> <span class="kt">Cardinality</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">cardinality</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">cardinality</span> <span class="o">+</span> <span class="nc">Cardinality</span><span class="o">[</span><span class="kt">B</span><span class="o">].</span><span class="py">cardinality</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[(</span><span class="kt">Boolean</span>, <span class="kt">Byte</span><span class="o">)]</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">512</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">Byte</span><span class="o">]]</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">258</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Int</span>, <span class="o">(</span><span class="kt">Boolean</span>, <span class="kt">Unit</span><span class="o">)]]</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">4294967298</span>
</code></pre></div></div>

<p>So using sum types seem to add the number of inhabitants whereas product types seem to multiply the number of inhabitants.
That makes a lot of sense given their names!</p>

<p>So what about that homomorphism we talked about earlier? 
Well, a homomorphism is a structure-preserving mapping function between two algebraic structures of the same sort (in this case a semiring).</p>

<p>This means that for any two values <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> and the homomorphism <code class="language-plaintext highlighter-rouge">f</code>, we get</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">f(x * y) === f(x) * f(y)</code></li>
  <li><code class="language-plaintext highlighter-rouge">f(x + y) === f(x) + f(y)</code></li>
</ol>

<p>Now this might seem fairly abstract, but it applies exactly to what we just did.
If we <em>“add”</em> two types of <code class="language-plaintext highlighter-rouge">Byte</code> and <code class="language-plaintext highlighter-rouge">Boolean</code>, we get an <code class="language-plaintext highlighter-rouge">Either[Byte, Boolean]</code> and if we apply the homomorphism function, <code class="language-plaintext highlighter-rouge">number</code> to it, we get the value <code class="language-plaintext highlighter-rouge">258</code>.
This is the same as first calling <code class="language-plaintext highlighter-rouge">number</code> on <code class="language-plaintext highlighter-rouge">Byte</code> and then adding that to the result of calling <code class="language-plaintext highlighter-rouge">number</code> on <code class="language-plaintext highlighter-rouge">Boolean</code>.</p>

<p>And of course the same applies to multiplication and product types.
However, we’re still missing something from a valid semiring, we only talked about multiplication and addition, but not about their respective identities.</p>

<p>What we did see, though is that <code class="language-plaintext highlighter-rouge">Unit</code> has exactly one inhabitant and <code class="language-plaintext highlighter-rouge">Nothing</code> has exactly zero.
So maybe we can use these two types to get a fully formed Semiring?</p>

<p>Let’s try it out!
If <code class="language-plaintext highlighter-rouge">Unit</code> is <code class="language-plaintext highlighter-rouge">one</code> then a product type of any type with <code class="language-plaintext highlighter-rouge">Unit</code> should be equivalent to just the first type.</p>

<p>Turns out, it is, we can easily go from something like <code class="language-plaintext highlighter-rouge">(Int, Unit)</code> to <code class="language-plaintext highlighter-rouge">Int</code> and back without losing anything and the number of inhabitants also stay exactly the same.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">4294967296</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[(</span><span class="kt">Unit</span>, <span class="kt">Int</span><span class="o">)]</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">4294967296</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[(</span><span class="kt">Unit</span>, <span class="o">(</span><span class="kt">Unit</span>, <span class="kt">Int</span><span class="o">))]</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">4294967296</span>
</code></pre></div></div>

<p>Okay, not bad, but how about <code class="language-plaintext highlighter-rouge">Nothing</code>?
Given that it is the identity for addition, any type summed with <code class="language-plaintext highlighter-rouge">Nothing</code> should be equivalent to that type. 
Is <code class="language-plaintext highlighter-rouge">Either[Nothing, A]</code> equivalent to <code class="language-plaintext highlighter-rouge">A</code>?
It is! Since <code class="language-plaintext highlighter-rouge">Nothing</code> doesn’t have any values an <code class="language-plaintext highlighter-rouge">Either[Nothing, A]</code> can only be a <code class="language-plaintext highlighter-rouge">Right</code> and therefore only an <code class="language-plaintext highlighter-rouge">A</code>, so these are in fact equivalent types.</p>

<p>We also have to check for the absorption law that says that any value mutliplied with the additive identity <code class="language-plaintext highlighter-rouge">zero</code> should be equivalent to <code class="language-plaintext highlighter-rouge">zero</code>.
Since <code class="language-plaintext highlighter-rouge">Nothing</code> is our <code class="language-plaintext highlighter-rouge">zero</code> a product type like <code class="language-plaintext highlighter-rouge">(Int, Nothing)</code> should be equivalent to <code class="language-plaintext highlighter-rouge">Nothing</code>.
This also holds, given the fact that we can’t construct a <code class="language-plaintext highlighter-rouge">Nothing</code> so we can never construct a tuple that expects a value of type <code class="language-plaintext highlighter-rouge">Nothing</code> either.</p>

<p>Let’s see if this translates to the number of possible inhabitants as well:</p>

<p>Additive Identity:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">Boolean</span><span class="o">]]</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="o">(</span><span class="kt">Byte</span>, <span class="kt">Boolean</span><span class="o">)]]</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">258</span>
</code></pre></div></div>

<p>Absorption:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[(</span><span class="kt">Nothing</span>, <span class="kt">Boolean</span><span class="o">)]</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[(</span><span class="kt">Nothing</span>, <span class="kt">Long</span><span class="o">)]</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>Nice! 
The only thing left now is distributivity. 
In type form this means that <code class="language-plaintext highlighter-rouge">(A, Either[B, C])</code> should be equal to <code class="language-plaintext highlighter-rouge">Either[(A, B), (A, C)]</code>.
If we think about it, these two types should also be exactly equivalent, woohoo!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[(</span><span class="kt">Boolean</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">Byte</span>, <span class="kt">Short</span><span class="o">])]</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">131584</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Cardinality</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Either</span><span class="o">[(</span><span class="kt">Boolean</span>, <span class="kt">Byte</span><span class="o">)</span>, <span class="o">(</span><span class="kt">Boolean</span>, <span class="kt">Short</span><span class="o">)]]</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="mi">131584</span>
</code></pre></div></div>

<h2 id="higher-kinded-algebraic-structures">Higher kinded algebraic structures</h2>

<p>Some of you might have heard of the <code class="language-plaintext highlighter-rouge">Semigroupal</code> type class. 
But why is it called that, and what is its relation to a <code class="language-plaintext highlighter-rouge">Semigroup</code>?
Let’s find out!</p>

<p>First, let’s have a look at <code class="language-plaintext highlighter-rouge">Semigroupal</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Semigroupal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">product</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It seems to bear some similarity to <code class="language-plaintext highlighter-rouge">Semigroup</code>, we have two values which we somehow combine, and it also shares <code class="language-plaintext highlighter-rouge">Semigroup</code>s associativity requirement.</p>

<p>So far so good, but the name <code class="language-plaintext highlighter-rouge">product</code> seems a bit weird.
It makes sense given we combine the <code class="language-plaintext highlighter-rouge">A</code> and the <code class="language-plaintext highlighter-rouge">B</code> in a tuple, which is a product type, but if we’re using products, maybe this isn’t a generic <code class="language-plaintext highlighter-rouge">Semigroupal</code> but actually a multiplicative one? 
Let’s fix this and rename it!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">MultiplicativeSemigroupal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">product</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Next, let us have a look at what an additive <code class="language-plaintext highlighter-rouge">Semigroupal</code> might look like.
Surely, the only thing we’d have to change is going from a product type to a sum type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">AdditiveSemigroupal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">sum</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Pretty interesting so far, can we top this and add identities to make <code class="language-plaintext highlighter-rouge">Monoidal</code>s?
Surely we can! For addition this should again be <code class="language-plaintext highlighter-rouge">Nothing</code> and <code class="language-plaintext highlighter-rouge">Unit</code> for multiplication:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">AdditiveMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">AdditiveSemigroupal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">nothing</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
<span class="o">}</span>

<span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">MultiplicativeMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">MultiplicativeSemigroupal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">unit</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So now we have these fancy type classes, but how are they actually useful?
Well, I’m going to make the claim that these type classes already exist in cats today, just under different names.</p>

<p>Let’s first look at the <code class="language-plaintext highlighter-rouge">AdditiveMonoidal</code>.
It is defined by two methods, <code class="language-plaintext highlighter-rouge">nothing</code> which returns an <code class="language-plaintext highlighter-rouge">F[Nothing]</code> and <code class="language-plaintext highlighter-rouge">sum</code> which takes an <code class="language-plaintext highlighter-rouge">F[A]</code> and an <code class="language-plaintext highlighter-rouge">F[B]</code> to create an <code class="language-plaintext highlighter-rouge">F[Either[A, B]]</code>.</p>

<p>What type class in Cats could be similar?
First, we’ll look at the <code class="language-plaintext highlighter-rouge">sum</code> function and try to find a counterpart for <code class="language-plaintext highlighter-rouge">AdditiveSemigroupal</code>.
Since we gave the lower kinded versions of these type classes symbolic operators, why don’t we do the same thing for <code class="language-plaintext highlighter-rouge">AdditiveSemigroupal</code>?</p>

<p>Since it is additive it should probably contain a <code class="language-plaintext highlighter-rouge">+</code> somewhere and it should also show that it’s inside some context.</p>

<p>Optimally it’d be something like <code class="language-plaintext highlighter-rouge">[+]</code>, but that’s not a valid identifier so let’s try <code class="language-plaintext highlighter-rouge">&lt;+&gt;</code> instead!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">&lt;+&gt;</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span>
</code></pre></div></div>

<p>Oh! The <code class="language-plaintext highlighter-rouge">&lt;+&gt;</code> function already exists in cats as an alias for <code class="language-plaintext highlighter-rouge">combineK</code> which can be found on <code class="language-plaintext highlighter-rouge">SemigroupK</code>, but it’s sort of different, it takes two <code class="language-plaintext highlighter-rouge">F[A]</code>s and returns an <code class="language-plaintext highlighter-rouge">F[A]</code>, not quite what we have here.</p>

<p>Or is it?
These two functions are actually the same, and we can define them in terms of one another as long as we have a functor:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span>

<span class="k">def</span> <span class="nf">combineK</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="nv">feaa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="nf">sum</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="nv">feaa</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">merge</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So our <code class="language-plaintext highlighter-rouge">AdditiveSemigroupal</code> is equivalent to <code class="language-plaintext highlighter-rouge">SemigroupK</code>, so probably <code class="language-plaintext highlighter-rouge">AdditiveMonoidal</code> is equivalent to <code class="language-plaintext highlighter-rouge">MonoidK</code>, right?</p>

<p>Indeed, and we can show that quite easily.</p>

<p><code class="language-plaintext highlighter-rouge">MonoidK</code> adds an <code class="language-plaintext highlighter-rouge">empty</code> function with the following definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>This function uses a universal quantifier for <code class="language-plaintext highlighter-rouge">A</code>, which means that it works for any <code class="language-plaintext highlighter-rouge">A</code>, which then means that it cannot actually include any particular <code class="language-plaintext highlighter-rouge">A</code> and is therefore equivalent to <code class="language-plaintext highlighter-rouge">F[Nothing]</code> which is what we have for <code class="language-plaintext highlighter-rouge">AdditiveMonoidal</code>.</p>

<p>Excellent, so we found counterparts for the additive type classes, and we already now that <code class="language-plaintext highlighter-rouge">MultiplicativeSemigroupal</code> is equivalent to <code class="language-plaintext highlighter-rouge">cats.Semigroupal</code>.
So the only thing left to find out is the counterpart of <code class="language-plaintext highlighter-rouge">MultiplicativeMonoidal</code>.</p>

<p>I’m going to spoil the fun and make the claim that <code class="language-plaintext highlighter-rouge">Applicative</code> is that counterpart.
<code class="language-plaintext highlighter-rouge">Applicative</code> adds <code class="language-plaintext highlighter-rouge">pure</code>, which takes an <code class="language-plaintext highlighter-rouge">A</code> and returns an <code class="language-plaintext highlighter-rouge">F[A]</code>.
<code class="language-plaintext highlighter-rouge">MultiplicativeMonoidal</code> adds <code class="language-plaintext highlighter-rouge">unit</code>, which takes no parameters and returns an <code class="language-plaintext highlighter-rouge">F[Unit]</code>.
So how can we go from one to another? 
Well the answer is again using a functor:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">unit</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">pure</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">unit</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Applicative</code> uses a covariant functor, but in general we could use invariant and contravariant structures as well.
<code class="language-plaintext highlighter-rouge">Applicative</code> also uses <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> as an alias for using <code class="language-plaintext highlighter-rouge">product</code> together with <code class="language-plaintext highlighter-rouge">map</code>, which seems like further evidence that our intuition that its a multiplicative type class is correct.</p>

<p>So in cats right now we have <code class="language-plaintext highlighter-rouge">&lt;+&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>, is there also a type class that combines both similar to how <code class="language-plaintext highlighter-rouge">Semiring</code> combines <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">*</code>?</p>

<p>There is, it is called <code class="language-plaintext highlighter-rouge">Alternative</code>, it extends <code class="language-plaintext highlighter-rouge">Applicative</code> and <code class="language-plaintext highlighter-rouge">MonoidK</code> and if we were super consistent we’d call it a <code class="language-plaintext highlighter-rouge">Semiringal</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> 
<span class="k">trait</span> <span class="nc">Semiringal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">MultiplicativeMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">AdditiveMonoidal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
</code></pre></div></div>

<p>Excellent, now we’ve got both <code class="language-plaintext highlighter-rouge">Semiring</code> and a higher kinded version of it.
Unfortunately the lower kinded version can’t be found in Cats yet, but hopefully in a future version it’ll be available as well.</p>

<p>If it were available, we could derive a <code class="language-plaintext highlighter-rouge">Semiring</code> for any <code class="language-plaintext highlighter-rouge">Alternative</code> the same we can derive a <code class="language-plaintext highlighter-rouge">Monoid</code> for any <code class="language-plaintext highlighter-rouge">MonoidK</code> or <code class="language-plaintext highlighter-rouge">Applicative</code>.
We could also lift any <code class="language-plaintext highlighter-rouge">Semiring</code> back into <code class="language-plaintext highlighter-rouge">Alternative</code>, by using <code class="language-plaintext highlighter-rouge">Const</code>, just like we can lift <code class="language-plaintext highlighter-rouge">Monoid</code>s into <code class="language-plaintext highlighter-rouge">Applicative</code> using <code class="language-plaintext highlighter-rouge">Const</code>.</p>

<p>To end this blog post, we’ll have a very quick look on how to do that.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Semiring.ops._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">getConst</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">constSemiringal</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semiring</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Semiringal</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">sum</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Const</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">getConst</span> <span class="o">+</span> <span class="nv">fb</span><span class="o">.</span><span class="py">getConst</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">product</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="o">(</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">)]</span> <span class="k">=</span>
    <span class="nc">Const</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">getConst</span> <span class="o">*</span> <span class="nv">fb</span><span class="o">.</span><span class="py">getConst</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">unit</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Const</span><span class="o">(</span><span class="nc">Semiring</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">one</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">nothing</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Const</span><span class="o">(</span><span class="nc">Semiring</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">zero</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Rings and Semirings are very interesting algebraic structures and even if we didn’t know about them we’ve probably been using them for quite some time.
This blog post aimed to show how <code class="language-plaintext highlighter-rouge">Applicative</code> and <code class="language-plaintext highlighter-rouge">MonoidK</code> relate to <code class="language-plaintext highlighter-rouge">Monoid</code> and how algebraic data types form a semiring and how these algebraic structures are pervasive throughout Scala and other functional programming languages.
For me personally, realizing how all of this ties together and form some really satisfying symmetry was really mind blowing and I hope this blog post can give some good insight on recognizing these interesting similarities throughout Cats and other libraries based on different mathematical abstractions.
For further material on this topic, you can check out <a href="https://www.youtube.com/watch?v=YScIPA8RbVE">this talk</a>.</p>

<h2 id="addendum">Addendum</h2>

<p>This article glossed over commutativity in the type class encodings.
Commutativity is very important law for semrings and the code should show that.
However, since this post already contained a lot of different type class definitions, adding extra commutative type class definitions that do nothing but add laws felt like it would distract from what is trying to be taught.</p>

<p>Moreover I focused on the cardinality of only the types we need, but for completeness’ sake, we could also add instances of <code class="language-plaintext highlighter-rouge">Cardinality</code> for things like <code class="language-plaintext highlighter-rouge">A =&gt; B</code> , <code class="language-plaintext highlighter-rouge">Option[A]</code> or <code class="language-plaintext highlighter-rouge">Ior[A, B]</code>.
These are:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Cardinality.of[A =&gt; B] === Cardinality.of[B].pow(Cardinality.of[A])</code></li>
  <li><code class="language-plaintext highlighter-rouge">Cardinality.of[Option[A]] === Cardinality.of[A] + 1</code></li>
  <li><code class="language-plaintext highlighter-rouge">Cardinality.of[Ior[A, B]] === Cardinality.of[A] + Cardinality.of[B] + Cardinality.of[A] * Cardinality.of[B]</code></li>
</ol>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 02 Nov 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/11/02/semirings.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/11/02/semirings.html</guid>
      </item>
    
      <item>
        <title>A comprehensive introduction to Cats-mtl</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p>MTL is a library for composing monad transformers and making it easier to work with nested monad transformer stacks.
It originates from the land of Haskell, but has made it into Scala a long time ago.
For the longest time however, it was barely usable, because of a bunch of different Scala quirks coming together.
With all this, I feel many have the impression that mtl is something scary, abstract or too complicated.
In this blog post, I’ll try my best to disprove this notion and demonstrate the simplicity and elegance of Cats-mtl. After reading this, I hope you’ll agree that one should prefer <code class="language-plaintext highlighter-rouge">mtl</code>  whenever one needs to compose more than one monad transformer nested inside of each other.</p>

<h2 id="what-is-mtl">What is mtl?</h2>

<p>Mtl is an acronym and stands for <em>Monad Transformer Library</em>. Its main purpose it make it easier to work with nested monad transformers. It achieves this by encoding the effects of most common monad transformers as type classes.
To understand what this means we’ll first have to look at some of the common monad transformers.</p>

<p>I’ll go over some of the lesser known transformers <code class="language-plaintext highlighter-rouge">StateT</code> and <code class="language-plaintext highlighter-rouge">ReaderT</code> next, so feel free to skip the next section if you already know about <code class="language-plaintext highlighter-rouge">StateT</code> and <code class="language-plaintext highlighter-rouge">ReaderT</code>.</p>

<h3 id="readert">ReaderT</h3>

<p><code class="language-plaintext highlighter-rouge">ReaderT</code> allows us to <em>read</em> from an environment and create other values that depend on the environment.
This can be especially useful for e.g. reading from some external configuration.
Some like to describe this as the functional programming equivalent of dependency injection.</p>

<p>As an example, let’s imagine we want to make a call to a service, but to make that call we need to pass some configuration.</p>

<p>First, some imports and some declarations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.data._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="k">import</span> <span class="nn">cats.effect._</span>

<span class="c1">// These are just String for simplicity
</span><span class="k">type</span> <span class="kt">Config</span> <span class="o">=</span> <span class="nc">String</span>
<span class="k">type</span> <span class="kt">Result</span> <span class="o">=</span> <span class="nc">String</span>

</code></pre></div></div>

<p>Now let’s say we have these two functions for the service we want to call and the configuration we want to read from.</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">getConfig</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Config</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="c1">// getConfig: cats.effect.IO[Config]
</span>
<span class="k">def</span> <span class="nf">serviceCall</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Config</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="c1">// serviceCall: (c: Config)cats.effect.IO[Result]
</span></code></pre></div></div>

<p>The easiest thing would be to just pass down the configuration from the very top of your application.
However that can be pretty tedious, so what we do instead is use <code class="language-plaintext highlighter-rouge">ReaderT</code>.
<code class="language-plaintext highlighter-rouge">ReaderT</code> gives us the <code class="language-plaintext highlighter-rouge">ask</code> function, which gives us access to a read-only environment value of type <code class="language-plaintext highlighter-rouge">E</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ask</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">ReaderT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">E</span><span class="o">]</span>
</code></pre></div></div>

<p>We can then use <code class="language-plaintext highlighter-rouge">flatMap</code>, <code class="language-plaintext highlighter-rouge">map</code> or for-comprehensions to actually use that value and do things with it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">readerProgram</span><span class="k">:</span> <span class="kt">ReaderT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Config</span>, <span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">config</span> <span class="k">&lt;-</span> <span class="nv">ReaderT</span><span class="o">.</span><span class="py">ask</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Config</span><span class="o">]</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="nv">ReaderT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="nf">serviceCall</span><span class="o">(</span><span class="n">config</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// readerProgram: cats.data.ReaderT[cats.effect.IO,Config,Result]
</span></code></pre></div></div>

<p>Now that we have a value of <code class="language-plaintext highlighter-rouge">ReaderT</code> that gives us back our result, the next step is to actually “inject” the dependency.
For this purpose, <code class="language-plaintext highlighter-rouge">ReaderT[F, E, A]</code> gives us a <code class="language-plaintext highlighter-rouge">run</code> function that expects us to give it a value of <code class="language-plaintext highlighter-rouge">E</code> and will then return an <code class="language-plaintext highlighter-rouge">F[A]</code>, so in our case an <code class="language-plaintext highlighter-rouge">IO</code> of <code class="language-plaintext highlighter-rouge">Result</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Combined with our <code class="language-plaintext highlighter-rouge">getConfig</code> function we can now write the entry point to our program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="nv">getConfig</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="nv">readerProgram</span><span class="o">.</span><span class="py">run</span><span class="o">)</span>
<span class="c1">// main: cats.effect.IO[Result]
</span></code></pre></div></div>

<p>And that is how we can do functional dependency injection in Scala.
However, I believe this pattern isn’t used very often, because it forces you to wrap all of your steps in <code class="language-plaintext highlighter-rouge">ReaderT</code>.
If you continue reading on, we’ll go through how this problem can be mitigated using MTL.</p>

<h3 id="statet">StateT</h3>

<p>Like <code class="language-plaintext highlighter-rouge">ReaderT</code>, <code class="language-plaintext highlighter-rouge">StateT</code> also allows us to read from an environment.
However, unlike <code class="language-plaintext highlighter-rouge">ReaderT</code>, it also allows us to write to that environment, making it capable of holding state, hence the name. 
With <code class="language-plaintext highlighter-rouge">StateT</code> over <code class="language-plaintext highlighter-rouge">IO</code>, we can deliberately create programs that can access the outside world and also maintain mutable state.
This is very powerful and, when used without care, can give rise to similar problems as can be found in imperative programs that abuse global mutable state and unlimited side effects.
Use <code class="language-plaintext highlighter-rouge">StateT</code> with care however, and it can be a really great tool for parts of your application that require some notion of mutable state.</p>

<p>An example use case that comes up very often is the ability to send some requests to an external services and after each of those requests, use the resulting value to modify an environment with which you’ll create the next request.
This environment could be used for something simple like a cache, or something more complex like dynamically changing the parameters of each request, depening on what state the environment currently holds.
Let’s look at an abstract example, that showcases this ability.</p>

<p>First, we’ll define a function that calls our external service which will take the environment into account.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Again we use String here for simplicity, in real code this would be something else
</span><span class="k">type</span> <span class="kt">Env</span> <span class="o">=</span> <span class="nc">String</span>
<span class="k">type</span> <span class="kt">Request</span> <span class="o">=</span> <span class="nc">String</span>
<span class="k">type</span> <span class="kt">Response</span> <span class="o">=</span> <span class="nc">String</span>

<span class="k">def</span> <span class="nf">initialEnv</span><span class="k">:</span> <span class="kt">Env</span> <span class="o">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="nf">request</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Request</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Next, we’ll also need a function that given a response and an old environment will return a new updated environment.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">updateEnv</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Response</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span><span class="k">:</span> <span class="kt">Env</span> <span class="o">=</span> <span class="o">???</span>

<span class="c1">// We also need some fake requests
</span><span class="k">def</span> <span class="nf">req1</span><span class="k">:</span> <span class="kt">Request</span> <span class="o">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="nf">req2</span><span class="k">:</span> <span class="kt">Request</span> <span class="o">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="nf">req3</span><span class="k">:</span> <span class="kt">Request</span> <span class="o">=</span> <span class="o">???</span>
<span class="k">def</span> <span class="nf">req4</span><span class="k">:</span> <span class="kt">Request</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Now we can get started with <code class="language-plaintext highlighter-rouge">StateT</code>.
To do so, we’ll create a new request function that will make the request with the current environment and update it after we’ve received the response:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">requestWithState</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Request</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Env</span>, <span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">env</span> <span class="k">&lt;-</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">get</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Env</span><span class="o">]</span>
  <span class="n">resp</span> <span class="k">&lt;-</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="nf">request</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">env</span><span class="o">))</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">modify</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Env</span><span class="o">](</span><span class="nf">updateEnv</span><span class="o">(</span><span class="n">resp</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">resp</span>
</code></pre></div></div>

<p>This demonstrates the power of <code class="language-plaintext highlighter-rouge">StateT</code>.
We can get the current state by using <code class="language-plaintext highlighter-rouge">StateT.get</code> (which returns a <code class="language-plaintext highlighter-rouge">StateT[IO, Env, Env]</code> similar to <code class="language-plaintext highlighter-rouge">ReaderT.ask</code>) and we can also modify it using <code class="language-plaintext highlighter-rouge">StateT.modify</code> (which takes a function <code class="language-plaintext highlighter-rouge">Env =&gt; Env</code> and returns a <code class="language-plaintext highlighter-rouge">StateT[IO, Env, Unit]</code>).</p>

<p>Now, if we wanted to make those different requests, we could just reuse that <code class="language-plaintext highlighter-rouge">requestWithState</code> function N number of times:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stateProgram</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Env</span>, <span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">resp1</span> <span class="k">&lt;-</span> <span class="nf">requestWithState</span><span class="o">(</span><span class="n">req1</span><span class="o">)</span>
  <span class="n">resp2</span> <span class="k">&lt;-</span> <span class="nf">requestWithState</span><span class="o">(</span><span class="n">req2</span><span class="o">)</span>
  <span class="n">resp3</span> <span class="k">&lt;-</span> <span class="nf">requestWithState</span><span class="o">(</span><span class="n">req3</span><span class="o">)</span>
  <span class="n">resp4</span> <span class="k">&lt;-</span> <span class="nf">requestWithState</span><span class="o">(</span><span class="n">req4</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">resp4</span>
</code></pre></div></div>

<p>And now we have a fully fledged program exactly as we wanted.
But what can we actually do with the <code class="language-plaintext highlighter-rouge">StateT</code> value?
To run the full program, we need an <code class="language-plaintext highlighter-rouge">IO</code>. 
Of course, just like <code class="language-plaintext highlighter-rouge">ReaderT</code>, we can turn <code class="language-plaintext highlighter-rouge">StateT</code> into <code class="language-plaintext highlighter-rouge">IO</code> by using the <code class="language-plaintext highlighter-rouge">run</code> method and supplying an initial value for our environment. 
Let’s try that out!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[(</span><span class="kt">Env</span>, <span class="kt">Response</span><span class="o">)]</span> <span class="k">=</span> <span class="nv">stateProgram</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">initialEnv</span><span class="o">)</span>
<span class="c1">// main: cats.effect.IO[(Env, Response)]
</span></code></pre></div></div>

<p>And that gives us a fully working stateful application. Cool.
Next, we’ll look at how we can combine different transformers and what monad transformers actually represent.</p>

<h2 id="monad-transformers-encode-some-notion-of-effect">Monad Transformers encode some notion of <em>effect</em></h2>

<p><code class="language-plaintext highlighter-rouge">EitherT</code> encodes the effect of short-circuiting errors.
<code class="language-plaintext highlighter-rouge">ReaderT</code> encodes the effect of reading a value from the environment.
<code class="language-plaintext highlighter-rouge">StateT</code> encodes the effect of pure local mutable state.</p>

<p>All of these monad transformers encode their effects as data structures, but there’s another way to achieve the same result: Type classes!</p>

<p>For example we’ve looked extensively at the <code class="language-plaintext highlighter-rouge">ReaderT.ask</code> function, what would it look like if we used a type class here instead?
Well, Cats-mtl has an answer and it’s called <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code>.
You can think of it as <code class="language-plaintext highlighter-rouge">ReaderT</code> encoded as a type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ApplicativeAsk</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">applicative</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">ask</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>At it’s core <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code> just encodes the fact that we can ask for a value from the environment, exactly like <code class="language-plaintext highlighter-rouge">ReaderT</code> does.
Exactly like <code class="language-plaintext highlighter-rouge">ReaderT</code>, it also includes another type parameter <code class="language-plaintext highlighter-rouge">E</code>, that represents that environment.</p>

<p>If you’re wondering why <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code> has an <code class="language-plaintext highlighter-rouge">Applicative</code> field instead of just extending from <code class="language-plaintext highlighter-rouge">Applicative</code>, that is to avoid implicit ambiguities that arise from having multiple subclasses of a given type (here <code class="language-plaintext highlighter-rouge">Applicative</code>) in scope implicitly.
So in this case we favor composition over inheritance as otherwise, we could not e.g. use <code class="language-plaintext highlighter-rouge">Monad</code> together with <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code>.
You can read more about this issue in this excellent <a href="https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html">blog post by Adelbert Chang</a>.</p>

<h3 id="effect-type-classes">Effect type classes</h3>

<p><code class="language-plaintext highlighter-rouge">ApplicativeAsk</code> is an example for what is at the core of Cats-mtl.
Cats-mtl provides type classes for most common effects which let you choose what kind of effects you need without committing to a specific monad transformer stack.</p>

<p>Ideally, you’d write all your code using only an abstract type constructor <code class="language-plaintext highlighter-rouge">F[_]</code> with different type class constraints and then at the end run that code with a specific data type that is able to fulfill those constraints.</p>

<p>So without further ado, let’s try to convert our <code class="language-plaintext highlighter-rouge">Reader</code> program from earlier into mtl-style.
First, I’ll include the original program again:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getConfig</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Config</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="c1">// getConfig: cats.effect.IO[Config]
</span>
<span class="k">def</span> <span class="nf">serviceCall</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Config</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="c1">// serviceCall: (c: Config)cats.effect.IO[Result]
</span>
<span class="k">def</span> <span class="nf">readerProgram</span><span class="k">:</span> <span class="kt">ReaderT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Config</span>, <span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">config</span> <span class="k">&lt;-</span> <span class="nv">ReaderT</span><span class="o">.</span><span class="py">ask</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Config</span><span class="o">]</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="nv">ReaderT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="nf">serviceCall</span><span class="o">(</span><span class="n">config</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// readerProgram: cats.data.ReaderT[cats.effect.IO,Config,Result]
</span>
<span class="k">def</span> <span class="nf">main</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="nv">getConfig</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="nv">readerProgram</span><span class="o">.</span><span class="py">run</span><span class="o">)</span>
<span class="c1">// main: cats.effect.IO[Result]
</span></code></pre></div></div>

<p>Now we should just replace that <code class="language-plaintext highlighter-rouge">ReaderT</code> with an <code class="language-plaintext highlighter-rouge">F</code> and add an <code class="language-plaintext highlighter-rouge">ApplicativeAsk[F, Config]</code> constraint, right?
We have one small problem though, how can we lift our <code class="language-plaintext highlighter-rouge">serviceCall</code> which is an <code class="language-plaintext highlighter-rouge">IO</code> value, into our abstract <code class="language-plaintext highlighter-rouge">F</code> context?
Fortunately <code class="language-plaintext highlighter-rouge">cats-effect</code> already defines a typeclass designed to help us out here called <code class="language-plaintext highlighter-rouge">LiftIO</code>.
It defines a single function <code class="language-plaintext highlighter-rouge">liftIO</code> that does exactly what you’d expect:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">LiftIO</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">liftIO</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If there’s an instance for <code class="language-plaintext highlighter-rouge">LiftIO[F]</code> we can lift any <code class="language-plaintext highlighter-rouge">IO[A]</code> into an <code class="language-plaintext highlighter-rouge">F[A]</code>.
Furthermore <code class="language-plaintext highlighter-rouge">IO</code> defines a method <code class="language-plaintext highlighter-rouge">to</code> which makes use of this type class to provide some nicer looking syntax.</p>

<p>With this in mind, we can now define our <code class="language-plaintext highlighter-rouge">readerProgram</code> fully using MTL:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.mtl._</span>
<span class="k">import</span> <span class="nn">cats.mtl.instances.all._</span>

<span class="k">def</span> <span class="nf">readerProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">LiftIO</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">ApplicativeAsk</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Config</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">config</span> <span class="k">&lt;-</span> <span class="nv">A</span><span class="o">.</span><span class="py">ask</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="nf">serviceCall</span><span class="o">(</span><span class="n">config</span><span class="o">).</span><span class="py">to</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
</code></pre></div></div>

<p>We replaced our call to <code class="language-plaintext highlighter-rouge">ReaderT.ask</code> with a call to <code class="language-plaintext highlighter-rouge">ask</code> provided by <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code> and instead of using <code class="language-plaintext highlighter-rouge">ReaderT.liftF</code> to lift an <code class="language-plaintext highlighter-rouge">IO</code> into <code class="language-plaintext highlighter-rouge">ReaderT</code>, we can simply use the <code class="language-plaintext highlighter-rouge">to</code> function on <code class="language-plaintext highlighter-rouge">IO</code>, pretty neat if you ask me.</p>

<p>Now to run it, all we need to do is specify the target <code class="language-plaintext highlighter-rouge">F</code> to run in, in our case <code class="language-plaintext highlighter-rouge">ReaderT[IO, Config, Result]</code> fits perfectly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">materializedProgram</span> <span class="k">=</span> <span class="n">readerProgram</span><span class="o">[</span><span class="kt">ReaderT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Config</span>, <span class="kt">?</span><span class="o">]]</span>

<span class="k">def</span> <span class="nf">main</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="nv">getConfig</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="nv">materializedProgram</span><span class="o">.</span><span class="py">run</span><span class="o">)</span>
</code></pre></div></div>

<p>This process of turning a program defined by an abstract type constructor with additional type class constraints into an actual concrete data type is sometimes called <em>interpreting</em>  or <em>materializing</em>  a program.</p>

<p>Another thing we can do is define a type alias for <code class="language-plaintext highlighter-rouge">ApplicativeAsk[F, Config]</code> so that we can more easily use it with the context bound syntax:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">ApplicativeConfig</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">ApplicativeAsk</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Config</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">readerProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">LiftIO:</span> <span class="kt">ApplicativeConfig</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>So far so good, but this doesn’t seem to be any better than what we had before.
I’ve teased at the beginning that MTL really shines once you use more than one monad transformer.
So let’s say our program now also needs to be able to handle errors (which I think is a very reasonable requirement).</p>

<p>To do so, we’ll use <code class="language-plaintext highlighter-rouge">MonadError</code>, which can be found in cats-core instead of mtl, but in its essence, it encodes the short circuting effect that’s shared with <code class="language-plaintext highlighter-rouge">EitherT</code>.</p>

<p>To keep things simple for now, we want to raise an error if the configuration we got was invalid somehow.
For this purpose we’ll have this simple function that will simply return if a <code class="language-plaintext highlighter-rouge">Config</code> is valid or not:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">validConfig</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Config</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Then we’ll also want to define an error ADT for our app:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">AppError</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">InvalidConfig</span> <span class="k">extends</span> <span class="nc">AppError</span>
</code></pre></div></div>

<p>Now we can go and extend our program from earlier. 
We’ll add a <code class="language-plaintext highlighter-rouge">MonadError[F, AppError]</code> type alias, <code class="language-plaintext highlighter-rouge">MonadAppError</code> and then add a constraint for it in our program.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">MonadAppError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">AppError</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadAppError:</span> <span class="kt">ApplicativeConfig:</span> <span class="kt">LiftIO</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Now we want so ensure somehow that our config is valid and raise an <code class="language-plaintext highlighter-rouge">InvalidConfig</code> error if it’s not.
To do so, we’ll simply use the <code class="language-plaintext highlighter-rouge">ensure</code> function provided by <code class="language-plaintext highlighter-rouge">MonadError</code>.
It looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ensure</span><span class="o">(</span><span class="n">error</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">E</span><span class="o">)(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>And it fills our need exactly. It will raise the passed <code class="language-plaintext highlighter-rouge">error</code>, if the <code class="language-plaintext highlighter-rouge">predicate</code> function returns <code class="language-plaintext highlighter-rouge">false</code>.
Let’s go and try it out:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadAppError:</span> <span class="kt">ApplicativeConfig:</span> <span class="kt">LiftIO</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">config</span> <span class="k">&lt;-</span> <span class="nc">ApplicativeAsk</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Config</span><span class="o">].</span><span class="py">ask</span>
              <span class="o">.</span><span class="py">ensure</span><span class="o">(</span><span class="nc">InvalidConfig</span><span class="o">)(</span><span class="n">validConfig</span><span class="o">)</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="nf">serviceCall</span><span class="o">(</span><span class="n">config</span><span class="o">).</span><span class="py">to</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// program: [F[_]](implicit evidence$1: MonadAppError[F], implicit evidence$2: ApplicativeConfig[F], implicit evidence$3: cats.effect.LiftIO[F])F[Result]
</span></code></pre></div></div>

<p>Pretty simple, now let’s materialize it!
To do so, we’ll use a monad stack of <code class="language-plaintext highlighter-rouge">ReaderT</code>, <code class="language-plaintext highlighter-rouge">EitherT</code> and <code class="language-plaintext highlighter-rouge">IO</code>.
Unwrapped it should look like this <code class="language-plaintext highlighter-rouge">IO[Either[AppError, Reader[Config, A]]]</code>.</p>

<p>We’ll create some type aliases to get a better overview:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">EitherApp</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">AppError</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">Stack</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ReaderT</span><span class="o">[</span><span class="kt">EitherApp</span>, <span class="kt">Config</span>, <span class="kt">A</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">materializedProgram</span><span class="k">:</span> <span class="kt">Stack</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">Stack</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">main</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">AppError</span>, <span class="kt">Result</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">EitherT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="n">getConfig</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="nv">materializedProgram</span><span class="o">.</span><span class="py">run</span><span class="o">).</span><span class="py">value</span>
</code></pre></div></div>

<p>This is the magic of mtl, it is able to give you type class instances for every single monad transformer in the stack.
This means that when you stack <code class="language-plaintext highlighter-rouge">EitherT</code>, <code class="language-plaintext highlighter-rouge">ReaderT</code> and <code class="language-plaintext highlighter-rouge">StateT</code>, you’ll be able to get instances for <code class="language-plaintext highlighter-rouge">MonadError</code>, <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code> and <code class="language-plaintext highlighter-rouge">MonadState</code>, which is really useful!</p>

<p>If you’re wondering how this works, well let’s just have a quick look at how the <code class="language-plaintext highlighter-rouge">MonadError</code> instance for <code class="language-plaintext highlighter-rouge">ReaderT</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">monadErrorForReaderT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span>, <span class="kt">R</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">ReaderT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">R</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">ReaderT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">R</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">ReaderT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">R</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">ReaderT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>

    <span class="k">def</span> <span class="nf">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">ReaderT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">R</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="nc">ReaderT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">R</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ReaderT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">R</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">ReaderT</span><span class="o">.</span><span class="py">ask</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">R</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span> 
        <span class="nv">ReaderT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="py">run</span><span class="o">(</span><span class="n">r</span><span class="o">)))</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>To get an instance of <code class="language-plaintext highlighter-rouge">MonadError</code> for <code class="language-plaintext highlighter-rouge">ReaderT[F, R, ?]</code>, we need to have a <code class="language-plaintext highlighter-rouge">MonadError</code> for <code class="language-plaintext highlighter-rouge">F</code>.
Then we can easily use that underlying instance to handle and raise the errors instead.
Again, this means that if some part of transformer stack is capable of raising and handling errors, now your whole stack is.
So if it includes <code class="language-plaintext highlighter-rouge">EitherT</code> somewhere, you can “lift” that capability.</p>

<p>There are different strategies for lifting these capabilities throughout your monad stack, but they’d be out of scope for this article.</p>

<p>What this means for us, is that we never have to think about lifting individual monads through transformer stacks.
The implicit search used by the type class mechanic takes care of it.
Pretty neat, I think.
Now contrast this lack of lifting, with the same program written without mtl:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">EitherApp</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">AppError</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias EitherApp
</span>
<span class="k">type</span> <span class="kt">Stack</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ReaderT</span><span class="o">[</span><span class="kt">EitherApp</span>, <span class="kt">Config</span>, <span class="kt">A</span><span class="o">]</span>
<span class="c1">// defined type alias Stack
</span>
<span class="k">def</span> <span class="nf">program</span><span class="k">:</span> <span class="kt">Stack</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">config</span> <span class="k">&lt;-</span> <span class="nv">ReaderT</span><span class="o">.</span><span class="py">ask</span><span class="o">[</span><span class="kt">EitherApp</span>, <span class="kt">Config</span><span class="o">]</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">validConfig</span><span class="o">(</span><span class="n">config</span><span class="o">))</span> <span class="o">().</span><span class="py">pure</span><span class="o">[</span><span class="kt">Stack</span><span class="o">]</span>
       <span class="k">else</span> <span class="nv">ReaderT</span><span class="o">.</span><span class="py">liftF</span><span class="o">[</span><span class="kt">EitherApp</span>, <span class="kt">Config</span>, <span class="kt">Unit</span><span class="o">](</span><span class="nv">EitherT</span><span class="o">.</span><span class="py">leftT</span><span class="o">(</span><span class="nc">InvalidConfig</span><span class="o">))</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="nv">ReaderT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="nv">EitherT</span><span class="o">.</span><span class="py">liftF</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">AppError</span>, <span class="kt">Result</span><span class="o">](</span><span class="nf">serviceCall</span><span class="o">(</span><span class="n">config</span><span class="o">)))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// program: Stack[Result]
</span></code></pre></div></div>

<p>It’s the same program, but now we have to add type annotations and <code class="language-plaintext highlighter-rouge">liftF</code>s everywhere.
If you try to take away one of those type annotations the program will fail to compile, so this is the minimum amount of boilerplate you need.</p>

<h3 id="adding-state">Adding State</h3>

<p>For the next step, let’s imagine we want to send multiple requests and after each, use information we retrieved from the response for the next request, similar to how we did earlier in the <code class="language-plaintext highlighter-rouge">StateT</code> example.</p>

<p>Instead of using <code class="language-plaintext highlighter-rouge">StateT</code>, we’ll use the <code class="language-plaintext highlighter-rouge">MonadState</code> type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">get</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">modify</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">get</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nf">set</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s imagine we have a list of requests, where we want to update the environment after each request, and we also want to use the environment to create the next request.
At the very end we want to return the list of all the responses we got:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Result</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Response</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">updateEnv</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Response</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span><span class="k">:</span> <span class="kt">Env</span> <span class="o">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="nf">requests</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Request</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>

<span class="k">def</span> <span class="nf">newServiceCall</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Config</span><span class="o">,</span> <span class="n">req</span><span class="k">:</span> <span class="kt">Request</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>So far, so good, next we’ll use <code class="language-plaintext highlighter-rouge">MonadState</code> to create a new function that will wrap <code class="language-plaintext highlighter-rouge">newServiceCall</code> with the addition of modifying the environment using <code class="language-plaintext highlighter-rouge">updateEnv</code>.
To do so, we’ll create a new type alias for <code class="language-plaintext highlighter-rouge">MonadState[F, Env]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">MonadStateEnv</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Env</span><span class="o">]</span>
<span class="c1">// defined type alias MonadStateEnv
</span>
<span class="k">def</span> <span class="nf">requestWithState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">MonadStateEnv:</span> <span class="kt">LiftIO</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Config</span><span class="o">,</span> <span class="n">req</span><span class="k">:</span> <span class="kt">Request</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">env</span> <span class="k">&lt;-</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Env</span><span class="o">].</span><span class="py">get</span>
  <span class="n">response</span> <span class="k">&lt;-</span> <span class="nf">newServiceCall</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">req</span><span class="o">,</span> <span class="n">env</span><span class="o">).</span><span class="py">to</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Env</span><span class="o">].</span><span class="py">modify</span><span class="o">(</span><span class="nf">updateEnv</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">response</span>
<span class="c1">// requestWithState: [F[_]](c: Config, req: Request)(implicit evidence$1: cats.Monad[F], implicit evidence$2: MonadStateEnv[F], implicit evidence$3: cats.effect.LiftIO[F])F[Response]
</span></code></pre></div></div>

<p>Here, we use <code class="language-plaintext highlighter-rouge">get</code> to retrieve the current state of the environment, then we use <code class="language-plaintext highlighter-rouge">newServiceCall</code> and lift it into <code class="language-plaintext highlighter-rouge">F</code> and use the response to modify the environment with <code class="language-plaintext highlighter-rouge">updateEnv</code>.</p>

<p>Now, we can use  <code class="language-plaintext highlighter-rouge">requestWithState</code> on our list of requests and embed this new part into our program.
The best way to do that, is of course <code class="language-plaintext highlighter-rouge">traverse</code>, as we want to go from a <code class="language-plaintext highlighter-rouge">List[Request]</code> and a function <code class="language-plaintext highlighter-rouge">Request =&gt; F[Response]</code> to an <code class="language-plaintext highlighter-rouge">F[List[Response]]</code>.
So without further ado, this is our final program, using all three different mtl type classes we learned about in this article:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadAppError:</span> <span class="kt">MonadStateEnv:</span> <span class="kt">ApplicativeConfig:</span> <span class="kt">LiftIO</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">config</span> <span class="k">&lt;-</span> <span class="nc">ApplicativeAsk</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Config</span><span class="o">].</span><span class="py">ask</span>
    <span class="o">.</span><span class="py">ensure</span><span class="o">(</span><span class="nc">InvalidConfig</span><span class="o">)(</span><span class="n">validConfig</span><span class="o">)</span>
  <span class="n">responses</span> <span class="k">&lt;-</span> <span class="nv">requests</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="n">req</span> <span class="k">=&gt;</span> <span class="n">requestWithState</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">config</span><span class="o">,</span> <span class="n">req</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">responses</span>
<span class="c1">// program: [F[_]](implicit evidence$1: MonadAppError[F], implicit evidence$2: MonadStateEnv[F], implicit evidence$3: ApplicativeConfig[F], implicit evidence$4: cats.effect.LiftIO[F])F[Result]
</span></code></pre></div></div>

<p>And that is it! 
Of course, we still have to run it, so let’s materialize our <code class="language-plaintext highlighter-rouge">F</code> into an appropriate data type.
We’ll be using a stack of <code class="language-plaintext highlighter-rouge">EitherT</code>, <code class="language-plaintext highlighter-rouge">StateT</code> and <code class="language-plaintext highlighter-rouge">ReaderT</code>, with <code class="language-plaintext highlighter-rouge">IO</code> as our base to satisfy <code class="language-plaintext highlighter-rouge">LiftIO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">materializedProgram</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">ReaderT</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Config</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">AppError</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Env</span>, <span class="kt">?</span><span class="o">]]</span>
</code></pre></div></div>

<p>And now we have a fully applied transformer stack.</p>

<p>The only thing left is to turn that stack back into an <code class="language-plaintext highlighter-rouge">IO</code> by running the individual layers.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">AppError</span>, <span class="o">(</span><span class="kt">Env</span>, <span class="kt">Result</span><span class="o">)]]</span> <span class="k">=</span> 
  <span class="nv">getConfig</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">conf</span> <span class="k">=&gt;</span> 
    <span class="nv">materializedProgram</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">initialEnv</span><span class="o">)</span> <span class="c1">//Run the StateT layer
</span>      <span class="o">.</span><span class="py">value</span> <span class="c1">//Run the EitherT layer
</span>      <span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">conf</span><span class="o">)</span> <span class="c1">//Run the ReaderT layer
</span>  <span class="o">)</span> 
</code></pre></div></div>

<p>If we were to get that same value using just transformers and no mtl, the amount of boilerplate would be excruciating. We would need multiple <code class="language-plaintext highlighter-rouge">liftF</code>s for every monad transformer and dozens of type annotations, leaving the actual code hidden under layers and layers of boilerplate.</p>

<p>With Cats-mtl, dealing with different effects is simple and free of boilerplate.
We can describe our application as functions dealing with an abstract context <code class="language-plaintext highlighter-rouge">F[_]</code> that must be able to provide certain effect constraints.
These constraints are provided by the different MTL type classes in Cats-mtl and their instances can be lifted up to the highest layer with Cats-mtl’s underlying machinery.</p>

<p>In summary Cats-mtl provides two things:
MTL type classes representing effects and a way to lift instances of these classes through transformer stacks.
If you’d like to learn more about Cats-mtl, <a href="https://typelevel.org/cats-mtl/">check out its new website!</a></p>

<h3 id="other-mtl-class-instances">Other mtl class instances</h3>

<p>Now I said that <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code> is the type class encoding of <code class="language-plaintext highlighter-rouge">ReaderT</code>, but it’s by no means the only one that can form an <code class="language-plaintext highlighter-rouge">ApplicativeAsk</code> instance.
Monad transformer stacks are known to be quite unperformant, especially so on the JVM, so there are some alternate solutions. For example, one could use <a href="https://github.com/traneio/arrows">the Arrows library</a>, which provides effect types with an input type in addition to its output type <code class="language-plaintext highlighter-rouge">Arrow[A, B]</code>. If you squint a bit, it’s practically equivalent to a function <code class="language-plaintext highlighter-rouge">A =&gt; IO[B]</code> or <code class="language-plaintext highlighter-rouge">ReaderT[IO, A, B]</code>. At the same time, however, it can be substantially more performant.</p>

<p>Other examples include using something like <code class="language-plaintext highlighter-rouge">cats-effect</code>’ <code class="language-plaintext highlighter-rouge">Ref</code> for <code class="language-plaintext highlighter-rouge">MonadState</code> (a working instance <a href="https://github.com/oleg-py/meow-mtl">can be found here</a>), or using a bifunctor <code class="language-plaintext highlighter-rouge">IO</code> that includes an extra type parameter for the error type, i.e. <code class="language-plaintext highlighter-rouge">BIO[E, A]</code> instead of using <code class="language-plaintext highlighter-rouge">EitherT[IO, E, A]</code> (a WIP for cats-effect <a href="https://github.com/LukaJCB/cats-bio">can be found here</a>).</p>

<p>In general, we can think up more performant solutions to our effect type class instances by using more specialized data structures. Monad Transformers are extremely general, which makes them very flexible, but that flexibility may come at a price. One of the great things about <code class="language-plaintext highlighter-rouge">mtl</code> is that we don’t have to choose up front, but only at the very end when our program is run.
For example, we might choose to use only monad transformers at the begining when developing our application. Then, when we want to scale up, we can move to more performant instances simply by changing a few lines when materializing our programs.</p>

<p>In the long term, I’d like to provide a submodule of <code class="language-plaintext highlighter-rouge">cats-mtl</code> that has very specialized and performant data types for every combination of effect type classes.
For this purpose, I’ve created <a href="https://github.com/LukaJCB/cats-mtl-special">the cats-mtl-special library</a> some time ago, but it still remains very much a work in progress.
Shoutout also to Jamie Pullar who has been using cats-mtl extensively in production and has also built some more performant instances along with some benchmarks which you can find <a href="https://www.slideshare.net/RyanAdams12/jamie-pullar-cats-mtl-in-action/39">as part of his talk here</a>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 06 Oct 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/10/06/intro-to-mtl.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/10/06/intro-to-mtl.html</guid>
      </item>
    
      <item>
        <title>Variance of Monad Transformers</title>
        
          <dc:creator>ceedubs</dc:creator>
                
        <description><![CDATA[<p>A question that <a href="https://github.com/typelevel/cats/issues/556">repeatedly</a> <a href="https://github.com/typelevel/cats/issues/2310">pops</a> <a href="https://github.com/typelevel/cats/issues/2538">up</a> about <a href="https://typelevel.org/cats/">Cats</a> is why monad transformer types like <code class="language-plaintext highlighter-rouge">OptionT</code> and <code class="language-plaintext highlighter-rouge">EitherT</code> aren’t covariant like their <code class="language-plaintext highlighter-rouge">Option</code> and <code class="language-plaintext highlighter-rouge">Either</code> counterparts. This blog post aims to answer that question.</p>

<h1 id="covariance">Covariance</h1>

<p>What does it mean to say that <code class="language-plaintext highlighter-rouge">Option</code> is covariant? It means that an <code class="language-plaintext highlighter-rouge">Option[B]</code> is allowed to be treated as an <code class="language-plaintext highlighter-rouge">Option[A]</code> if <code class="language-plaintext highlighter-rouge">B</code> is a subtype of <code class="language-plaintext highlighter-rouge">A</code>. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Err</span><span class="o">(</span><span class="k">val</span> <span class="nv">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">NotFound</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Err</span><span class="o">(</span><span class="n">s</span><span class="s">"Not found: $id"</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">optionNotFound</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NotFound</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">NotFound</span><span class="o">(</span><span class="mi">42L</span><span class="o">))</span>
<span class="c1">// optionNotFound: Option[NotFound] = Some(NotFound(42))
</span>
<span class="n">optionNotFound</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Err</span><span class="o">]</span>
<span class="c1">// res0: Option[Err] = Some(NotFound(42))
</span></code></pre></div></div>

<p>Great. If you want to treat your <code class="language-plaintext highlighter-rouge">Option[NotFound]</code> as an <code class="language-plaintext highlighter-rouge">Option[Err]</code>, you are free to.</p>

<p>This is made possible because the <code class="language-plaintext highlighter-rouge">Option</code> type is declared as <code class="language-plaintext highlighter-rouge">sealed abstract class Option[+A]</code>, where the <code class="language-plaintext highlighter-rouge">+</code> in front of the <code class="language-plaintext highlighter-rouge">A</code> means that it is covariant in the <code class="language-plaintext highlighter-rouge">A</code> type parameter.</p>

<p>What happens if we try to do the same with <code class="language-plaintext highlighter-rouge">OptionT</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Eval</span>
<span class="k">import</span> <span class="nn">cats.data.OptionT</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">optionTNotFound</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">NotFound</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OptionT</span><span class="o">(</span><span class="nv">Eval</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">optionNotFound</span><span class="o">))</span>
<span class="c1">// optionTNotFound: cats.data.OptionT[cats.Eval,NotFound] = OptionT(Now(Some(NotFound(42))))
</span></code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optionTNotFound</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">Err</span><span class="o">]</span>
<span class="c1">// &lt;console&gt;:17: error: type mismatch;
//  found   : cats.data.OptionT[cats.Eval,NotFound]
//  required: cats.data.OptionT[cats.Eval,Err]
// Note: NotFound &lt;: Err, but class OptionT is invariant in type A.
// You may wish to define A as +A instead. (SLS 4.5)
//        optionTNotFound: OptionT[Eval, Err]
//        ^
</span></code></pre></div></div>

<p>The compiler complains that an <code class="language-plaintext highlighter-rouge">OptionT[Eval, NotFound]</code> is <em>not</em> an <code class="language-plaintext highlighter-rouge">OptionT[Eval, Err]</code>, but it also suggests that we may be able to fix this by using <code class="language-plaintext highlighter-rouge">+A</code> like is done with <code class="language-plaintext highlighter-rouge">Option</code>.</p>

<p><code class="language-plaintext highlighter-rouge">OptionT</code> in Cats is defined as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">OptionT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<p>Let’s try to make the suggested change with an experimental <code class="language-plaintext highlighter-rouge">MyOptionT</code> structure:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MyOptionT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
<span class="c1">// &lt;console&gt;:14: error: covariant type A occurs in invariant position in type =&gt; F[Option[A]] of value value
//        final case class MyOptionT[F[_], +A](value: F[Option[A]])
//                                             ^
</span></code></pre></div></div>

<p>Now it’s complaining that <code class="language-plaintext highlighter-rouge">A</code> is a covariant type but shows up in an invariant position. We’ll discuss more about what this means later in the post, but for now let’s just try declaring <code class="language-plaintext highlighter-rouge">F</code> as covariant:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">CovariantOptionT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">+</span><span class="k">_</span><span class="o">]</span>, <span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">covOptionTNotFound</span><span class="k">:</span> <span class="kt">CovariantOptionT</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">NotFound</span><span class="o">]</span> <span class="k">=</span> <span class="nc">CovariantOptionT</span><span class="o">(</span><span class="nv">Eval</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">optionNotFound</span><span class="o">))</span>
<span class="c1">// covOptionTNotFound: CovariantOptionT[cats.Eval,NotFound] = CovariantOptionT(Now(Some(NotFound(42))))
</span>
<span class="n">covOptionTNotFound</span><span class="k">:</span> <span class="kt">CovariantOptionT</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">Err</span><span class="o">]</span>
<span class="c1">// res2: CovariantOptionT[cats.Eval,Err] = CovariantOptionT(Now(Some(NotFound(42))))
</span></code></pre></div></div>

<p>Woohoo! Problem solved, right?</p>

<p>Well, not exactly. This works great if <code class="language-plaintext highlighter-rouge">F</code> is in fact covariant, but what if it’s not? For example, the JSON library <a href="https://circe.github.io/circe/">circe</a> has a <code class="language-plaintext highlighter-rouge">Decoder</code> type that <em>could</em> be covariant but isn’t (at least as of circe 0.10.0). With the invariant <code class="language-plaintext highlighter-rouge">OptionT</code> in Cats we can do something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">io.circe.Decoder</span>

<span class="k">def</span> <span class="nf">defaultValueDecoder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">defaultValue</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">optionDecoder</span><span class="k">:</span> <span class="kt">Decoder</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Decoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">OptionT</span><span class="o">(</span><span class="n">optionDecoder</span><span class="o">).</span><span class="py">getOrElse</span><span class="o">(</span><span class="n">defaultValue</span><span class="o">)</span>
</code></pre></div></div>

<p>However, we can’t do the same with our <code class="language-plaintext highlighter-rouge">CovariantOptionT</code>, because we can’t even create an <code class="language-plaintext highlighter-rouge">OptionT</code> where the <code class="language-plaintext highlighter-rouge">F</code> type isn’t covariant:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wrap</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">optionDecoder</span><span class="k">:</span> <span class="kt">Decoder</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">CovariantOptionT</span><span class="o">[</span><span class="kt">Decoder</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">CovariantOptionT</span><span class="o">[</span><span class="kt">Decoder</span>, <span class="kt">A</span><span class="o">](</span><span class="n">optionDecoder</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:18: error: kinds of the type arguments (io.circe.Decoder,A) do not conform to the expected kinds of the type parameters (type F,type A).
// io.circe.Decoder's type parameters do not match type F's expected parameters:
// type A is invariant, but type _ is declared covariant
//          CovariantOptionT[Decoder, A](optionDecoder)
//                          ^
</span></code></pre></div></div>

<p>In this particular case, <code class="language-plaintext highlighter-rouge">Decoder</code> <em>could</em> be declared as covariant, but it’s not. It would be unfortunate to lose the ability to use a monad transformer because a 3rd party library chose not to make a type covariant. And perhaps more importantly, sometimes you might want to use an <code class="language-plaintext highlighter-rouge">OptionT</code> with an <code class="language-plaintext highlighter-rouge">F</code> type that fundamentally isn’t covariant in nature, such as <code class="language-plaintext highlighter-rouge">Monoid</code> (which is invariant) or <code class="language-plaintext highlighter-rouge">Order</code> (which is contravariant in nature and is declared as invariant in its type definition). Later in this post there will be some examples of using <code class="language-plaintext highlighter-rouge">OptionT</code> with a contravariant functor type (<code class="language-plaintext highlighter-rouge">Eq</code>) to gain acess to a handy <code class="language-plaintext highlighter-rouge">contramap</code> operation.</p>

<h1 id="workaround">Workaround</h1>

<p>It’s completely reasonable to want to be able to take your <code class="language-plaintext highlighter-rouge">OptionT[Eval, NotFound]</code> and treat it as an <code class="language-plaintext highlighter-rouge">OptionT[Eval, Err]</code>, and in some cases it may only be typed as <code class="language-plaintext highlighter-rouge">OptionT[Eval, NotFound]</code> because of type inference picking a more specific type than you intended. Luckily Cats has some handy methods to make this easy:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">optionTNotFound</span><span class="o">.</span><span class="py">widen</span><span class="o">[</span><span class="kt">Err</span><span class="o">]</span>
<span class="c1">// res4: cats.data.OptionT[cats.Eval,Err] = OptionT(Now(Some(NotFound(42))))
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">.widen</code> method is available for any type that has a <code class="language-plaintext highlighter-rouge">Functor</code>. If you are working with a type that represents a <code class="language-plaintext highlighter-rouge">Bifunctor</code>, such as <code class="language-plaintext highlighter-rouge">EitherT</code>, then you can use <code class="language-plaintext highlighter-rouge">widen</code> for the type on the right and <code class="language-plaintext highlighter-rouge">leftWiden</code> for the type on the left:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.EitherT</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">eitherTNotFound</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">NotFound</span>, <span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">EitherT</span><span class="o">.</span><span class="py">leftT</span><span class="o">[</span><span class="kt">Eval</span>, <span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="nc">NotFound</span><span class="o">(</span><span class="mi">42L</span><span class="o">))</span>
<span class="c1">// eitherTNotFound: cats.data.EitherT[cats.Eval,NotFound,Some[Int]] = EitherT(Now(Left(NotFound(42))))
</span>
<span class="nv">eitherTNotFound</span><span class="o">.</span><span class="py">widen</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
<span class="c1">// res5: cats.data.EitherT[cats.Eval,NotFound,Option[Int]] = EitherT(Now(Left(NotFound(42))))
</span>
<span class="nv">eitherTNotFound</span><span class="o">.</span><span class="py">leftWiden</span><span class="o">[</span><span class="kt">Err</span><span class="o">]</span>
<span class="c1">// res6: cats.data.EitherT[cats.Eval,Err,Some[Int]] = EitherT(Now(Left(NotFound(42))))
</span></code></pre></div></div>

<p>Similarly there is a <code class="language-plaintext highlighter-rouge">narrow</code> method for contravariant functors:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Eq</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">optionTEqErr</span><span class="k">:</span> <span class="kt">OptionT</span><span class="o">[</span><span class="kt">Eq</span>, <span class="kt">Err</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OptionT</span><span class="o">(</span><span class="nc">Eq</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]).</span><span class="py">contramap</span><span class="o">((</span><span class="n">err</span><span class="k">:</span> <span class="kt">Err</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">err</span><span class="o">.</span><span class="py">msg</span><span class="o">)</span>
<span class="c1">// optionTEqErr: cats.data.OptionT[cats.Eq,Err] = OptionT(cats.kernel.Eq$$anon$103@33f6456e)
</span>
<span class="nv">optionTEqErr</span><span class="o">.</span><span class="py">narrow</span><span class="o">[</span><span class="kt">NotFound</span><span class="o">]</span>
<span class="c1">// res7: cats.data.OptionT[cats.Eq,NotFound] = OptionT(cats.kernel.Eq$$anon$103@33f6456e)
</span></code></pre></div></div>

<h1 id="back-to-that-compile-error">Back to that compile error…</h1>

<p>Let’s return to that <code class="language-plaintext highlighter-rouge">covariant type A occurs in invariant position</code> compile error that was triggered when we tried to declare <code class="language-plaintext highlighter-rouge">final case class MyOptionT[F[_], +A](value: F[Option[A]])</code>. Why did this happen?</p>

<p>Pretend for a minute that the Scala compiler <em>did</em> allow us to do this. We could then write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">eqOptionNotFound</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">NotFound</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Eq</span><span class="o">.</span><span class="py">instance</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">NotFound</span><span class="o">]]{</span>
  <span class="nf">case</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="nf">case</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="nf">case</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">),</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="nf">case</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">id</span> <span class="o">===</span> <span class="nv">y</span><span class="o">.</span><span class="py">id</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">optionTEqNotFound</span><span class="k">:</span> <span class="kt">MyOptionT</span><span class="o">[</span><span class="kt">Eq</span>, <span class="kt">NotFound</span><span class="o">]</span> <span class="k">=</span> <span class="nc">MyOptionT</span><span class="o">(</span><span class="n">eqOptionNotfound</span><span class="o">)</span> <span class="c1">// only allowed in our pretend world
</span>
<span class="k">val</span> <span class="nv">optionTEqErr</span><span class="k">:</span> <span class="kt">MyOptionT</span><span class="o">[</span><span class="kt">Eq</span>, <span class="kt">Err</span><span class="o">]</span> <span class="k">=</span> <span class="n">optionTEqNotFound</span> <span class="c1">// only allowed in our pretend world
</span></code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">MyOptionT</code> would be covariant in <code class="language-plaintext highlighter-rouge">A</code>, this <code class="language-plaintext highlighter-rouge">MyOptionT[Eq, NotFound]</code> could be treated as a <code class="language-plaintext highlighter-rouge">MyOptionT[Eq, Err]</code>. That is, it would have a <code class="language-plaintext highlighter-rouge">value</code> that is an <code class="language-plaintext highlighter-rouge">Eq[Option[Err]]</code>. But if you look at how we implemented our equality check, it’s taking two <code class="language-plaintext highlighter-rouge">NotFound</code> instances and comparing their <code class="language-plaintext highlighter-rouge">id</code> fields. For a general <code class="language-plaintext highlighter-rouge">Err</code>, we have no guarantee that it will be a <code class="language-plaintext highlighter-rouge">NotFound</code> and that it will have an <code class="language-plaintext highlighter-rouge">id</code> field. We can’t treat an <code class="language-plaintext highlighter-rouge">Eq[Option[NotFound]]</code> as an <code class="language-plaintext highlighter-rouge">Eq[Option[Err]]</code>, because <code class="language-plaintext highlighter-rouge">Eq</code> is contravariant and <em>not</em> covariant in nature. The <code class="language-plaintext highlighter-rouge">covariant type A occurs in invariant position</code> message that the scala compiler gave us was the compiler correctly identifying that our code was unsound.</p>

<h1 id="conclusion">Conclusion</h1>

<p>There are some use-cases in which having monad transforers such as <code class="language-plaintext highlighter-rouge">OptionT</code> and <code class="language-plaintext highlighter-rouge">EitherT</code> be defined as covariant would be convenient, such as helping to nudge type inference in the right direction. However, if Cats were to define these types as covariant, it would eliminate the possibility of using them with non-covariant types. Forcing covariance in Cats would be overly restrictive, since third-party libraries might not declare types as covariant, and monad transformers can be useful for invariant a contravariant types. Luckily, methods such as <code class="language-plaintext highlighter-rouge">widen</code>, <code class="language-plaintext highlighter-rouge">leftWiden</code>, and <code class="language-plaintext highlighter-rouge">narrow</code> provide concise solutions to turning a monad transformer (or other type that forms a functor) into the type that you need.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/09/29/monad-transformer-variance.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/09/29/monad-transformer-variance.html</guid>
      </item>
    
      <item>
        <title>Chain – Replacing the List Monoid</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p><code class="language-plaintext highlighter-rouge">List</code> is a great data type, it is very simple and easy to understand.
It has very low overhead for the most important functions such as <code class="language-plaintext highlighter-rouge">fold</code> and <code class="language-plaintext highlighter-rouge">map</code> and also supports prepending a single element in constant time.</p>

<p>Traversing a data structure with something like <code class="language-plaintext highlighter-rouge">Writer[List[Log], A]</code> or <code class="language-plaintext highlighter-rouge">ValidatedNel[Error, A]</code> is  powerful and allows us to precisely specify what kind of iteration we want to do while remaining succint.
However, in terms of efficiency it’s a whole different story unfortunately.
That is because both of these traversals make use of the <code class="language-plaintext highlighter-rouge">List</code> monoid (or the <code class="language-plaintext highlighter-rouge">NonEmptyList</code> semigroup), which by the nature of <code class="language-plaintext highlighter-rouge">List</code> is very inefficient.
If you use <code class="language-plaintext highlighter-rouge">traverse</code> with a data structure with <code class="language-plaintext highlighter-rouge">n</code> elements and <code class="language-plaintext highlighter-rouge">Writer</code> or <code class="language-plaintext highlighter-rouge">Validated</code> as the <code class="language-plaintext highlighter-rouge">Applicative</code> type, you will end up with a runtime of <code class="language-plaintext highlighter-rouge">O(n^2)</code>.
This is because, with <code class="language-plaintext highlighter-rouge">List</code>, appending a single element requires iterating over the entire data structure and therefore takes linear time.</p>

<p>So <code class="language-plaintext highlighter-rouge">List</code> isn’t all that great for this use case, so let’s use <code class="language-plaintext highlighter-rouge">Vector</code> or <code class="language-plaintext highlighter-rouge">NonEmptyVector</code> instead, right?</p>

<p>Well, <code class="language-plaintext highlighter-rouge">Vector</code> has its own problems and in this case it’s unfortunately not that much faster than <code class="language-plaintext highlighter-rouge">List</code> at all. You can check <a href="http://www.lihaoyi.com/post/BenchmarkingScalaCollections.html#vectors-are-ok">this blog post</a> by Li Haoyi for some deeper insight into <code class="language-plaintext highlighter-rouge">Vector</code>’s issues.</p>

<p>Because of this, it’s now time to welcome a new data structure to Cats.
Meet <code class="language-plaintext highlighter-rouge">Chain</code> and its non-empty counterpart, <code class="language-plaintext highlighter-rouge">NonEmptyChain</code>.</p>

<p>Available in the newest Cats 1.3.1 release, <code class="language-plaintext highlighter-rouge">Chain</code> evolved from what used to be <code class="language-plaintext highlighter-rouge">fs2.Catenable</code> and Erik Osheim’s <a href="https://github.com/non/chain">Chain</a> library.
Similar to <code class="language-plaintext highlighter-rouge">List</code>, it is also a very simple data structure, but unlike <code class="language-plaintext highlighter-rouge">List</code> it supports both constant O(1) time <code class="language-plaintext highlighter-rouge">append</code> and <code class="language-plaintext highlighter-rouge">prepend</code>.
This makes its <code class="language-plaintext highlighter-rouge">Monoid</code> instance super performant and a much better fit for usage with <code class="language-plaintext highlighter-rouge">Validated</code>,<code class="language-plaintext highlighter-rouge">Writer</code>, <code class="language-plaintext highlighter-rouge">Ior</code> or <code class="language-plaintext highlighter-rouge">Const</code>.</p>

<p>To utilize this, we’ve added a bunch of <code class="language-plaintext highlighter-rouge">NonEmptyChain</code> shorthands in Cats 1.3 that mirror those that used <code class="language-plaintext highlighter-rouge">NonEmptyList</code> in earlier versions. These include type aliases like <code class="language-plaintext highlighter-rouge">ValidatedNec</code> or <code class="language-plaintext highlighter-rouge">IorNec</code> as well as helper functions like <code class="language-plaintext highlighter-rouge">groupByNec</code> or <code class="language-plaintext highlighter-rouge">Validated.invalidNec</code>.
We hope that these make it easy for you to upgrade to the more efficient data structure and enjoy those benefits as soon as possible.</p>

<p>To get a good idea of the performance improvements, here are some benchmarks that test monoidal append (higher score is better):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] Benchmark                                  Mode  Cnt   Score   Error  Units
[info] CollectionMonoidBench.accumulateChain     thrpt   20  51.911 ± 7.453  ops/s
[info] CollectionMonoidBench.accumulateList      thrpt   20   6.973 ± 0.781  ops/s
[info] CollectionMonoidBench.accumulateVector    thrpt   20   6.304 ± 0.129  ops/s
</code></pre></div></div>

<p>As you can see accumulating things with <code class="language-plaintext highlighter-rouge">Chain</code> is more than 7 times faster than <code class="language-plaintext highlighter-rouge">List</code> and over 8 times faster than <code class="language-plaintext highlighter-rouge">Vector</code>.
So appending is a lot more performant than the standard library collections, but what about operations like <code class="language-plaintext highlighter-rouge">map</code> or <code class="language-plaintext highlighter-rouge">fold</code>?
Fortunately we’ve also benchmarked these (again, higher score is better):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] Benchmark                           Mode  Cnt          Score         Error  Units
[info] ChainBench.foldLeftLargeChain      thrpt   20        117.267 ±       1.815  ops/s
[info] ChainBench.foldLeftLargeList       thrpt   20        135.954 ±       3.340  ops/s
[info] ChainBench.foldLeftLargeVector     thrpt   20         61.613 ±       1.326  ops/s
[info]
[info] ChainBench.mapLargeChain           thrpt   20         59.379 ±       0.866  ops/s
[info] ChainBench.mapLargeList            thrpt   20         66.729 ±       7.165  ops/s
[info] ChainBench.mapLargeVector          thrpt   20         61.374 ±       2.004  ops/s
</code></pre></div></div>

<p>While not as dominant, <code class="language-plaintext highlighter-rouge">Chain</code> holds its ground fairly well.
It won’t have the random access performance of something like <code class="language-plaintext highlighter-rouge">Vector</code>, but in a lot of other cases, <code class="language-plaintext highlighter-rouge">Chain</code> seems to outperform it quite handily.
So if you don’t perform a lot of random access on your data structure, then you should be fine using <code class="language-plaintext highlighter-rouge">Chain</code> extensively instead.</p>

<p>So next time you write any code that uses <code class="language-plaintext highlighter-rouge">List</code> or <code class="language-plaintext highlighter-rouge">Vector</code> as a <code class="language-plaintext highlighter-rouge">Monoid</code>, be sure to use <code class="language-plaintext highlighter-rouge">Chain</code> instead!</p>

<p>The whole code for <code class="language-plaintext highlighter-rouge">Chain</code> and <code class="language-plaintext highlighter-rouge">NonEmptyChain</code> can be found <a href="https://github.com/typelevel/cats/blob/v1.3.0/core/src/main/scala/cats/data/Chain.scala">here</a> and <a href="https://github.com/typelevel/cats/blob/v1.3.0/core/src/main/scala/cats/data/NonEmptyChain.scala">here</a>.
You can also check out the benchmarks <a href="https://github.com/typelevel/cats/blob/v1.3.0/bench/src/main/scala/cats/bench">here</a>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/09/04/chain-replacing-the-list-monoid.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/09/04/chain-replacing-the-list-monoid.html</guid>
      </item>
    
      <item>
        <title>Error handling in Http4s with classy optics</title>
        
          <dc:creator>gvolpe</dc:creator>
                
        <description><![CDATA[<p>As a longtime <code class="language-plaintext highlighter-rouge">http4s</code> user I keep on learning new things and I’m always trying to come up with the best practices for writing http applications. This time I want to talk about my latest achievements in error handling within the context of an http application where it basically means mapping each business error to the appropiate <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">http response</a>.</p>

<p>So let’s get started by putting up an example of an http application with three different endpoints that interacts with a <code class="language-plaintext highlighter-rouge">UserAlgebra</code> that may or may not fail with some specific errors.</p>

<p>If you are one of those who don’t like to read and prefer to jump straight into the code please find it <a href="https://gist.github.com/gvolpe/3fa32dd1b6abce2a5466efbf0eca9e94">here</a> :)</p>

<h3 id="user-algebra">User Algebra</h3>

<p>We have a simple <code class="language-plaintext highlighter-rouge">UserAlgebra</code> that let us perform some actions such as finding and persisting users.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserUpdateAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">trait</span> <span class="nc">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">updateAge</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And also an ADT of the possible errors that may arise. I’ll explain later in this post why it extends <code class="language-plaintext highlighter-rouge">Exception</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserError</span> <span class="k">extends</span> <span class="nc">Exception</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
</code></pre></div></div>

<h3 id="user-interpreter">User Interpreter</h3>

<p>And here we have a simple interpreter for our <code class="language-plaintext highlighter-rouge">UserAlgebra</code> for demonstration purposes so you can have an idea on how the logic would look like. In a real-life project an interpreter will more likely connect to a database instead of using an in-memory representaion based on <code class="language-plaintext highlighter-rouge">Ref</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.Sync</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">object</span> <span class="nc">UserInterpreter</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nv">Ref</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">User</span><span class="o">]](</span><span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span> <span class="n">state</span> <span class="k">=&gt;</span>
      <span class="k">new</span> <span class="nc">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">private</span> <span class="k">def</span> <span class="nf">validateAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="nf">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="o">))</span> <span class="k">else</span> <span class="nv">F</span><span class="o">.</span><span class="py">unit</span>

        <span class="k">override</span> <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
          <span class="nv">state</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">username</span><span class="o">))</span>

        <span class="k">override</span> <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="nf">validateAge</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">age</span><span class="o">)</span> <span class="o">*&gt;</span>
            <span class="nf">find</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">))</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
                <span class="nv">state</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">,</span> <span class="n">user</span><span class="o">))</span>
            <span class="o">}</span>

        <span class="k">override</span> <span class="k">def</span> <span class="nf">updateAge</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="nf">validateAge</span><span class="o">(</span><span class="n">age</span><span class="o">)</span> <span class="o">*&gt;</span>
            <span class="nf">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nv">state</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="nv">user</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">age</span> <span class="k">=</span> <span class="n">age</span><span class="o">)))</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
                <span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="o">))</span>
            <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="http-routes">Http Routes</h3>

<p>The following implementation of <code class="language-plaintext highlighter-rouge">UserRoutes</code> applies the tagless final encoding and the concept of “abstracting over the effect type” where we do not commit to a particular effect until the edge of our application.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">io.circe.generic.auto._</span>
<span class="k">import</span> <span class="nn">io.circe.syntax._</span>
<span class="k">import</span> <span class="nn">org.http4s._</span>
<span class="k">import</span> <span class="nn">org.http4s.circe._</span>
<span class="k">import</span> <span class="nn">org.http4s.circe.CirceEntityDecoder._</span>
<span class="k">import</span> <span class="nn">org.http4s.dsl.Http4sDsl</span>

<span class="k">class</span> <span class="nc">UserRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">userAlgebra</span><span class="k">:</span> <span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">val</span> <span class="nv">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">HttpRoutes</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">User</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
        <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
        <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="nv">userUpdate</span><span class="o">.</span><span class="py">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="n">username</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Now this particular implementation is missing a very important part: error handling. If we use the <code class="language-plaintext highlighter-rouge">UserAlgebra</code>’s interpreter previously defined we will clearly miss the three errors defined by the <code class="language-plaintext highlighter-rouge">UserError</code> ADT.</p>

<p><strong><em>NOTE: If you are not familiar with these concepts make sure you check out <a href="https://youtu.be/pGfj_l-h3M8?t=887">my talk at Scala Matsuri</a> early this year where I also talk about error handling in http applications using the Http4s library.</em></strong></p>

<h3 id="http-error-handling">Http Error Handling</h3>

<p>Okay let’s just go ahead and add some error handling to our http route by taking advantange of the <code class="language-plaintext highlighter-rouge">MonadError</code> instance defined by our constraint <code class="language-plaintext highlighter-rouge">Sync[F]</code> and making use of the syntax provided by <code class="language-plaintext highlighter-rouge">cats</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserRoutesAlt</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">userAlgebra</span><span class="k">:</span> <span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">val</span> <span class="nv">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">HttpRoutes</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">User</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
        <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}.</span><span class="py">handleErrorWith</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Conflict</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
        <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="nv">userUpdate</span><span class="o">.</span><span class="py">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}.</span><span class="py">handleErrorWith</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BadRequest</span><span class="o">(</span><span class="n">s</span><span class="s">"Invalid age $age"</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Now we can say this implementation is quite elegant! We are handling and mapping business errors to the according http response and our code compiles without any warning whatsoever. But wait… We are not handling the <code class="language-plaintext highlighter-rouge">UserNotFound</code> error and the compiler didn’t tell us about it! That’s not cool and we as functional programmers believe in types because we can know what a function might do just by looking at the types but here it seems we hit the wall.</p>

<p>The problem is that our constraint of type <code class="language-plaintext highlighter-rouge">Sync</code> from <code class="language-plaintext highlighter-rouge">cats-effect</code> has a <code class="language-plaintext highlighter-rouge">MonadError</code> instance with its type error fixed as <code class="language-plaintext highlighter-rouge">Throwable</code>. So the compiler can’t help us here since this type is too generic. And we can’t add a constraint for <code class="language-plaintext highlighter-rouge">MonadError[F, UserError]</code> because we would get an “ambigous implicits” error with two instances of <code class="language-plaintext highlighter-rouge">MonadError</code> in scope.</p>

<p>So, what can we do about it?</p>

<h3 id="next-level-mtl-optics">Next level MTL: Optics</h3>

<p>I heard sometime ago about Classy Optics (Lenses, Prisms, etc) when I was learning Haskell and watched <a href="https://www.youtube.com/watch?v=GZPup5Iuaqw">this amazing talk</a> by George Wilson but I never got to use this concept in Scala until now!</p>

<p>Well first, let me give you a quick definition of <code class="language-plaintext highlighter-rouge">Lens</code>es and <code class="language-plaintext highlighter-rouge">Prism</code>s. In a few words we can define:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Lens</code>es as getters and setters that compose making the accessing of nested data structure’s fields quite easy.</li>
  <li><code class="language-plaintext highlighter-rouge">Prism</code>s as first-class pattern matching that let us access branches of an ADT and that also compose.</li>
</ul>

<p>And <code class="language-plaintext highlighter-rouge">Classy Optics</code> as the idea of “associate with each type a typeclass full of optics for that type”.</p>

<p><strong><em>So what am I talking about and how can these concepts help us solving the http error handling problem?</em></strong></p>

<p>Remember that I defined the <code class="language-plaintext highlighter-rouge">UserError</code> ADT by extending <code class="language-plaintext highlighter-rouge">Exception</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserError</span> <span class="k">extends</span> <span class="nc">Exception</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
</code></pre></div></div>

<p>Well there’s a reason! By making <code class="language-plaintext highlighter-rouge">UserError</code> a subtype of <code class="language-plaintext highlighter-rouge">Exception</code> (and by default of <code class="language-plaintext highlighter-rouge">Throwable</code>) we can take advantage of <code class="language-plaintext highlighter-rouge">Prisms</code> by going back and forth in the types. See what I’m going yet?</p>

<p><code class="language-plaintext highlighter-rouge">UserRoute</code> has a <code class="language-plaintext highlighter-rouge">Sync[F]</code> constraint, meaning that we have available a <code class="language-plaintext highlighter-rouge">MonadError[F, Throwable]</code> instance, but we would like to have <code class="language-plaintext highlighter-rouge">MonadError[F, UserError]</code> instead to leverage the Scala compiler. The caveat is that the error types need to be of the same family so we can derive a <code class="language-plaintext highlighter-rouge">Prism</code> that can navigate the errors types in one direction or another. But how do we derive it?</p>

<h4 id="cats-meow-mtl">Cats Meow MTL</h4>

<p>Fortunately our friend <a href="https://twitter.com/oleg_pyzhcov">Oleg Pyzhcov</a> has created this great library named <a href="https://github.com/oleg-py/meow-mtl">meow-mtl</a> that makes heavy use of <a href="https://github.com/milessabin/shapeless">Shapeless</a> in order to derive <code class="language-plaintext highlighter-rouge">Lenses</code> and <code class="language-plaintext highlighter-rouge">Prisms</code> and it provides instances for some <code class="language-plaintext highlighter-rouge">cats-effect</code> compatible datatypes.</p>

<p>And two of the supported typeclasses are <code class="language-plaintext highlighter-rouge">ApplicativeError</code> and <code class="language-plaintext highlighter-rouge">MonadError</code> as long as the error type is a subtype of <code class="language-plaintext highlighter-rouge">Throwable</code> to make it compatible with <code class="language-plaintext highlighter-rouge">cats-effect</code>. So we can do something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.MonadError</span>
<span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">com.olegpy.meow.hierarchy._</span> <span class="c1">// All you need is this import!
</span><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">CustomError</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Throwable</span>

<span class="k">def</span> <span class="nf">customHandle</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fallback</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">CustomError</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">f</span><span class="o">.</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">fallback</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nv">IO</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span> <span class="o">}</span>
<span class="nf">customHandle</span><span class="o">(</span><span class="n">io</span><span class="o">,</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">))</span>
</code></pre></div></div>

<h4 id="generalizing-http-error-handling">Generalizing Http Error Handling</h4>

<p>Now back to our use case. We can’t have a <code class="language-plaintext highlighter-rouge">MonadError[F, UserError]</code> constraint because there’s already a <code class="language-plaintext highlighter-rouge">MonadError[F, Throwable]</code> in scope given our <code class="language-plaintext highlighter-rouge">Sync[F]</code> constraint. But it turns out we can make this work if we also abstract over the error handling by introducing an <code class="language-plaintext highlighter-rouge">HttpErrorHandler</code> algebra where the error type is a subtype of <code class="language-plaintext highlighter-rouge">Throwable</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">HttpErrorHandler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span> <span class="k">=</span> <span class="n">ev</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">UserRoutes</code> can now have an additional constraint of type <code class="language-plaintext highlighter-rouge">HttpErrorHandler[F, UserError]</code> so we clearly know what kind of errors we are dealing with and can have the Scala compiler on our side.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserRoutesMTL</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">userAlgebra</span><span class="k">:</span> <span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">H</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="nv">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">HttpRoutes</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">User</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
        <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="nv">user</span><span class="o">.</span><span class="py">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="nv">req</span><span class="o">.</span><span class="py">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
        <span class="nv">userAlgebra</span><span class="o">.</span><span class="py">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="nv">userUpdate</span><span class="o">.</span><span class="py">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="nv">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nv">H</span><span class="o">.</span><span class="py">handle</span><span class="o">(</span><span class="n">httpRoutes</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>We are basically delegating the error handling (AKA mapping business errors to appropiate http responses) to a specific algebra.</p>

<p>We also need an implementation for this algebra in order to handle errors of type <code class="language-plaintext highlighter-rouge">UserError</code> but first we can introduce a <code class="language-plaintext highlighter-rouge">RoutesHttpErrorHandler</code> object that encapsulates the repetitive task of handling errors given an <code class="language-plaintext highlighter-rouge">HttpRoutes[F]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.ApplicativeError</span>
<span class="k">import</span> <span class="nn">cats.data.</span><span class="o">{</span><span class="nc">Kleisli</span><span class="o">,</span> <span class="nc">OptionT</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">RoutesHttpErrorHandler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="n">handler</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Response</span><span class="o">[</span><span class="kt">F</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ApplicativeError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span> <span class="o">{</span> <span class="n">req</span><span class="k">:</span> <span class="kt">Request</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="nc">OptionT</span> <span class="o">{</span>
        <span class="nv">routes</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">req</span><span class="o">).</span><span class="py">value</span><span class="o">.</span><span class="py">handleErrorWith</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">handler</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And our implementation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="nv">handler</span><span class="k">:</span> <span class="kt">UserError</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Response</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BadRequest</span><span class="o">(</span><span class="n">s</span><span class="s">"Invalid age $age"</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Conflict</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="nv">username</span><span class="o">.</span><span class="py">asJson</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">handle</span><span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">RoutesHttpErrorHandler</span><span class="o">(</span><span class="n">routes</span><span class="o">)(</span><span class="n">handler</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>If we forget to handle some errors the compiler will shout at us <strong><em>“match may not be exhaustive!”</em></strong> That’s fantastic :)</p>

<h4 id="wiring-all-the-components">Wiring all the components</h4>

<p>And the last part will be the wiring of all these components where we need to include the <code class="language-plaintext highlighter-rouge">meow-mtl</code> import to figure out the derivation of the instances we need in order to make this work. It’ll look something like this if using <code class="language-plaintext highlighter-rouge">cats.effect.IO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.olegpy.meow.hierarchy._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">userHttpErrorHandler</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UserError</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UserHttpErrorHandler</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>

<span class="nv">UserInterpreter</span><span class="o">.</span><span class="py">create</span><span class="o">[</span><span class="kt">IO</span><span class="o">].</span><span class="py">flatMap</span> <span class="o">{</span> <span class="nc">UserAlgebra</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">routes</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UserRoutesMTL</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="nc">UserAlgebra</span><span class="o">)</span>
  <span class="nv">IO</span><span class="o">.</span><span class="py">unit</span> <span class="c1">// pretend this is the rest of your program
</span><span class="o">}</span>
</code></pre></div></div>

<h3 id="final-thoughts">Final thoughts</h3>

<p>This is such an exciting time to be writing pure functional programming in Scala! The Typelevel ecosystem is getting richer and more mature, having an amazing set of libraries to solve business problems in an elegant and purely functional way.</p>

<p>I hope you have enjoyed this post and please do let me know if you know of better ways to solve this problem in the comments!</p>

<p>And last but not least I would like to thank all the friendly folks I hang out with in the <code class="language-plaintext highlighter-rouge">cats-effect</code>, <code class="language-plaintext highlighter-rouge">cats</code>, <code class="language-plaintext highlighter-rouge">fs2</code> and <code class="language-plaintext highlighter-rouge">http4s</code> Gitter channels for all the time and effort they put (<em>for free</em>) into making this community an amazing space.</p>

<p><strong>UPDATE:</strong> See the new article <a href="https://typelevel.org/blog/2018/11/28/http4s-error-handling-mtl-2.html">Error handling in Http4s with classy optics – Part 2</a>.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 25 Aug 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/08/25/http4s-error-handling-mtl.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/08/25/http4s-error-handling-mtl.html</guid>
      </item>
    
      <item>
        <title>Refactoring with Monads</title>
        
          <dc:creator>mtomko</dc:creator>
                
        <description><![CDATA[<p>I was recently cleaning up some Scala code I’d written a few months
ago when I realized I had been structuring code in a very confusing
way for a very long time. At work, we’ve been trying to untangle the
knots of code that get written by different authors at different
times, as requirements inevitably evolve. We all know that code should
be made up of short, easily digestible functions but we don’t always
get guidance on how to achieve that. In the presence of error handling
and nested data structures, the problem gets even harder.</p>

<p>The goal of this blog post is to describe a concrete strategy for
structuring code so that the overall flow of control is clear to the
reader, even months later; and so the smaller pieces are both
digestible and testable. I’ll start by giving an example function,
operating on some nested data types. Then I’ll explore some ways to
break it into smaller pieces. The key insight is that we can use
computational effects in the form of
<a href="https://typelevel.org/cats/typeclasses/monad.html">monads</a> (more
specifically,
<a href="https://typelevel.org/cats/api/cats/MonadError.html">MonadError</a>) to
wrap smaller pieces and ultimately, compose them into an
understandable sequence of computations.</p>

<h3 id="example-domain-reading-a-catalog">Example domain: reading a catalog</h3>

<p>Let’s not worry about <code class="language-plaintext highlighter-rouge">MonadError</code> yet, but instead look at some
example code. Consider a situation where you need to translate data
from one domain model to another one with different restrictions, and
controlled vocabularies. This can happen in a number of places in a
program, for instance reading a database or an HTTP request to
construct a domain object.</p>

<p>Suppose we need to read an object from a relational database.
Unfortunately, rows in the table may represent objects of a variety of
types so we have to read the row and build up the object graph
accordingly. This is the boundary between the weakly typed wilderness
and the strongly typed world within our program.</p>

<p>Say our database table represents a library catalog, which might have
print books and ebooks. We’d like to look up a book by ID and get back
a nicely typed record.</p>

<p>Here’s a simple table</p>

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>title</th>
      <th>author</th>
      <th>format</th>
      <th>download_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>45</td>
      <td>Programming In Haskell</td>
      <td>Hutton, Graham</td>
      <td>print</td>
      <td>null</td>
    </tr>
    <tr>
      <td>46</td>
      <td>Programming In Haskell</td>
      <td>Hutton, Graham</td>
      <td>ebook</td>
      <td>epub</td>
    </tr>
    <tr>
      <td>49</td>
      <td>Programming In Haskell</td>
      <td>Hutton, Graham</td>
      <td>ebook</td>
      <td>pdf</td>
    </tr>
  </tbody>
</table>

<p>We can define a simple domain model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Format</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Print</span> <span class="k">extends</span> <span class="nc">Format</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Digital</span> <span class="k">extends</span> <span class="nc">Format</span>
<span class="k">object</span> <span class="nc">Format</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">fromString</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Format</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DownloadType</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Epub</span> <span class="k">extends</span> <span class="nc">DownloadType</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Pdf</span> <span class="k">extends</span> <span class="nc">DownloadType</span>
<span class="k">object</span> <span class="nc">DownloadType</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">fromString</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">DownloadType</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Book</span> <span class="k">extends</span> <span class="nc">Product</span> <span class="k">with</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">id</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="nf">title</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">def</span> <span class="nf">author</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">def</span> <span class="nf">format</span><span class="k">:</span> <span class="kt">Format</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">PrintBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Book</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">format</span><span class="k">:</span> <span class="kt">Format</span> <span class="o">=</span> <span class="nc">Print</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">EBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">downloadType</span><span class="k">:</span> <span class="kt">DownloadType</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Book</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">format</span><span class="k">:</span> <span class="kt">Format</span> <span class="o">=</span> <span class="nc">Digital</span>
<span class="o">}</span>

</code></pre></div></div>

<p>We want to be able to define a method such as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<h3 id="monolithic-function">Monolithic function</h3>
<p>One trivial definition of <code class="language-plaintext highlighter-rouge">findBookById</code> might be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Try</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// unsafeQueryUnique returns a `Try[Row]`
</span>  <span class="nv">DB</span><span class="o">.</span><span class="py">unsafeQueryUnique</span><span class="o">(</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">row</span> <span class="k">=&gt;</span>
    <span class="c1">// pick out the properties every book possesses
</span>    <span class="k">val</span> <span class="nv">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">formatStr</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">)</span>

    <span class="c1">// now start to determine the types - get the format first
</span>    <span class="nv">Format</span><span class="o">.</span><span class="py">fromString</span><span class="o">(</span><span class="n">formatStr</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
        <span class="c1">// for print books, we can construct the book and return immediately
</span>        <span class="nc">Success</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
        <span class="c1">// for digital books we need to handle the download type
</span>        <span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"download_type"</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
            <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">AssertionError</span><span class="o">(</span><span class="n">s</span><span class="s">"download type not provided for digital book $id"</span><span class="o">))</span>
          <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">downloadStr</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nv">DownloadType</span><span class="o">.</span><span class="py">fromString</span><span class="o">(</span><span class="n">downloadStr</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">dt</span> <span class="k">=&gt;</span>
              <span class="nc">Success</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">dt</span><span class="o">))</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Depending on your perspective, that is arguably a long function. If
you think it is not so long, pretend that the table has a number of
other fields that must also be conditionally parsed to construct a
<code class="language-plaintext highlighter-rouge">Book</code>.</p>

<h3 id="tail-refactoring">Tail refactoring</h3>
<p>One possible approach is a a strategy I’m going to call
“tail-refactoring”, for lack of a better description. Basically, each
function does a little work or some error checking, and then calls the
next appropriate function in the chain.</p>

<p>You can imagine what kind of code will result. The functions are
smaller, but it’s hard to describe what each function does, and
functions occasionally have to carry along additional parameters that
they will ignore except to pass deeper into the call chain. Let’s take
a look at an example refactoring:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Try</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">extractEBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">downloadTypeStrOpt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">EBook</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">downloadTypeStrOpt</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">AssertionError</span><span class="o">())</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">downloadTypeStr</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">DownloadType</span><span class="o">.</span><span class="py">fromString</span><span class="o">(</span><span class="n">downloadTypeStr</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">dt</span> <span class="k">=&gt;</span>
        <span class="nc">Success</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">dt</span><span class="o">))</span>
      <span class="o">}</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">extractBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">formatStr</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">downloadTypeStrOpt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Format</span><span class="o">.</span><span class="py">fromString</span><span class="o">(</span><span class="n">formatStr</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
      <span class="nc">Success</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
      <span class="nf">extractEBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">downloadTypeStrOpt</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">DB</span><span class="o">.</span><span class="py">unsafeQueryUnique</span><span class="o">(</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">row</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">formatStr</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">downloadTypeStr</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"download_type"</span><span class="o">)</span>
    <span class="nf">extractBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">formatStr</span><span class="o">,</span> <span class="n">downloadTypeStr</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>As you can see, this form has more manageably-sized functions,
although they are still a little long. You can also see that the flow
of control is distributed through all three functions, which means
understanding the logic enough to modify or test it requires
understanding all three functions both individually and as a whole. To
follow the logic, we must trace the functions like a recursive descent
parser.</p>

<h3 id="refactoring-with-monads">Refactoring with Monads</h3>
<p>Without throwing exceptions and catching them at the top, it’s going
to be hard to do substantially better than the “tail-refactoring”
approach, unless we start to make use of the fact that we’re working
with <code class="language-plaintext highlighter-rouge">Try</code>, a data type that supports <code class="language-plaintext highlighter-rouge">flatMap</code>. More precisely, <code class="language-plaintext highlighter-rouge">Try</code>
has a monad instance - recall that monads let us model computational
effects that take place in sequence.</p>

<p>Let’s try to factor out smaller functions, each returning <code class="language-plaintext highlighter-rouge">Try</code>, and
then use a for-comprehension to specify the sequence of operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Try</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">parseDownloadType</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">DownloadType</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">o</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">DownloadType</span><span class="o">.</span><span class="py">fromString</span><span class="o">)</span>
    <span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">AssertionError</span><span class="o">(</span><span class="n">s</span><span class="s">"download type not provided for digital book $id"</span><span class="o">)))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">row</span> <span class="k">&lt;-</span> <span class="nv">DB</span><span class="o">.</span><span class="py">unsafeQueryUnique</span><span class="o">(</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">)</span>
    <span class="n">format</span> <span class="k">&lt;-</span> <span class="nv">Format</span><span class="o">.</span><span class="py">fromString</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">))</span>
    <span class="n">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="n">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="n">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="n">book</span> <span class="k">&lt;-</span> <span class="n">format</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
        <span class="nc">Success</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
        <span class="nf">parseDownloadType</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"download_type"</span><span class="o">),</span> <span class="n">id</span><span class="o">)</span>
          <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">book</span>
</code></pre></div></div>

<p>It’s less code, the functions are smaller, and the top-level function
dictates the entire flow of control. No function takes more than 2
arguments. These are testable, understandable functions. This version
really shows the power of using monads to sequence computation.</p>

<p>Now we are truly making use of the fact that <code class="language-plaintext highlighter-rouge">Try</code> has a monad instance
and not just another container class. We can simply describe the “happy
path” and trust <code class="language-plaintext highlighter-rouge">Try</code> to short-circuit computation if something erroneous
or unexpected occurs. In that case, <code class="language-plaintext highlighter-rouge">Try</code> captures the error and stops
computation there. The code does this without the need for explicit
branching logic.</p>

<h3 id="abstracting-effect-type">Abstracting effect type</h3>
<p>Now, let’s take this one step further - here’s where we achieve
buzzword compliance. Let’s abstract away from the effect, <code class="language-plaintext highlighter-rouge">Try</code>, and
instead make use of
<a href="https://typelevel.org/cats/api/cats/MonadError.html">MonadError</a>.
This lets us use a more diverse set of effect types, from
<a href="https://typelevel.org/cats-effect/datatypes/io.html">IO</a> to
<a href="https://monix.io/docs/3x/eval/task.html">Task</a>, so we can execute our
function in whatever asynchronous context we wish. This has the feel
of a tagless final strategy (although we aren’t worrying about
describing interpreters here).</p>

<p>Here we go:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.MonadError</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="nf">parseDownloadType</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">o</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span>
    <span class="k">implicit</span> <span class="n">me</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Throwable</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">DownloadType</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">me</span><span class="o">.</span><span class="py">fromOption</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AssertionError</span><span class="o">(</span><span class="n">s</span><span class="s">"download type not provided for digital book $id"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nv">me</span><span class="o">.</span><span class="py">fromTry</span><span class="o">(</span><span class="nv">DownloadType</span><span class="o">.</span><span class="py">fromString</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">findBookById</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">me</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Throwable</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">row</span> <span class="k">&lt;-</span> <span class="nv">DB</span><span class="o">.</span><span class="py">queryUnique</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">)</span>
    <span class="n">format</span> <span class="k">&lt;-</span> <span class="nv">me</span><span class="o">.</span><span class="py">fromTry</span><span class="o">(</span><span class="nv">Format</span><span class="o">.</span><span class="py">fromString</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">)))</span>
    <span class="n">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="n">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="n">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="n">book</span> <span class="k">&lt;-</span> <span class="n">format</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
        <span class="nv">me</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
        <span class="n">parseDownloadType</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"downloadType"</span><span class="o">),</span> <span class="n">id</span><span class="o">)</span>
          <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">book</span>
</code></pre></div></div>

<p>The code isn’t much more complicated than the version using <code class="language-plaintext highlighter-rouge">Try</code> but
it adds a lot of flexibility. In a synchronous context, we could still
use <code class="language-plaintext highlighter-rouge">Try</code>. In that case, however, the database call is executed
eagerly, which means the function isn’t referentially transparent. We
can make the function referentially transparent by using a monad such
as <code class="language-plaintext highlighter-rouge">IO</code> or <code class="language-plaintext highlighter-rouge">Task</code> as the effect type and delaying the evaluation of
the database call until “the end of the universe”.</p>

<p>In this example, pay attention to the use of
<a href="https://typelevel.github.io/cats/api/cats/syntax/ApplicativeErrorExtensionOps.html#fromOption[A](oa:Option[A],ifEmpty:=%3EE):F[A]">fromOption</a>
and
<a href="https://typelevel.github.io/cats/api/cats/ApplicativeError.html#fromTry[A](t:scala.util.Try[A])(implicitev:Throwable%3C:%3CE):F[A]">fromTry</a>,
which adapt <code class="language-plaintext highlighter-rouge">Option</code> and <code class="language-plaintext highlighter-rouge">Try</code> to <code class="language-plaintext highlighter-rouge">F</code>. If you are using existing APIs
that aren’t already generalized to <code class="language-plaintext highlighter-rouge">MonadError</code> these methods adapt
common error types, but require very little ceremony to use.</p>

<h3 id="refactoring-strategy">Refactoring strategy</h3>

<p>When faced with a similar refactoring problem, consider whether you
can break the problem into a sequence of independently executable
steps, each of which can be wrapped in a monad. If so, begin by
describing the control flow in your refactored function with a monadic
for-comprehension. Don’t define the individual functions that comprise
the steps of the for-comprehension until you have filled in the
<code class="language-plaintext highlighter-rouge">yield</code> at the end. You can use pseudocode or stubs to minimize the
amount of code churn at the beginning. This is a great time to shuffle
steps around and work out exactly what arguments are needed and when,
as well as where they are coming from.</p>

<p>Once the top level function looks plausible, begin implenting the
steps of the for-comprehension. You can replace the stubs or
pseudocode you wrote by refactoring code from your original function.
If the original code did not operate in a monadic context, recall that
you can convert a simple function <code class="language-plaintext highlighter-rouge">A =&gt; B</code> to <code class="language-plaintext highlighter-rouge">F[A] =&gt; F[B]</code> using
<a href="https://typelevel.org/cats/api/cats/Monad.html#lift[A,B](f:A=%3EB):F[A]=%3EF[B]">lift</a>
(thanks,
<a href="https://typelevel.org/cats/typeclasses/functor.html">Functor</a>!). This
makes converting your existing code even easier.</p>

<h3 id="conclusion">Conclusion</h3>
<p>In this post, we have seen how we can use monads as an aid in
refactoring code to improve both readability and testability. We have
also demonstrated that we can do this in many cases without needing to
specify the monad in use <em>a priori</em>. As a result, we gain the
flexibility to choose the appropriate monad for our application,
independently of the program logic.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/08/07/refactoring-monads.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/08/07/refactoring-monads.html</guid>
      </item>
    
      <item>
        <title>Testing in the wild</title>
        
          <dc:creator>etorreborre</dc:creator>
                
        <description><![CDATA[<p>Writing tests seems like a wonderful idea in theory but real systems can be a real pain to test. Today I want to show a few tips on how to
 use <a href="http://specs2.org">specs2</a> + <a href="http://www.scalacheck.org">ScalaCheck</a> to make some real-world testing somewhat bearable.</p>

<p>I am currently refactoring a big piece of code. Such refactoring is more like a small rewrite and some of our previous tests also have to be
 rewritten from scratch. I will try to introduce you to the problem first.</p>

<h3 id="creating-articles">Creating articles</h3>

<p>The system-du-jour is called “Panda” (we have animal names for many of our services in my team) and is tasked with the creation of articles
 on our legacy platform. An article is already a complicated beast. We have 3 levels of descriptions:</p>

<ul>
  <li>Model: the description for a pair of RunFast shoes, with the brand, the gender it applies to, the size chart it uses and so on</li>
  <li>Config: the description for a specific combination of colours - black RunFast -, images, material,… There can be several configs per model</li>
  <li>Simple: the description of a specific size - 37, 38, 39 -, price, stock, EAN (European Article Number),… There can be several simples
  per config</li>
</ul>

<p>This data can be created in our legacy catalog by calling a bunch of SOAP (yes you read that right) APIs and getting back, at each level,
  some identifiers for the model, the configs, the simples.</p>

<p>This in itself can already be quite complicated and the creation of an article could fail in many ways. But it gets a lot more complex
  considering that:</p>

<ol>
  <li>
    <p>we need the service to be idempotent and not try to recreate an existing model/config/simple twice if we receive the same event twice
(we are using Kafka as our events system)</p>
  </li>
  <li>
    <p>the articles sent by a merchant can be created incrementally, so some parts of the model/config/simple might have been already created
in a previous call</p>
  </li>
  <li>
    <p>we are not the only ones creating articles in the system! Indeed, our team creates articles coming from external merchants but there is
also an internal “wholesale” department buying their own articles and creating them in the catalog. In that case a merchant might add
a new config to an existing model or some simples to an existing config</p>
  </li>
  <li>
    <p>any step in the process could break and we have no support for transactions making sure that everything is created at once</p>
  </li>
</ol>

<p>So many things which can go wrong, how would you go about testing it?</p>

<h3 id="combinations-the-key-to-testing">Combinations, the key to testing</h3>

<p>After I started rewriting the tests I realized that our current approach was barely scratching the surface of all the possible combinations.
 In a similar case your first thought should be “ScalaCheck”! But this time I am going to use ScalaCheck with a twist. Instead of only modelling
 input data (model/config/simples) I am also modelling the system state:</p>

<ul>
  <li>we have a “mapping table” to store merchant articles that have already been created. In which states can it be?</li>
  <li>the legacy catalog can also be in many different states: does a particular model/config/simple already exist or not?</li>
</ul>

<p>If we translate this into a specs2 + ScalaCheck specification, we get a property like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArticleServiceSpec</span> <span class="k">extends</span> <span class="nc">Specification</span> <span class="k">with</span> <span class="nc">ScalaCheck</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">is</span> <span class="k">=</span> <span class="n">s2</span><span class="s">"""

  &lt;insert long description of the problem and what we want to test&gt;

  run tests for model creation $modelCreation

"""</span>

  <span class="k">def</span> <span class="nf">modelCreation</span> <span class="k">=</span> <span class="n">prop</span> <span class="o">{</span> <span class="o">(</span><span class="n">reviewed</span><span class="k">:</span> <span class="kt">Article</span><span class="o">,</span> <span class="n">catalog</span><span class="k">:</span> <span class="kt">TestCatalog</span><span class="o">,</span> <span class="n">mappings</span><span class="k">:</span> <span class="kt">TestMappings</span><span class="o">)</span> <span class="k">=&gt;</span>

    <span class="n">ok</span> <span class="c1">// for now
</span>

  <span class="o">}.</span><span class="py">setGen1</span><span class="o">(</span><span class="n">genArticleOneConfig</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We are creating a ScalaCheck property, with a specs2 method <code class="language-plaintext highlighter-rouge">prop</code> which gives us some additional power over row ScalaCheck properties.
 One thing we do here is to restrict the kind of generated <code class="language-plaintext highlighter-rouge">Article</code> to articles containing only one new configuration because we want to
  focus first on all the possible cases of model creation. So we pass a specific generator to the property, just for the first argument
  with <code class="language-plaintext highlighter-rouge">setGen1</code>.</p>

<p>Then, as you can see above, we return <code class="language-plaintext highlighter-rouge">ok</code> which is a specs2 result. This is because <code class="language-plaintext highlighter-rouge">prop</code> allows us to return anything that specs2 recognizes
  as a <code class="language-plaintext highlighter-rouge">Result</code> (with the <code class="language-plaintext highlighter-rouge">org.specs2.execute.AsResult</code> typeclass) and then we are not limited to booleans in our ScalaCheck properties but
  we can use specs2 matchers as well (we are going use this in the next step).</p>

<p>Now, for testing we need to do the following:</p>

<ol>
  <li>capture the state before the article creation</li>
  <li>execute the article creation</li>
  <li>capture the state after the article creation</li>
  <li>compare the resulting state to expected values</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="nv">before</span> <span class="k">=</span> <span class="nf">createBeforeState</span><span class="o">(</span><span class="n">reviewed</span><span class="o">,</span> <span class="n">catalog</span><span class="o">,</span> <span class="n">mappings</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nf">run</span><span class="o">(</span><span class="nf">createService</span><span class="o">(</span><span class="n">catalog</span><span class="o">,</span> <span class="n">mappings</span><span class="o">).</span><span class="py">createArticles</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">reviewed</span><span class="o">))</span>
  <span class="k">val</span> <span class="nv">after</span>  <span class="k">=</span> <span class="nf">createAfterState</span><span class="o">(</span><span class="n">reviewed</span><span class="o">,</span> <span class="n">catalog</span><span class="o">,</span> <span class="n">mappings</span><span class="o">,</span> <span class="n">result</span><span class="o">)</span>
</code></pre></div></div>

<p>What are <code class="language-plaintext highlighter-rouge">BeforeState</code> and <code class="language-plaintext highlighter-rouge">AfterState</code>? They are custom case classes modelling the variables we are interested in:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">case</span> <span class="k">class</span> <span class="nc">BeforeState</span><span class="o">(</span>
   <span class="n">modelIdProvided</span><span class="k">:</span>       <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">modelNeedsToBeCreated</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">modelExistsInCatalog</span><span class="k">:</span>  <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">mappingExists</span><span class="k">:</span>         <span class="kt">Boolean</span><span class="o">)</span>

 <span class="k">case</span> <span class="k">class</span> <span class="nc">AfterState</span><span class="o">(</span>
   <span class="n">modelExistsInCatalog</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">mappingExists</span><span class="k">:</span>        <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">exception</span><span class="k">:</span>            <span class="kt">Option</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">])</span>
</code></pre></div></div>

<p>The first 2 variables of <code class="language-plaintext highlighter-rouge">BeforeState</code> are a bit curious. The first one gives us a <code class="language-plaintext highlighter-rouge">ModelId</code> if upstream systems know that a model already
  exist. Then how could <code class="language-plaintext highlighter-rouge">modelNeedsToBeCreated</code> be true? Well, the events we receive don’t rule out this possibility. This is the
  current state of our domain data and arguably we should model things differently and reject malformed events right away. This is where the
  saying <a href="https://www.obeythetestinggoat.com/book/chapter_purist_unit_tests.html#_listen_to_your_tests_ugly_tests_signal_a_need_to_refactor">“Listen to your tests”</a> comes in :-).</p>

<p>If we count the number of combinations we end up with 16 possibilities for our “before state” and 8 possible outcomes. How can we represent
   all those combinations in our test?</p>

<h3 id="datatables">DataTables</h3>

<p>Specs2 offers to possibility to create tables of data directly inside the code for better readability of actual and expected values
 when you have lots of different possible combinations. Here is what we can do here</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="nv">results</span> <span class="k">=</span>
  <span class="s">"#"</span> <span class="o">|</span> <span class="s">"model-id"</span> <span class="o">|</span> <span class="s">"create"</span> <span class="o">|</span> <span class="s">"in catalog"</span> <span class="o">|</span> <span class="s">"mapping"</span> <span class="o">||</span> <span class="s">"in catalog"</span>  <span class="o">|</span> <span class="s">"mapping"</span> <span class="o">|</span> <span class="s">"exception"</span> <span class="o">|</span> <span class="s">"comment"</span> <span class="o">|</span>
  <span class="mi">1</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"no model is created, because it can be found in the catalog, creation data is ignored"</span> <span class="o">|</span>
  <span class="mi">2</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"we just updated the mapping"</span> <span class="o">|</span>
  <span class="mi">3</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"the config creation must fail, no existing model"</span> <span class="o">|</span>
  <span class="mi">4</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"the given model-id is ignored (a warning is logged)"</span> <span class="o">|</span>
  <span class="mi">5</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"no model is created, because it can be found in the catalog"</span> <span class="o">|</span>
  <span class="mi">6</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"the mappings are not updated because we did not create the model"</span> <span class="o">|</span>
  <span class="mi">7</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"no corresponding model in the catalog"</span> <span class="o">|</span>
  <span class="mi">8</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"no corresponding model in the catalog"</span> <span class="o">|</span>
  <span class="mi">9</span>   <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"we use the mapping table to retrieve the model id and the catalog for the model"</span> <span class="o">|</span>
  <span class="mi">10</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"in this case the model already exists in the catalag but we have no way to know"</span> <span class="o">|</span>
  <span class="mi">11</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"the mapping exists but not the data in the catalog"</span> <span class="o">|</span>
  <span class="mi">12</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"regular model + config creation case"</span> <span class="o">|</span>
  <span class="mi">13</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"there is no model id and no creation data"</span> <span class="o">|</span>
  <span class="mi">14</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"the model exists in the catalog but we have no way to retrieve it"</span> <span class="o">|</span>
  <span class="mi">15</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"model id found in the mapping but not in the catalog"</span> <span class="o">|</span>
  <span class="mi">16</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"not enough data to create the model nor the mapping"</span>

 <span class="nf">checkState</span><span class="o">(</span><span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">,</span> <span class="nf">parseTable</span><span class="o">(</span><span class="n">results</span><span class="o">))</span>
</code></pre></div></div>
<p>This looks like a strange piece of code but this is actually all valid Scala syntax! <code class="language-plaintext highlighter-rouge">results</code> is a specs2 <code class="language-plaintext highlighter-rouge">DataTable</code> created out of:</p>

<ul>
  <li>a header where column names are separated with <code class="language-plaintext highlighter-rouge">|</code></li>
  <li>rows that are also separated with <code class="language-plaintext highlighter-rouge">|</code></li>
  <li>cells on each row, separated with <code class="language-plaintext highlighter-rouge">!</code></li>
</ul>

<p>We can also use <code class="language-plaintext highlighter-rouge">||</code> and <code class="language-plaintext highlighter-rouge">!!</code> as separators and we use this possibility here to visually distinguish input columns from expected results
  columns.</p>

<h3 id="running-the-tests">Running the tests</h3>

<p>The table above is like a big “truth table” for all our input conditions. Running a test consists in:</p>

<ol>
  <li>using the ‘before state’ to locate one of the row</li>
  <li>getting the expected ‘after state’ from the expected columns</li>
  <li>comparing the actual ‘after state’ with the expected one</li>
</ol>

<p>The funny thing is that before executing the test I did not exactly know what the code would actually do! So I just let the test guide me.
I put some expected values, run the test and in case of a failure, inspect the input values, think hard about why the code is not behaving the
way I think it should.</p>

<p>One question comes to mind: since this is a ScalaCheck property, how can we be sure we hit all the cases in the table? The first thing we
can do is to massively increase the number of tests that are going to be executed for this property, like 10000. With specs2 you have many
ways to do this. You can set the <code class="language-plaintext highlighter-rouge">minTestsOk</code> ScalaCheck property directly in the code:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">modelCreation</span> <span class="k">=</span> <span class="n">prop</span> <span class="o">{</span> <span class="o">(</span><span class="n">reviewed</span><span class="k">:</span> <span class="kt">Article</span><span class="o">,</span> <span class="n">catalog</span><span class="k">:</span> <span class="kt">TestCatalog</span><span class="o">,</span> <span class="n">mappings</span><span class="k">:</span> <span class="kt">TestMappings</span><span class="o">)</span> <span class="k">=&gt;</span>
 <span class="o">...</span>
<span class="o">}.</span><span class="py">setGen1</span><span class="o">(</span><span class="n">genArticleOneConfig</span><span class="o">).</span><span class="py">set</span><span class="o">(</span><span class="n">minTestsOk</span> <span class="k">=</span> <span class="mi">10000</span><span class="o">)</span>
</code></pre></div></div>

<p>But you can also do it from sbt:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sbt&gt; testOnly *ArticleServiceSpec -- scalacheck.mintestsok 10000
</code></pre></div></div>

<p>This is quite cool because this means that you don’t have to recompile the code if you just want to run a ScalaCheck property with more tests.</p>

<h3 id="checking-the-results">Checking the results</h3>

<p>As I wrote, when a specific combination would fail I had to inspect the inputs/outputs and think hard, maybe my expectations are wrong and
I needed to change the expected values? To this end I added a “line number” column to the table and reported it in the result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [error]  &gt; On line 6
 [error]
 [error]  Before
 [error]    model id set:             true
 [error]    model creation data set:  false
 [error]    model exists in catalog : true
 [error]    model id mapping exists:  false
 [error]
 [error]  After
 [error]    model exists in catalog:  true
 [error]      expected:               true
 [error]
 [error]    model id mapping exists:  false
 [error]      expected:               false
 [error]
 [error]    exception thrown:         None
 [error]      expected:               Some
</code></pre></div></div>

<p>This reporting is all done in the <code class="language-plaintext highlighter-rouge">checkState</code> method which is:</p>

<ul>
  <li>doing the comparison between actual and expected values</li>
  <li>displaying the before / after states</li>
  <li>displaying the difference between expected and actual values</li>
</ul>

<p>Actually I even enhanced the display of actual/expected values by coloring them in green or red in the console, using one of specs2 helper
 classes <code class="language-plaintext highlighter-rouge">org.specs2.text.AnsiColors</code>:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.specs2.text.AnsiColors</span>

<span class="k">def</span> <span class="nf">withColor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">actual</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">expected</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">condition</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="c1">// color the expected value in green or red, depending on the test success
</span>  <span class="nf">color</span><span class="o">(</span><span class="nv">expected</span><span class="o">.</span><span class="py">toString</span><span class="o">,</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">condition</span><span class="o">(</span><span class="n">actual</span><span class="o">,</span> <span class="n">expected</span><span class="o">))</span> <span class="n">green</span> <span class="k">else</span> <span class="n">red</span><span class="o">)</span>

<span class="nf">withColor</span><span class="o">(</span><span class="nv">after</span><span class="o">.</span><span class="py">modelExistsInCatalog</span><span class="o">,</span> <span class="nv">expected</span><span class="o">.</span><span class="py">modelExistsInCatalog</span><span class="o">)</span>
</code></pre></div></div>

<p>Both the line numbering and the coloring really helps in fixing issues fast!</p>

<h3 id="replaying-tests">Replaying tests</h3>

<p>A vexing issue with property-based testing is that being random, it will generate random failures every time you re-run a property. So you
can’t re-run a property with the exact same input data. But that was before ScalaCheck 1.14! Now we can pass the seed that is used by the random
 generator to faithfully re-run a failing test. Indeed when a property fails, specs2 will display the current seed value:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[error]  The seed is 1tRQ5-jdfEABEXz1y62Cs0C4vNJQKyXps9eWvbjJPSI=
</code></pre></div></div>

<p>And you can pass this value on the command line to re-run with exactly the failing input data:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sbt&gt; testOnly *ArticleServiceSpec -- scalacheck.seed 1tRQ5-jdfEABEXz1y62Cs0C4vNJQKyXps9eWvbjJPSI=
</code></pre></div></div>

<p>This is super-convenient for debugging!</p>

<h3 id="comments">Comments</h3>

<p>Finally when a given row in the table passes, there is a <code class="language-plaintext highlighter-rouge">comment</code> column to register the reason for this specific outcomes so that future
generations have a sense of <em>why</em> the code is behaving that way. In that sense this whole approach is a bit like having “golden tests” which
are capturing the behaviour of the system as a series of examples</p>

<h3 id="conclusion">Conclusion</h3>

<p>This post shows how we can leverage features from both specs2 and ScalaCheck to make our tests more exhaustive, more readable, more debuggable.
The reality is still more complicated than this:</p>

<ul>
  <li>
    <p>the total number of combinations would make our table very large. So there are actually several tables (one for model creation, one for
 config creation,…) where we assume that some variables are fixed while others can move</p>
  </li>
  <li>
    <p>specs2 datatables are currently limited to 10 columns. The <code class="language-plaintext highlighter-rouge">DataTable</code> code is actually code generated and the latest version only has 10
 columns. One easy first step would be to generate more code (and go up to the magic 22 number for example) or to re-implement this functionality
 as some kind of HList</p>
  </li>
  <li>
    <p>the input state is not trivial to generate because the objects are dependent. The <code class="language-plaintext highlighter-rouge">ModelId</code> of a generated model must be exactly the same
 as the one used in the <code class="language-plaintext highlighter-rouge">Mappings</code> component to register that a model has already been created. So in reality the 2 generators for <code class="language-plaintext highlighter-rouge">Article</code> and
 <code class="language-plaintext highlighter-rouge">Mappings</code> are not totally independent</p>
  </li>
  <li>
    <p>the <code class="language-plaintext highlighter-rouge">Arbitrary</code> instance for <code class="language-plaintext highlighter-rouge">Article</code> can give us articles with 5 <code class="language-plaintext highlighter-rouge">Configs</code> and 10 <code class="language-plaintext highlighter-rouge">Simples</code> but for this test, one <code class="language-plaintext highlighter-rouge">Config</code> and one <code class="language-plaintext highlighter-rouge">Simple</code>
  are enough. Unfortunately we miss a nice language to express those generation condition and easily tweak the default <code class="language-plaintext highlighter-rouge">Arbitrary[Article]</code> (I
  will explore a solution to this problem during the next Haskell eXchange)</p>
  </li>
  <li>
    <p>why are we even using ScalaCheck to generate all the cases since we already statically know all the possible 16 input conditions? We could
  invert this relation and have a ScalaCheck property generated for each row of the datatable with some arbitrary data for the model (and some
fixed data given by the current row). This would not necessarily lead to easier code to implement.</p>
  </li>
</ul>

<p>Anyway despite those remaining questions and issues I hope this post gives you some new ideas on how to be more effective when writing tests
  with specs2 and ScalaCheck, please comment on your own experiments!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/07/12/testing-in-the-wild.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/07/12/testing-in-the-wild.html</guid>
      </item>
    
      <item>
        <title>Optimizing Tagless Final – Part 2 – Monadic programs</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p>In our previous post on optimizing tagless final programs we learned how we could use the <a href="https://github.com/LukaJCB/sphynx">sphynx library</a> to derive some optimization schemes for your tagless final code. In case you missed it and want to read up on it, you can find it <a href="https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html">right here</a> or you can watch my presentation on the topic <a href="https://www.youtube.com/watch?v=E9iRYNuTIYA">here</a>, but you should be able to follow this blog post without going through it all in detail.</p>

<h2 id="optimizing-monadic-programs">Optimizing monadic programs</h2>

<p>One of the questions I’ve been getting a lot, is if we can also do something like that for the monadic parts of our program.
The answer is yes, we can, however it will have to be quite a bit different.</p>

<p>I don’t think the differences are quite obvious, so we’ll go through them step by step.
With applicative programs, we’re optimizing a bunch of independent instructions.
That means, we can look at all of them and extract information out of them statically (i.e. without running the interpreter).
They can be seen as a sequence of instructions that we can fold down to a single monoid <code class="language-plaintext highlighter-rouge">M</code>, that holds the information that we need to optimize.
We then used that monoid to recreate a new interpreter that can take this extra information into account.</p>

<p>With monadic programs, we do not have such luxury.
We can only step through each of our instructions one at a time, because every instruction depends on the results of the prior one.
This means that we cannot extract any information beyond the very first instruction we have.
That might seem like a deal breaker, but there’s still a few things we can do.
We could, for example, build up our monoid <code class="language-plaintext highlighter-rouge">M</code> dynamically, after each monadic instruction.
Then, before invoking the next computation in the monadic sequence, we could take that monoid and recreate that next computation with that extra information.</p>

<p>Now, that might sound super abstract to you, and I wouldn’t disagree, so let’s look at a quick example.
Say, we’re using the <code class="language-plaintext highlighter-rouge">KVStore</code> algebra again from last time:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We could optimize programs with this algebra by caching the results of <code class="language-plaintext highlighter-rouge">get</code> and we could use that same cache to also cache key-value pairs we inserted using <code class="language-plaintext highlighter-rouge">put</code>.</p>

<p>So given this example program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">)</span>
  <span class="n">dog</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="n">cat</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="nv">dog</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="s">"dog"</span><span class="o">))</span>
  <span class="n">cat2</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">List</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">cat2</span><span class="o">).</span><span class="py">flatten</span>
</code></pre></div></div>

<p>The naively interpreted program would be doing the following things:</p>
<ol>
  <li>put the value “cat” into the store with the <code class="language-plaintext highlighter-rouge">key</code> passed by the user</li>
  <li>get the value “cat” back out of the store</li>
  <li>access the key-value store and maybe return a value associated with the key “cat”</li>
  <li>access the store again with the same “cat” key.</li>
</ol>

<p>Now if accessing the key-value store means going through a network layer this is of course highly inefficient.
Ideally our fully optimized program should do the following things:</p>
<ol>
  <li>put the value “cat” into the store with the <code class="language-plaintext highlighter-rouge">key</code> parameter passed by the user and cache it.</li>
  <li>access the cache to get the value “cat” associated with <code class="language-plaintext highlighter-rouge">key</code></li>
  <li>access the key-value-store and maybe return a value associated with the key “cat”</li>
  <li>access the cache to return the previous result for the “cat” key.</li>
</ol>

<p>Cool, next, let’s look at how we might get there.
First the type of our cache, which for our case can just be a <code class="language-plaintext highlighter-rouge">Map[String, String]</code>, but generically could just be any monoid.</p>

<p>Now what we want to do is transform any interpreter for <code class="language-plaintext highlighter-rouge">KVStore</code> programs into interpreters that</p>
<ol>
  <li>Look in the cache before performing a <code class="language-plaintext highlighter-rouge">get</code> action with the actual interpreter</li>
  <li>Write to the cache after performing either a <code class="language-plaintext highlighter-rouge">get</code> or <code class="language-plaintext highlighter-rouge">put</code> action.</li>
</ol>

<p>So how can we get there? It seems like we want to thread a bunch of state through our program, that we want to both read and write to.
If you’re familiar with FP folklore you might recognize that that description fits almost exactly to the <code class="language-plaintext highlighter-rouge">State</code> monad.
Furthermore, because we know that our <code class="language-plaintext highlighter-rouge">F[_]</code> is a monad, that means the <code class="language-plaintext highlighter-rouge">StateT</code> monad transformer over <code class="language-plaintext highlighter-rouge">F</code> will also be a monad.</p>

<p>Okay with that said, let’s try to develop function that turns any interpreter <code class="language-plaintext highlighter-rouge">KVStore[F]</code> into an interpreter into <code class="language-plaintext highlighter-rouge">StateT[F, M, A]</code>, so an <code class="language-plaintext highlighter-rouge">KVStore[StateT[F, M, ?]]</code>, where <code class="language-plaintext highlighter-rouge">M</code> is the monoid we use to accumulate our extracted information.
We’ll start with the <code class="language-plaintext highlighter-rouge">put</code> operation.
For <code class="language-plaintext highlighter-rouge">put</code>, we’ll want to call the interpreter to perform the action and then modify the state by adding the retrieved value into our cache.
To make the code a bit more legible we’ll also define a few type aliases.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Cache</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">A</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">transform</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">StateT</span><span class="o">.</span><span class="py">liftF</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">](</span><span class="nv">interp</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">*&gt;</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>

  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So far, so good, now let’s have a look at what to do with the <code class="language-plaintext highlighter-rouge">get</code> function.
It’s a bit more complex, because we want to read from the cache, as well as write to it if the cache didn’t include our key.
What we have to do is, get our current state, then check if the key is included, if so, just return it, otherwise call the interpreter to perform the <code class="language-plaintext highlighter-rouge">get</code> action and then write that into the cache.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">cache</span> <span class="k">&lt;-</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">get</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">]</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="nv">cache</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
              <span class="k">case</span> <span class="n">s</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">s</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">liftF</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nv">interp</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
                             <span class="o">.</span><span class="py">flatTap</span><span class="o">(</span><span class="nf">updateCache</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
            <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">updateCache</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">ov</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">ov</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">().</span><span class="py">pure</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is quite something, so let’s try to walk through it step by step.
First we get the cache using <code class="language-plaintext highlighter-rouge">StateT.get</code>, so far so good.
Now, we check if the key is in the cache using <code class="language-plaintext highlighter-rouge">cache.get(key)</code>.
The result of that is an <code class="language-plaintext highlighter-rouge">Option[String]</code>, which we can pattern match to see if it did include the key.
If it did, then we can just return that <code class="language-plaintext highlighter-rouge">Option[String]</code> by lifting it into <code class="language-plaintext highlighter-rouge">CachedAction</code> using <code class="language-plaintext highlighter-rouge">pure</code>.
If it wasn’t in the cache, things are a bit more tricky.
First, we lift the interpreter action into <code class="language-plaintext highlighter-rouge">CachedAction</code> using <code class="language-plaintext highlighter-rouge">StateT.liftF</code>, that gives us a <code class="language-plaintext highlighter-rouge">CachedAction[Option[String]]</code>, which is already the return type we need and we could return it right there, but we still need to update the cache.
Because we already have the return type we need, we can use the <code class="language-plaintext highlighter-rouge">flatTap</code> combinator.
Then inside the <code class="language-plaintext highlighter-rouge">updateCache</code> function, we take the result of our interpreter, which is again an <code class="language-plaintext highlighter-rouge">Option[String]</code>, and update the cache if the value is present.
If it’s empty, we don’t want to do anything at all, so we just lift unit into <code class="language-plaintext highlighter-rouge">CachedAction</code>.</p>

<p>In case you’re wondering <code class="language-plaintext highlighter-rouge">flatTap</code> works just like <code class="language-plaintext highlighter-rouge">flatMap</code>, but will then <code class="language-plaintext highlighter-rouge">map</code> the result type back to the original one, making it a bit similar to a monadic version of the left shark (<code class="language-plaintext highlighter-rouge">&lt;*</code>) operator, making it very useful for these “fire-and-forget” operations.
It’s defined like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">flatTap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">fa</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div></div>

<p>And with that we now have a working function to turn any interpreter into an optimized interpreter.
We can also generalize this fairly easily into a function that will do all of the wiring for us.
To do so, we’ll generalize away from <code class="language-plaintext highlighter-rouge">KVStore</code> and <code class="language-plaintext highlighter-rouge">Cache</code> and instead use generic <code class="language-plaintext highlighter-rouge">Alg[_[_]]</code> and <code class="language-plaintext highlighter-rouge">M</code> parameters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">M:</span> <span class="kt">Monoid</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">MonadProgram</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">withState</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
    <span class="nf">program</span><span class="o">(</span><span class="nf">withState</span><span class="o">(</span><span class="n">interpreter</span><span class="o">)).</span><span class="py">runEmptyA</span>
</code></pre></div></div>

<p>Just like last time, we have to use a <code class="language-plaintext highlighter-rouge">MonadProgram</code> wrapper around <code class="language-plaintext highlighter-rouge">Alg[F] =&gt; F[A]</code>, because Scala lacks rank-N types which would allow us to define values that work over ALL type constructors <code class="language-plaintext highlighter-rouge">F[_]: Monad</code> (Fortunately however, this will very probably soon be fixed in dotty, PR <a href="https://github.com/lampepfl/dotty/pull/4672">here</a>).</p>

<p>Now let’s see if we can actually use it, by checking it with a test interpreter that will print whenever we retrieve or insert values into the <code class="language-plaintext highlighter-rouge">KVStore</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimize</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">IO</span>, <span class="kt">Cache</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nf">program</span><span class="o">(</span><span class="s">"mouse"</span><span class="o">))(</span><span class="n">transform</span><span class="o">)</span>
  <span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">printInterpreter</span><span class="o">)</span>
  <span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>

<span class="c1">// Put key: mouse, value: cat
// Get key: cat
</span></code></pre></div></div>

<p>It works and does exactly what we want! 
Nice! We could end this blog post right here, but there’s still a couple of things I’d like to slightly alter.</p>

<h3 id="refining-the-api">Refining the API</h3>

<p>As you were able to tell the implementation of our transformation from the standard interpreter to the optimized interpreter is already quite complex and that is for a very very simple algebra that doesn’t do a lot.
Even then, I initially wrote an implementation that packs everything in a single <code class="language-plaintext highlighter-rouge">StateT</code> constructor to avoid the overhead of multiple calls to <code class="language-plaintext highlighter-rouge">flatMap</code>, but considered the version I showed here more easily understandable.
For more involved algebras and more complex programs, all of this will become a lot more difficult to manage.
In our last blog post we were able to clearly separate the extraction of our information from the rebuilding of our interpreter with that information.
Let’s have a look at if we can do the same thing here.</p>

<p>First we’ll want to define an extraction method.
For applicative programs we used <code class="language-plaintext highlighter-rouge">Const[M, ?]</code>, however that cannot work here, as <code class="language-plaintext highlighter-rouge">Const</code> doesn’t have a <code class="language-plaintext highlighter-rouge">Monad</code> instance and also, because for extraction with monadic programs, we need to actually take the result of the computation into account. 
That means, that for every operation in our algebra, we want a way to turn it into our monoid <code class="language-plaintext highlighter-rouge">M</code>.
With that said, it seems we want a function <code class="language-plaintext highlighter-rouge">A =&gt; M</code>, where <code class="language-plaintext highlighter-rouge">A</code> is the result type of the operations in our algebra.
So what we can do here is define an algebra for <code class="language-plaintext highlighter-rouge">? =&gt; M</code>, in types an <code class="language-plaintext highlighter-rouge">Alg[? =&gt; M]</code>.</p>

<p>Let’s try to do define such an interpreter for our <code class="language-plaintext highlighter-rouge">KVStore</code> along with <code class="language-plaintext highlighter-rouge">Cache</code>/<code class="language-plaintext highlighter-rouge">Map[String, String</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">Cache</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">Cache</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Cache</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nv">Map</span><span class="o">.</span><span class="py">empty</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Cache</span> <span class="k">=</span>
    <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Just as before we want to extract the cache piece by piece with every monadic step.
Whenever we get an <code class="language-plaintext highlighter-rouge">Option[String]</code> after using <code class="language-plaintext highlighter-rouge">get</code>, we can then turn that into a <code class="language-plaintext highlighter-rouge">Cache</code> if it’s non-empty.
The same goes for <code class="language-plaintext highlighter-rouge">put</code>, where we’ll create a Map using the key-value pair.
We now have a way to turn the results of our algebra operations into our information <code class="language-plaintext highlighter-rouge">M</code>, so far so good!</p>

<p>Next, we’ll need a way to rebuild our operations using that extracted information.
For that, let’s consider what that actually means.
For applicative programs this meant a function that given a state <code class="language-plaintext highlighter-rouge">M</code> and an interpreter <code class="language-plaintext highlighter-rouge">Alg[F]</code>, gave a  reconstructed interpreter inside the <code class="language-plaintext highlighter-rouge">F</code> context <code class="language-plaintext highlighter-rouge">F[Alg[F]]</code>.
So a function <code class="language-plaintext highlighter-rouge">(M, Alg[F]) =&gt; F[Alg[F]]</code>.</p>

<p>For monadic programs, there’s no need to precompute any values, as we’re dealing with fully sequential computations that can potentially update the state after every evaluation.
So we’re left with a function <code class="language-plaintext highlighter-rouge">(M, Alg[F]) =&gt; Alg[F]</code>.
Let’s try building that for <code class="language-plaintext highlighter-rouge">KVStore</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">m</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">o</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nv">interp</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">m</span> <span class="k">=&gt;</span> <span class="nv">interp</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Easy enough!
For <code class="language-plaintext highlighter-rouge">get</code> we look inside our cache and use the value if it’s there, otherwise we call the original interpreter to do its job.
For <code class="language-plaintext highlighter-rouge">put</code>, there’s nothing to gain from having access to our extracted information and the only thing we can do is call the interpreter and let it do what needs to be done.</p>

<p>Now we have a way to extract information and then also use that information, next up is finding a way to wire these two things together to get back to the behaviour we got using <code class="language-plaintext highlighter-rouge">StateT</code>.</p>

<p>And as a matter of fact, we’ll wire them back together using exactly <code class="language-plaintext highlighter-rouge">StateT</code>, as it’s monad instance does do exactly what we want.</p>

<p>Using our two functions <code class="language-plaintext highlighter-rouge">extract</code> and <code class="language-plaintext highlighter-rouge">rebuild</code> it’s fairly easy to get back to <code class="language-plaintext highlighter-rouge">KVStore[StateT[F, Cache, ?]]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">transform</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">cache</span> <span class="k">=&gt;</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="n">interp</span><span class="o">).</span><span class="py">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> 
      <span class="o">(</span><span class="n">cache</span> <span class="o">|+|</span><span class="err"> </span><span class="nv">extract</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>

  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">cache</span> <span class="k">=&gt;</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="n">interp</span><span class="o">).</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> 
      <span class="o">(</span><span class="n">cache</span> <span class="o">|+|</span><span class="err"> </span><span class="nv">extract</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is fairly straightforward, we use rebuild with our cache and the interpreter to get a new interpreter that will run the operation.
Then, we use the result, which is just an <code class="language-plaintext highlighter-rouge">F[Unit]</code>/<code class="language-plaintext highlighter-rouge">F[Option[String]]</code> respectively, and map it 
  using the extractor to get the newest <code class="language-plaintext highlighter-rouge">Cache</code> and using its <code class="language-plaintext highlighter-rouge">Monoid</code> instance to update the state and then we tuple it with the result, giving us an <code class="language-plaintext highlighter-rouge">F[(Cache, Unit)]</code> or <code class="language-plaintext highlighter-rouge">F[(Cache, Option[String])]</code>, which is exactly what the <code class="language-plaintext highlighter-rouge">StateT</code> constructor needs.</p>

<p>This is great, but can we generalize this to any algebra and any monoid?</p>

<p>The answer is yes, but it’s not exactly easy.
First let’s look at the actual problem.
We have two interpreters <code class="language-plaintext highlighter-rouge">extract</code> and <code class="language-plaintext highlighter-rouge">rebuild</code>, but we have no way to combine them, because <code class="language-plaintext highlighter-rouge">Alg</code>, is completely unconstrained and that means we can’t call any functions on a generic <code class="language-plaintext highlighter-rouge">Alg[F]</code> at all.
So, okay, we need to constrain our <code class="language-plaintext highlighter-rouge">Alg</code> parameter to be able to combine values of <code class="language-plaintext highlighter-rouge">Alg[F]</code> with values of <code class="language-plaintext highlighter-rouge">Alg[G]</code> in some way, but what kind of type class could that be?
Are there even type classes that operate on the kind of <code class="language-plaintext highlighter-rouge">Alg</code>?</p>

<h3 id="higher-kinded-things">Higher kinded things</h3>

<p>There are, they’re just hidden away in a small library called <code class="language-plaintext highlighter-rouge">Mainecoon</code>.
That library gives us higher kinded versions of things like functors and contravariant functors, called <code class="language-plaintext highlighter-rouge">FunctorK</code> and <code class="language-plaintext highlighter-rouge">ContravariantK</code> respectively.</p>

<p>Let’s have a quick look at <code class="language-plaintext highlighter-rouge">FunctorK</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span>
<span class="k">trait</span> <span class="nc">FunctorK</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">mapK</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Instead of mapping over type constructors <code class="language-plaintext highlighter-rouge">F[_]</code>, we map over algebras <code class="language-plaintext highlighter-rouge">A[_[_]]</code> and insteading of using functions <code class="language-plaintext highlighter-rouge">A =&gt; B</code>, we use natural transformations <code class="language-plaintext highlighter-rouge">F ~&gt; G</code>.
This is nice, but doesn’t really get us that far.</p>

<p>What we really need is the equivalent of the <code class="language-plaintext highlighter-rouge">Applicative</code>/<code class="language-plaintext highlighter-rouge">Apply</code> <code class="language-plaintext highlighter-rouge">map2</code> operation.
<code class="language-plaintext highlighter-rouge">map2</code> looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<p>And a higher kinded version would look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">map2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="n">H</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span>
</code></pre></div></div>

<p>If you haven’t guessed yet <code class="language-plaintext highlighter-rouge">Tuple2K</code> is just a higher kinded version of <code class="language-plaintext highlighter-rouge">Tuple2</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>Unfortunately <code class="language-plaintext highlighter-rouge">Mainecoon</code> doesn’t have an <code class="language-plaintext highlighter-rouge">ApplyK</code> type class that gives us this <code class="language-plaintext highlighter-rouge">map2K</code> operation, but it gives the next best thing! 
A higher-kinded <code class="language-plaintext highlighter-rouge">Semigroupal</code>, which when combined with the higher kinded <code class="language-plaintext highlighter-rouge">Functor</code> gives us that higher kinded <code class="language-plaintext highlighter-rouge">Apply</code> type class.
It’s called <code class="language-plaintext highlighter-rouge">CartesianK</code> (because cats <code class="language-plaintext highlighter-rouge">Semigroupal</code> used to be called <code class="language-plaintext highlighter-rouge">Cartesian</code>, but is renamed to <code class="language-plaintext highlighter-rouge">SemigroupalK</code> in the next version) and looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> 
<span class="k">trait</span> <span class="nc">CartesianK</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">productK</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now just like you can define <code class="language-plaintext highlighter-rouge">map2</code> using <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">product</code> we can do the same for <code class="language-plaintext highlighter-rouge">map2K</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">map2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="n">H</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">productK</span><span class="o">(</span><span class="n">af</span><span class="o">,</span> <span class="n">ag</span><span class="o">).</span><span class="py">mapK</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="putting-it-all-together">Putting it all together</h3>

<p>Okay, after that quick detour, let’s have a look at how can make use of these type classes.</p>

<p>If we look at what we have and how we’d like to use the <code class="language-plaintext highlighter-rouge">map2K</code> function, we can infer the rest that we need quite easily.</p>

<p>We have an <code class="language-plaintext highlighter-rouge">Alg[F]</code> and a <code class="language-plaintext highlighter-rouge">Alg[? =&gt; M]</code>, and we want an <code class="language-plaintext highlighter-rouge">Alg[StateT[F, M, ?]]</code>, so given those two as the inputs to <code class="language-plaintext highlighter-rouge">map2K</code>, all that seems to be missing is the natural transformation <code class="language-plaintext highlighter-rouge">Tuple2K[F, ? =&gt; M, ?] ~&gt; StateT[F, M, ?]</code>.
Nice! As so often, the types guide us and show us the way.</p>

<p>Well let’s try to define just that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">first</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nv">M</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">second</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks good, but actually has a problem, to get an <code class="language-plaintext highlighter-rouge">Alg[F]</code> from <code class="language-plaintext highlighter-rouge">rebuild</code> we give it an <code class="language-plaintext highlighter-rouge">M</code> and an interpreter <code class="language-plaintext highlighter-rouge">Alg[F]</code>. 
The interpreter isn’t really a problem, but the <code class="language-plaintext highlighter-rouge">M</code> can prove problematic as we need to give it to the <code class="language-plaintext highlighter-rouge">rebuild</code> function after each monadic step to always receive the latest state.
If we look at our natural transformation above, that function will never receive the newest state.
So what can we do about this?
Well, we could be a bit more honest about our types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">FunctionM</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">FunctionM</span><span class="o">]</span>
</code></pre></div></div>

<p>Hey, now we’re getting there. This works, but if we look into some of the data types provided by <code class="language-plaintext highlighter-rouge">Cats</code> we can acutally see that this is just <code class="language-plaintext highlighter-rouge">Kleisli</code> or <code class="language-plaintext highlighter-rouge">ReaderT</code>, so our <code class="language-plaintext highlighter-rouge">rebuild</code> should actually look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span>
</code></pre></div></div>

<p>And now, we can easily implement a correct version of that natural transformation from earlier:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">first</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">m</span><span class="o">))(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">second</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Cool, then let us also adjust the rebuild function we created for <code class="language-plaintext highlighter-rouge">KVStore</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="nv">m</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">o</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nv">interp</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="o">})</span>

  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="nv">interp</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s stayed pretty much the same, we just needed to wrap the whole thing in a <code class="language-plaintext highlighter-rouge">Kleisli</code> and we’re good!</p>

<p>Now we can go ahead and define the full function signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="kt">:</span> <span class="kt">FunctorK:</span> <span class="kt">CartesianK</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">M:</span> <span class="kt">Monoid</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">MonadProgram</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span><span class="o">])</span>
  <span class="o">(</span><span class="n">rebuild</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
  
    <span class="k">val</span> <span class="nv">tupleToState</span> <span class="k">=</span> <span class="nf">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
        <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">first</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">m</span><span class="o">))(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">second</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="nv">withState</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
      <span class="nf">map2K</span><span class="o">(</span><span class="nf">extract</span><span class="o">(</span><span class="n">interpreter</span><span class="o">),</span> <span class="n">rebuild</span><span class="o">))(</span><span class="n">tupleToState</span><span class="o">)</span>

    <span class="nf">program</span><span class="o">(</span><span class="n">withState</span><span class="o">).</span><span class="py">runEmptyA</span>
  
  <span class="o">}</span>
</code></pre></div></div>

<p>That is all, we’ve got a fully polymorphic function that can optimize monadic programs.</p>

<p>Let’s use it!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">optimize</span><span class="o">(</span><span class="n">program</span><span class="o">)(</span><span class="n">extract</span><span class="o">)(</span><span class="n">rebuild</span><span class="o">)</span>
  <span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">printInterpreter</span><span class="o">)</span>
  <span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>Now, when we run this, it should be exactly the same result as when we ran it earlier using the direct <code class="language-plaintext highlighter-rouge">StateT</code> interpreter, but the resulting code is much cleaner.
However, it does have the drawback that you’ll now need additional constraints for every algebra to use this function.
That said though, one of the cool features of <code class="language-plaintext highlighter-rouge">Mainecoon</code> is that it comes with auto-derivation.
Meaning we can just add an annotation to any of our algebras and it will automatically derive the <code class="language-plaintext highlighter-rouge">FunctorK</code> and <code class="language-plaintext highlighter-rouge">CartesianK</code> instances.</p>

<p>In fact, that is exactly how I defined those two instances for the <code class="language-plaintext highlighter-rouge">KVStore</code> algebra:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@autoFunctorK</span>
<span class="nd">@autoCartesianK</span>
<span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>This makes it fairly easy to use these extra type classes and helpts mitigate the drawbacks I mentioned.</p>

<h3 id="conclusions">Conclusions</h3>

<p>Today we’ve seen a way to make optimizing monadic tagless final programs easier and intuitive, all the code is taken from the sphynx library and can be found <a href="https://github.com/LukaJCB/sphynx">right here</a>, but might still be subject to change, because designing a good API is hard.</p>

<p>What do you think about this optimization scheme? Maybe you just prefer using <code class="language-plaintext highlighter-rouge">StateT</code> and being done with it, or maybe you like to use a typeclass based approach like the one we used last time?</p>

<p>Would love to hear from you all in the comments!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 27 Jun 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/06/27/optimizing-tagless-final-2.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/06/27/optimizing-tagless-final-2.html</guid>
      </item>
    
      <item>
        <title>Typedapi or how to derive your clients and servers from types</title>
        
          <dc:creator>pheymann</dc:creator>
                
        <description><![CDATA[<p>In this blog post, I will show you how to leverage Scala’s type system to derive an HTTP client function from a single type. This will also be the story of how I started to work on <a href="https://github.com/pheymann/typedapi">Typedapi</a> which is basically the attempt to bring Haskell’s <a href="https://github.com/haskell-servant/servant">Servant</a> to Scala.</p>

<h2 id="servant-in-a-nutshell-and-how-it-began">Servant in a nutshell and how it began</h2>
<p>For everyone not knowing Servant, it is a library which lets you define your web apis as types and derives the client and server functions from it. When I saw it for the first time while working on a pet project I immediately loved the idea. Creating web server and clients this way reduces your code to a mere type, you get extra type safety and you can use the api types as contracts between your server and its clients.</p>

<p>I couldn’t find any viable alternative in Scala at the time and decided to build it on my own. But I just wanted to start with a single feature to not overwhelm myself and abandon the project after a short time. Therefore, I set out to make Scala able to derive a client function from a single api type, as we will do in this post.</p>

<h2 id="derive-a-client-function-from-a-type-how-hard-can-it-be">Derive a client function from a type. How hard can it be?</h2>
<p>Let’s start with an example we will use later on to ease understanding. Consider the following api:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /users/:name?minAge=:age -&gt; List[User]
</code></pre></div></div>

<p>It only consists of a single endpoint which returns a list of <code class="language-plaintext highlighter-rouge">Users</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>with a given <code class="language-plaintext highlighter-rouge">name: String</code>. Furthermore, you filter the resulting users by their <code class="language-plaintext highlighter-rouge">age: Int</code>. Our big goal is to end up with a function which is derived from a type-level representation of our endpoint:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">minAge</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span>
</code></pre></div></div>

<h3 id="represent-the-api-as-a-type">Represent the api as a type</h3>
<p>Question: how do you represent the above api as a type in Scala? I think the best way is to break it apart and try to find type-level representations for each element. After that, we “just” merge them together.</p>

<p>When we take a closer look at our endpoint we see that it consists of:</p>
<ul>
  <li>a method <code class="language-plaintext highlighter-rouge">GET</code> to identify which kind of operation we want to do and which also describes the expected return type</li>
  <li>constant path elements identifying an endpoint: <code class="language-plaintext highlighter-rouge">/users</code></li>
  <li>dynamic path elements called “segments” which represent input parameters with a name and type: <code class="language-plaintext highlighter-rouge">:name</code></li>
  <li>queries which again represent input parameters with a name and type: <code class="language-plaintext highlighter-rouge">minAge=[age]</code></li>
</ul>

<p>Or in other words, just a plain HTTP definition of a web endpoint. Now that we know what we are working with let’s try and find a type-level representation.</p>

<p>But how do you transform a value-level information as a type? First of all, the value has to be known at compile time which leaves us with literals. If we would work with Dotty we could leverage a concept called literal type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Path</span> <span class="o">=</span> <span class="s">"users"</span>
</code></pre></div></div>

<p>But since we want to stay in Vanilla Scala this will not work. We have to take another route by using a tool probably every developer has to use when it comes to working on the type-level called <a href="https://github.com/milessabin/shapeless">shapeless</a>. It has this nifty class <a href="https://github.com/milessabin/shapeless/blob/shapeless-2.3.3/core/src/main/scala/shapeless/singletons.scala#L32">Witness</a> which comes with an abstract type <code class="language-plaintext highlighter-rouge">T</code>. And <code class="language-plaintext highlighter-rouge">T</code> is exactly what we need here as it transforms our literals into types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.Witness</span>

<span class="k">val</span> <span class="nv">usersW</span> <span class="k">=</span> <span class="nc">Witness</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
</code></pre></div></div>

<p>But this isn’t a pure type declaration, you will say. And you are right, but right now there is no other way in Scala. We have to go the ordinary value road first to create our types.</p>

<p>Now that we know how to get a type representation from a <code class="language-plaintext highlighter-rouge">String</code> which describes our path we should clearly mark it as a path element:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Path</span><span class="o">[</span><span class="kt">P</span><span class="o">]</span>

<span class="nc">type</span> <span class="n">users</span> <span class="k">=</span> <span class="nc">Path</span><span class="o">[</span><span class="kt">usersW.T</span><span class="o">]</span>
</code></pre></div></div>

<p>That’s it. That is the basic concept of how we can describe our apis as types. We just reuse this concept now for the remaining elements like the segment.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">nameW</span> <span class="k">=</span> <span class="nc">Witness</span><span class="o">(</span><span class="ss">'name)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>

<span class="nc">type</span> <span class="n">name</span> <span class="k">=</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">nameW.T</span>, <span class="kt">String</span><span class="o">]</span>
</code></pre></div></div>

<p>Do you see how we included the segment’s identifier in the type? This way we are not only gain information about the expected type but also what kind of value we want to see. By the way, I decided to use <code class="language-plaintext highlighter-rouge">Symbols</code> as identifiers, but you could also switch to <code class="language-plaintext highlighter-rouge">String</code> literals. The remaining definitions look pretty similar:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">minAgeW</span> <span class="k">=</span> <span class="nc">Witness</span><span class="o">(</span><span class="ss">'minAge)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Query</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>

<span class="nc">type</span> <span class="n">minAge</span> <span class="k">=</span> <span class="nc">Query</span><span class="o">[</span><span class="kt">minAgeW.T</span>, <span class="kt">Int</span><span class="o">]</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Method</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Get</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Method</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">A</code> in <code class="language-plaintext highlighter-rouge">Get[A]</code> represents the expected result type of our api endpoint.</p>

<p>Now that we know how to obtain the types of our api elements we have to put them together into a single type representation. After looking through shapeless’s features we will find <code class="language-plaintext highlighter-rouge">HLists</code>, a list structure which can store elements of different types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.</span><span class="o">{::,</span> <span class="nc">HNil</span><span class="o">}</span>

<span class="k">type</span> <span class="kt">Api</span> <span class="o">=</span> <span class="nc">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="o">::</span> <span class="n">users</span> <span class="o">::</span> <span class="n">name</span> <span class="o">::</span> <span class="n">minAge</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Here you go. <code class="language-plaintext highlighter-rouge">Api</code> is an exact representation of the endpoint we defined at the beginning. But you don’t want to write <code class="language-plaintext highlighter-rouge">Witness</code> and <code class="language-plaintext highlighter-rouge">HLists</code> all the time so let’s wrap it up into a convenient function call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">api</span><span class="o">[</span><span class="kt">M</span> <span class="k">&lt;:</span> <span class="kt">Method</span>, <span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Q</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Api</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span>
       <span class="o">(</span><span class="n">method</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">path</span><span class="k">:</span> <span class="kt">PathList</span><span class="o">[</span><span class="kt">P</span><span class="o">],</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">QueryList</span><span class="o">[</span><span class="kt">Q</span><span class="o">])</span>
       <span class="o">(</span><span class="k">implicit</span> <span class="n">prepQP</span><span class="k">:</span> <span class="kt">Prepend.Aux</span><span class="o">[</span><span class="kt">Q</span>, <span class="kt">P</span>, <span class="kt">Api</span><span class="o">])</span><span class="k">:</span> <span class="kt">ApiTypeCarrier</span><span class="o">[</span><span class="kt">M</span> <span class="kt">::</span> <span class="kt">Api</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ApiTypeCarrier</span><span class="o">()</span>
      
<span class="k">val</span> <span class="nv">Api</span> <span class="k">=</span> <span class="nf">api</span><span class="o">(</span><span class="nc">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]],</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="ss">'name)</span><span class="o">,</span> <span class="nv">Queries</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="nc">Query</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="ss">'minAge)</span><span class="o">))</span>
</code></pre></div></div>

<p>Not clear what is happening? Let’s take a look at the different elements of <code class="language-plaintext highlighter-rouge">def api(...)</code>:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">method</code> should be obvious. It takes some method type.</li>
  <li><code class="language-plaintext highlighter-rouge">PathList</code> is a type carrier with a function <code class="language-plaintext highlighter-rouge">def /(...)</code> to concatenate path elements and segments. In the end, <code class="language-plaintext highlighter-rouge">PathList</code> only stores the type of an <code class="language-plaintext highlighter-rouge">HList</code> and nothing more.</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PathList</span><span class="o">[</span><span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]()</span> <span class="o">{</span>
  
  <span class="k">def</span> <span class="nf">/</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">path</span><span class="k">:</span> <span class="kt">Witness.Lt</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">PathList</span><span class="o">[</span><span class="kt">S</span> <span class="kt">::</span> <span class="kt">P</span><span class="o">]</span> <span class="k">=</span> <span class="nc">PathList</span><span class="o">()</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">Root</span> <span class="k">=</span> <span class="nc">PathList</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]()</span>
</code></pre></div></div>
<ul>
  <li>Same is true for <code class="language-plaintext highlighter-rouge">QueryList</code>.</li>
  <li>The last step is to merge all these <code class="language-plaintext highlighter-rouge">HLists</code> types into a single one. Shapeless comes again with a handy type class called <code class="language-plaintext highlighter-rouge">Prepend</code> which provides us with the necessary functionality. Two <code class="language-plaintext highlighter-rouge">HList</code> types go in, a single type comes out. And again, we use a type carrier here to store the api type.</li>
</ul>

<p>Whoho, we did it. One thing we can mark as done on our todo list. Next step is to derive an actual client function from it.</p>

<h3 id="clients-from-types">Clients from types</h3>
<p>So far we have a type carrier describing our api as type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApiTypeCarrier</span><span class="o">[</span><span class="kt">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="kt">::</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">minAgeW.T</span>, <span class="kt">Int</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">Segment</span><span class="o">[</span><span class="kt">nameW.T</span>, <span class="kt">String</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">usersW.T</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span>
</code></pre></div></div>

<p>Now we want to transform that into a function call <code class="language-plaintext highlighter-rouge">(name: String, minAge: Int) =&gt; F[List[User]]</code>. So what we need is the following:</p>
<ul>
  <li>the types of our expected input</li>
  <li>the output type</li>
  <li>the path to the endpoint we want to call</li>
</ul>

<p>All information are available but mixed up and we need to separate them. Usually, when we work with collections and want to change their shape we do a <code class="language-plaintext highlighter-rouge">fold</code> and alas shapeless has type classes to fold left and right over an <code class="language-plaintext highlighter-rouge">HList</code>. But we only have a type. How do we fold that?</p>

<h4 id="type-level-foldleft">Type-level FoldLeft</h4>
<p>What we want is to go from <code class="language-plaintext highlighter-rouge">Api &lt;: HList</code> to <code class="language-plaintext highlighter-rouge">(El &lt;: HList, KIn &lt;: HList, VIn &lt;: HList, M, Out)</code> with:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">El</code> al the elements in our api: <code class="language-plaintext highlighter-rouge">"users".type :: SegmentInput :: QueryInput :: GetCall :: HNil</code></li>
  <li><code class="language-plaintext highlighter-rouge">KIn</code> the input key types: <code class="language-plaintext highlighter-rouge">nameW.T :: minAgeW.T :: HNil</code></li>
  <li><code class="language-plaintext highlighter-rouge">VIn</code> the input value types: <code class="language-plaintext highlighter-rouge">String :: Int :: HNil</code></li>
  <li>the method type: <code class="language-plaintext highlighter-rouge">GetCall</code></li>
  <li>and <code class="language-plaintext highlighter-rouge">Out</code>: <code class="language-plaintext highlighter-rouge">List[User]</code></li>
</ul>

<p>Here, we introduced new types <code class="language-plaintext highlighter-rouge">SegmentInput</code> and <code class="language-plaintext highlighter-rouge">QueryInput</code> which act as placeholders and indicate that our api has the following inputs. This representation will come in handy when we construct our function.</p>

<p>Now, how to fold on the type-level? The first step, we have to define a function which describes how to aggregate two types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FoldLeftFunction</span><span class="o">[</span><span class="kt">In</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">}</span>
</code></pre></div></div>

<p>That’s it. We say what goes in and what comes out. You need some examples to get a better idea? Here you go:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">pathTransformer</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nc">FoldLeftFunction</span><span class="o">[</span><span class="kt">Path</span><span class="o">[</span><span class="kt">P</span><span class="o">]</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">::</span> <span class="nc">El</span><span class="o">,</span> <span class="nc">KIn</span><span class="o">,</span> <span class="nc">VIn</span><span class="o">,</span> <span class="nc">Out</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>We expect a <code class="language-plaintext highlighter-rouge">Path[P]</code> and intermediate aggregation state <code class="language-plaintext highlighter-rouge">(El, KIn, VIn, M, Out)</code>. We merge the two by adding <code class="language-plaintext highlighter-rouge">P</code> to our list of api elements. The same technique is also used for more involved aggregations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">segmentTransformer</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">V</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nc">FoldLeftFunction</span><span class="o">[</span><span class="kt">Segment</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SegmentInput</span> <span class="o">::</span> <span class="nc">El</span><span class="o">,</span> <span class="n">K</span> <span class="o">::</span> <span class="nc">KIn</span><span class="o">,</span> <span class="n">V</span> <span class="o">::</span> <span class="nc">VIn</span><span class="o">,</span> <span class="nc">Out</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>Here, we get some <code class="language-plaintext highlighter-rouge">Segment</code> with a name <code class="language-plaintext highlighter-rouge">K</code> and a type <code class="language-plaintext highlighter-rouge">V</code> and an intermediate aggregation state we will update by adding a placeholder to <code class="language-plaintext highlighter-rouge">El</code>, the name to <code class="language-plaintext highlighter-rouge">KIn</code> and the value type to <code class="language-plaintext highlighter-rouge">VIn</code>.</p>

<p>Now that we can aggregate types we need a vehicle to traverse our <code class="language-plaintext highlighter-rouge">HList</code> type and transform it on the fly by using our <code class="language-plaintext highlighter-rouge">FoldLeftFunction</code> instances. I think yet another type class can help us here.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">TypeLevelFoldLeft</span><span class="o">[</span><span class="kt">H</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">}</span>

<span class="k">object</span> <span class="nc">TypeLevelFoldLeft</span> <span class="o">{</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">returnCase</span><span class="o">[</span><span class="kt">Agg</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TypeLevelFoldLeft</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Agg</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">foldCase</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Agg</span>, <span class="kt">FfOut</span>, <span class="kt">FOut</span><span class="o">](</span><span class="k">implicit</span> <span class="n">f</span><span class="k">:</span> <span class="kt">FoldLeftFunction.Aux</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">Agg</span>, <span class="kt">FfOut</span><span class="o">],</span> 
                                                                  <span class="n">next</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">TypeLevelFoldLeft.Aux</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">FfOut</span>, <span class="kt">FOut</span><span class="o">]])</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">TypeLevelFoldLeft</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">FOut</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The above definition describes a recursive function which will apply the <code class="language-plaintext highlighter-rouge">FoldLeftFunction</code> on <code class="language-plaintext highlighter-rouge">H</code> and the current aggregated type <code class="language-plaintext highlighter-rouge">Agg</code> and continues with the resulting <code class="language-plaintext highlighter-rouge">FfOut</code> and the remaining list. And before you bang your head against the wall for hours until the clock strikes 3 am, like I did, a small hint, make <code class="language-plaintext highlighter-rouge">next</code> lazy. Otherwise, Scala is not able to find <code class="language-plaintext highlighter-rouge">next</code>. My guess is that Scala is not able to infer <code class="language-plaintext highlighter-rouge">next</code>, because it depends on <code class="language-plaintext highlighter-rouge">FfOut</code> which is also unknown. So we have to defer <code class="language-plaintext highlighter-rouge">next</code>’s inference to give the compiler some time to work.</p>

<p>And another hint, you can start with <code class="language-plaintext highlighter-rouge">Unit</code> as the initial type for your aggregate.</p>

<h4 id="collect-all-the-request-data">Collect all the request data</h4>
<p>We folded our api type into the new representation making it easier now to derive a function which collects all the data necessary to make a request.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// path to our endpoint described by Path and Segment
</span><span class="k">type</span> <span class="kt">Uri</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

<span class="c1">// queries described by Query
</span><span class="k">type</span> <span class="kt">Queries</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>

<span class="nc">VIn</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Uri</span><span class="o">,</span> <span class="nc">Queries</span><span class="o">)</span>
</code></pre></div></div>

<p>This function will form the basis of our client function we try to build. It generates the <code class="language-plaintext highlighter-rouge">Uri</code> and a <code class="language-plaintext highlighter-rouge">Map</code> of <code class="language-plaintext highlighter-rouge">Queries</code> which will be used later on to do a request using some HTTP library.</p>

<p>By now, you should be already comfortable with type classes. Therefore, it shouldn’t shock you that I will introduce yet another one to derive the above function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">inputs</span><span class="k">:</span> <span class="kt">VIn</span><span class="o">,</span> <span class="n">uri</span><span class="k">:</span> <span class="kt">Uri</span><span class="o">,</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">Queries</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Instances of this type class update <code class="language-plaintext highlighter-rouge">uri</code> and <code class="language-plaintext highlighter-rouge">queries</code> depending on the types they see. For example, if the current head of <code class="language-plaintext highlighter-rouge">El</code> is a path element we prepend its <code class="language-plaintext highlighter-rouge">String</code> literal to <code class="language-plaintext highlighter-rouge">uri</code>. Just keep in mind to reverse the <code class="language-plaintext highlighter-rouge">List</code> before returning it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">pathBuilder</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="k">implicit</span> <span class="n">wit</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">P</span><span class="o">],</span> <span class="n">next</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">])</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">RequestDataBuilder</span><span class="o">[</span><span class="kt">P</span> <span class="kt">::</span> <span class="kt">T</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">inputs</span><span class="k">:</span> <span class="kt">VIn</span><span class="o">,</span> <span class="n">uri</span><span class="k">:</span> <span class="kt">Uri</span><span class="o">,</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">Queries</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">)</span> <span class="k">=</span>
      <span class="nf">next</span><span class="o">(</span><span class="n">inputs</span><span class="o">,</span> <span class="nv">wit</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">toString</span><span class="o">()</span> <span class="o">::</span> <span class="n">uri</span><span class="o">,</span> <span class="n">queries</span><span class="o">,</span> <span class="n">headers</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Or if we encounter a query input we derive the key’s type-literal, pair it with the given input value and add both to <code class="language-plaintext highlighter-rouge">queries</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">queryBuilder</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">V</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="k">implicit</span> <span class="n">wit</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span> <span class="n">next</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">])</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">RequestDataBuilder</span><span class="o">[</span><span class="kt">QueryInput</span> <span class="kt">::</span> <span class="kt">T</span>, <span class="kt">K</span> <span class="kt">::</span> <span class="kt">KIn</span>, <span class="kt">V</span> <span class="kt">::</span> <span class="kt">VIn</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">inputs</span><span class="k">:</span> <span class="kt">V</span> <span class="kt">::</span> <span class="kt">VIn</span><span class="o">,</span> <span class="n">uri</span><span class="k">:</span> <span class="kt">Uri</span><span class="o">,</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">Queries</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">)</span> <span class="k">=</span>
      <span class="nf">next</span><span class="o">(</span><span class="nv">inputs</span><span class="o">.</span><span class="py">tail</span><span class="o">,</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="nv">wit</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">name</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nv">inputs</span><span class="o">.</span><span class="py">head</span><span class="o">.</span><span class="py">toString</span><span class="o">()))</span> <span class="o">++</span> <span class="n">queries</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The other cases are looking quite similar and it is up to the interested reader to find the implementations.</p>

<p>What we end up with is a nested function call structure which will take an <code class="language-plaintext highlighter-rouge">HList</code> and returns the <code class="language-plaintext highlighter-rouge">uri</code> and <code class="language-plaintext highlighter-rouge">queries</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">builder</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">]]</span>

<span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">VIn</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="nc">Uri</span><span class="o">,</span> <span class="nc">Queries</span><span class="o">)</span> <span class="k">=</span> <span class="n">input</span> <span class="k">=&gt;</span> <span class="nf">builder</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">,</span> <span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>

<span class="s">"joe"</span> <span class="o">::</span> <span class="mi">42</span> <span class="o">::</span> <span class="nc">HNil</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"users"</span><span class="o">,</span> <span class="s">"joe"</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"minAge"</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">"42"</span><span class="o">)))</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">"joe"</code> and <code class="language-plaintext highlighter-rouge">42</code> are our expected inputs (<code class="language-plaintext highlighter-rouge">VIn</code>) which we derived from the segments and queries of our <code class="language-plaintext highlighter-rouge">Api</code>.</p>

<h4 id="make-the-request">Make the request</h4>
<p>We have all the data we need to make an IO request but nothing to execute it. We change that now. By adding an HTTP backend. But we don’t want to expose this implementation detail through our code. What we want is a generic description of a request action and that sounds again like a job for type classes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ApiRequest</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">C</span>, <span class="kt">Out</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">),</span> <span class="n">client</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Out</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have to specialize that for the set of methods we have:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">GetRequest</span><span class="o">[</span><span class="kt">C</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Out</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">ApiRequest</span><span class="o">[</span><span class="kt">GetCall</span>, <span class="kt">C</span>, <span class="kt">F</span>, <span class="kt">Out</span><span class="o">]</span>

<span class="o">...</span>

<span class="k">val</span> <span class="nv">request</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">ApiRequest</span><span class="o">[</span><span class="kt">GetCall</span>, <span class="kt">IO</span>, <span class="kt">C</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]]</span>

<span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">VIn</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="n">input</span> <span class="k">=&gt;</span> <span class="nf">request</span><span class="o">(</span><span class="nf">builder</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">,</span> <span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">),</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s say we want http4s as our backend. Then we just have to implement these <code class="language-plaintext highlighter-rouge">traits</code> using http4s functionality.</p>

<h4 id="make-it-a-whole">Make it a whole</h4>
<p>We have a bunch of type classes which in theory do a request, but so far they are completely useless. To make a working piece of code out of it we have to connect them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">derive</span><span class="o">[</span><span class="kt">Api</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">C</span><span class="o">]</span>
  <span class="o">(</span><span class="n">api</span><span class="k">:</span> <span class="kt">ApiTypeCarrier</span><span class="o">[</span><span class="kt">Api</span><span class="o">],</span> <span class="n">client</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">fold</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">TypeLevelFoldLeft.Aux</span><span class="o">[</span><span class="kt">Api</span>, <span class="kt">Fold</span><span class="o">]</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]</span>
            <span class="n">builder</span><span class="k">:</span> <span class="kt">RequestBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">],</span>
            <span class="n">request</span><span class="k">:</span> <span class="kt">ApiRequest</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">F</span>, <span class="kt">C</span>, <span class="kt">Out</span><span class="o">])</span><span class="k">:</span> <span class="kt">VIn</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Out</span><span class="o">]</span> <span class="k">=</span> <span class="n">vin</span> <span class="k">=&gt;</span> <span class="nf">request</span><span class="o">(</span><span class="nv">builder</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">vin</span><span class="o">,</span> <span class="nv">List</span><span class="o">.</span><span class="py">newBuilder</span><span class="o">,</span> <span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">),</span> <span class="n">client</span><span class="o">)</span>
</code></pre></div></div>

<p>The first approach gives us the desired function. It transforms our api type into a <code class="language-plaintext highlighter-rouge">(El, KIn, VIn, Method, Out)</code> representation, derives a function to collect all data to do a request, and finds an IO backend to actually do the request. But it has a major drawback. You have to fix <code class="language-plaintext highlighter-rouge">F[_]</code> somehow and the only way is to set it explicitly. But by doing that you are forced to provide definitions for all the type parameters. Furthermore, this function isn’t really convenient. To use it you have to create and pass an <code class="language-plaintext highlighter-rouge">HList</code> and as we said before, we don’t want to expose something like that.</p>

<p>To fix the first problem we simply add a helper class which moves the step of defining the higher kind <code class="language-plaintext highlighter-rouge">F[_]</code> to a separate function call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">ExecutableDerivation</span><span class="o">[</span><span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">O</span><span class="o">](</span><span class="n">builder</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">],</span> <span class="n">input</span><span class="k">:</span> <span class="kt">VIn</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">final</span> <span class="k">class</span> <span class="nc">Derivation</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">client</span><span class="k">:</span> <span class="kt">C</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">req</span><span class="k">:</span> <span class="kt">ApiRequest</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">C</span>, <span class="kt">F</span>, <span class="kt">O</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">O</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">data</span> <span class="k">=</span> <span class="nf">builder</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nv">List</span><span class="o">.</span><span class="py">newBuilder</span><span class="o">,</span> <span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>

      <span class="nf">req</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">cm</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">run</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Derivation</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Derivation</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Making a function of arity <code class="language-plaintext highlighter-rouge">Length[VIn]</code> out of <code class="language-plaintext highlighter-rouge">Vin =&gt; F[O]</code>is possible by using <code class="language-plaintext highlighter-rouge">shapeless.ops.function.FnFromProduct</code>.</p>

<p>When we apply both solutions we end up with:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">derive</span><span class="o">[</span><span class="kt">H</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Fold</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]</span>
  <span class="o">(</span><span class="n">apiList</span><span class="k">:</span> <span class="kt">ApiTypeCarrier</span><span class="o">[</span><span class="kt">H</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">fold</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">TypeLevelFoldLeft.Aux</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">Unit</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]],</span>
            <span class="n">builder</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">],</span>
            <span class="n">vinToFn</span><span class="k">:</span> <span class="kt">FnFromProduct</span><span class="o">[</span><span class="kt">VIn</span> <span class="k">=&gt;</span> <span class="kt">ExecutableDerivation</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]])</span><span class="k">:</span> <span class="kt">vinToFn.Out</span> <span class="o">=</span> 
  <span class="nv">vinToFn</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">ExecutableDerivation</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">](</span><span class="n">builder</span><span class="o">,</span> <span class="n">input</span><span class="o">))</span>
</code></pre></div></div>

<p>I already hear the “your function signature is so big …” jokes incoming, but this is basically what we will (and want to) end up with when doing type-level programming. In the end, our types have to express the logic of our program and that needs some space.</p>

<p>But finally, we can say we did it! We convinced the Scala compiler to derive a client function from a type. Let’s have a look at our example to see how it works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">org.http4s.client.Client</span>

<span class="k">val</span> <span class="nv">Api</span> <span class="k">=</span> <span class="nf">api</span><span class="o">(</span><span class="nc">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]],</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="ss">'name)</span><span class="o">,</span> <span class="nv">Queries</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="nc">Query</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="ss">'minAge)</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">get</span> <span class="k">=</span> <span class="nf">derive</span><span class="o">(</span><span class="nc">Api</span><span class="o">)</span>

<span class="nf">get</span><span class="o">(</span><span class="s">"joe"</span><span class="o">,</span> <span class="mi">42</span><span class="o">).</span><span class="py">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="nc">Client</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span> <span class="c1">// IO[List[User]]
</span></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>When you take a closer look at the code above you will see that we were able to move most of the heavy lifting to the compiler or shapeless therefore reducing our code to a relatively small set of “simple” type classes. And when literal types are in thing in Scala we can also remove most of the boilerplate necessary to create our api types.</p>

<p>This, again, shows me how powerful Scalas type system is and how much you can gain when you embrace it.</p>

<h2 id="next-step---typedapi">Next Step - Typedapi</h2>
<p>Now that we are able to derive a single client function from a type we should also be able to do the same for a collection of api types. And if we are already on it, let’s add server-side support. Or … you just use <a href="https://github.com/pheymann/typedapi">Typedapi</a>. It already comes with the following features:</p>
<ul>
  <li>client function derivation</li>
  <li>server function derivation</li>
  <li>single and multi api type handling</li>
  <li>support for htt4s</li>
  <li>support for akka-http in the making</li>
  <li>simple interface to add more HTTP frameworks/libraries</li>
</ul>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/06/15/typedapi.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/06/15/typedapi.html</guid>
      </item>
    
      <item>
        <title>Shared State in Functional Programming</title>
        
          <dc:creator>gvolpe</dc:creator>
                
        <description><![CDATA[<p>Newcomers to functional programming (FP) are often very confused about the proper way to share state without breaking purity and end up having a mix of pure and impure code that <a href="https://queue.acm.org/detail.cfm?id=2611829">defeats the purpose</a> of having pure FP code in the first place.</p>

<p>This is the reason that has motivated me to write a beginner friendly guide :)</p>

<h2 id="use-case">Use Case</h2>

<p>We have a program that runs three computations at the same time and updates the internal state to keep track of the
tasks that have been completed. When all the tasks are completed we request the final state and print it out.</p>

<p>You should get an output similar to the following one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Starting process #1
Starting process #2
Starting process #3
  ... 3 seconds
Done #2
  ... 5 seconds
Done #1
  ... 10 seconds
Done #3
List(#2, #1, #3)
</code></pre></div></div>

<p>We’ll use the concurrency primitive <a href="https://typelevel.org/cats-effect/concurrency/ref.html"><code class="language-plaintext highlighter-rouge">Ref[IO, List[String]]</code></a> to represent our internal state because it’s a great fit.</p>

<h3 id="getting-started">Getting started</h3>

<p>So this is how we might decide to start writing our code having some knowledge about <a href="https://typelevel.org/cats-effect/datatypes/io.html"><code class="language-plaintext highlighter-rouge">cats.effect.IO</code></a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">object</span> <span class="nc">sharedstate</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">_</span>

  <span class="k">def</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>

  <span class="k">val</span> <span class="nv">process1</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #1"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#1"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #1"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="nv">process2</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #2"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#2"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #2"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="nv">process3</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #3"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#3"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #3"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">myState</span> <span class="k">=</span> <span class="nv">Ref</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="py">unsafeRunSync</span><span class="o">()</span>
    <span class="k">val</span> <span class="nv">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">process1</span><span class="o">,</span> <span class="n">process2</span><span class="o">,</span> <span class="n">process3</span><span class="o">).</span><span class="py">parSequence</span><span class="o">.</span><span class="py">void</span>
    <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="nv">myState</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="nv">rs</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">masterProcess</span><span class="o">.</span><span class="py">as</span><span class="o">(</span><span class="nv">ExitCode</span><span class="o">.</span><span class="py">Success</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>We defined a <code class="language-plaintext highlighter-rouge">var myState: Ref[IO, List[String]]</code> initialized as <code class="language-plaintext highlighter-rouge">null</code> so we can create it on startup and all the child processes can have access to it. A so called <code class="language-plaintext highlighter-rouge">global state</code>.</p>

<p>But now we try to run our application and we encounter our first ugly problem: <code class="language-plaintext highlighter-rouge">NullPointerException</code> on line 19. All the processes are defined by using <code class="language-plaintext highlighter-rouge">myState</code> which has not yet been initialized. So an easy way to fix it is to define all our processes as <code class="language-plaintext highlighter-rouge">lazy val</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="nv">process1</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="nv">process2</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="nv">process3</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>That worked, brilliant! We have an application that meets the business criteria and most importantly it works!</p>

<h3 id="rethinking-our-application">Rethinking our application</h3>

<p>But let’s take a step back and review our code once again, there are at least two pieces of code that should have caught your attention:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">_</span>
</code></pre></div></div>

<p>We are using <code class="language-plaintext highlighter-rouge">var</code> and initializing our state to <code class="language-plaintext highlighter-rouge">null</code>, OMG! Also the workaround of <code class="language-plaintext highlighter-rouge">lazy val</code> should get you thinking…</p>

<p>And here’s the second obvious one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myState</span> <span class="k">=</span> <span class="nv">Ref</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="py">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>We require our <code class="language-plaintext highlighter-rouge">myState</code> to be of type <code class="language-plaintext highlighter-rouge">Ref[IO, List[String]</code> but the smart constructor gives us an <code class="language-plaintext highlighter-rouge">IO[Ref[IO, List[String]]]</code> so we are “forced” to call <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> to get our desired type. And there’s a reason for that, the creation of a <code class="language-plaintext highlighter-rouge">Ref[F, A]</code> is side-effectful, therefore it needs to be wrapped in <code class="language-plaintext highlighter-rouge">IO</code> to keep the purity.</p>

<p>But wait a minute… that <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> is something that you should only see at the edge of your program, most commonly in the <code class="language-plaintext highlighter-rouge">main</code> method that is invoked by the <code class="language-plaintext highlighter-rouge">JVM</code> and that is impure by nature (of type <code class="language-plaintext highlighter-rouge">Unit</code>). But because we are using <code class="language-plaintext highlighter-rouge">IOApp</code> we shouldn’t be calling any operations which names are prefixed with <code class="language-plaintext highlighter-rouge">unsafe</code>.</p>

<p>You say to yourself, yes, I know this is bad and ugly but I don’t know a better way to share the state between different computations and this works. But we know you have heard that funcional programming is beautiful so why doing this?</p>

<h3 id="functional-programming">Functional Programming</h3>

<p>Okay, can we do better? Of course we do and you wouldn’t believe how simple it is!</p>

<p>Let’s get started by getting rid of that ugly <code class="language-plaintext highlighter-rouge">var myState</code> initialized to <code class="language-plaintext highlighter-rouge">null</code> and pass it as parameter to the processes that need to access it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">object</span> <span class="nc">sharedstate</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>

  <span class="k">def</span> <span class="nf">process1</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #1"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#1"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #1"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">process2</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #2"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#2"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #2"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">process3</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #3"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#3"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #3"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Ref</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="py">unsafeRunSync</span><span class="o">()</span>

    <span class="k">val</span> <span class="nv">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nf">process1</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="nf">process2</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="nf">process3</span><span class="o">(</span><span class="n">myState</span><span class="o">)).</span><span class="py">parSequence</span><span class="o">.</span><span class="py">void</span>
    <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="nv">myState</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="nv">rs</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">masterProcess</span><span class="o">.</span><span class="py">as</span><span class="o">(</span><span class="nv">ExitCode</span><span class="o">.</span><span class="py">Success</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Great! We got rid of that <code class="language-plaintext highlighter-rouge">global state</code> and we are now passing our <code class="language-plaintext highlighter-rouge">Ref</code>as a parameter. Remember that it is a concurrency primitive meant to be accesed and modified in concurrent scenarios, so we are safe here.</p>

<p>Notice how all our processes are now defined as <code class="language-plaintext highlighter-rouge">def processN(myState: Ref[IO, List[String]])</code>.</p>

<h3 id="a-well-known-method-flatmap">A well known method: flatMap!</h3>

<p>Now, we still have that <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> hanging around our code, how can we get rid of it? The answer is <code class="language-plaintext highlighter-rouge">flatMap</code>!!!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Ref</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">myState</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nf">process1</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="nf">process2</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="nf">process3</span><span class="o">(</span><span class="n">myState</span><span class="o">)).</span><span class="py">parSequence</span><span class="o">.</span><span class="py">void</span>
    <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="nv">myState</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="nv">rs</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>You only need to call <code class="language-plaintext highlighter-rouge">flatMap</code> once up in the call chain where you call the processes to make sure they all share the same state. If you don’t do this, a new <code class="language-plaintext highlighter-rouge">Ref</code> will be created every time you <code class="language-plaintext highlighter-rouge">flatMap</code> (remember creating a <code class="language-plaintext highlighter-rouge">Ref</code> is side effectful!) and thus your processes will not be sharing the same state changing the behavior of your program.</p>

<p>We now have a purely functional code that shares state in a simple and pure fashion. Here’s the entire FP program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">object</span> <span class="nc">sharedstate</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>

  <span class="k">def</span> <span class="nf">process1</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #1"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#1"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #1"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">process2</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #2"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#2"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #2"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">process3</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Starting process #3"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">IO</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nv">myState</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#3"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"Done #3"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Ref</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">myState</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="nv">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nf">process1</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="nf">process2</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="nf">process3</span><span class="o">(</span><span class="n">myState</span><span class="o">)).</span><span class="py">parSequence</span><span class="o">.</span><span class="py">void</span>
      <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="nv">myState</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="nv">rs</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
    <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">masterProcess</span><span class="o">.</span><span class="py">as</span><span class="o">(</span><span class="nv">ExitCode</span><span class="o">.</span><span class="py">Success</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="mutable-reference">Mutable reference</h2>

<p>As I mentioned in one of the sections above, the creation of <code class="language-plaintext highlighter-rouge">Ref[F, A]</code> is side-effectful. So what does this mean? Does it write to disk? Does it perform HTTP Requests? Not exactly.</p>

<p>It all comes down to wanting to keep the property of <em>referential transparency</em> while sharing and mutating state. So let’s again put up an example to follow up along with some explanation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="k">=</span> <span class="n">n</span>
<span class="k">def</span> <span class="nf">get</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></div></div>

<p>Here we have imperative and impure code that mutates state. So we can try wrapping things in <code class="language-plaintext highlighter-rouge">IO</code> to keep side effects under control:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">IORef</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">a</span> <span class="k">=</span> <span class="n">n</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">get</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is way better since now the mutation is encapsulated within <code class="language-plaintext highlighter-rouge">IORef</code> but we are now pushing some responsibility to whoever creates an <code class="language-plaintext highlighter-rouge">IORef</code>. Consider this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ref</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IORef</span><span class="o">()</span>
</code></pre></div></div>

<p>If we have two or more references to <code class="language-plaintext highlighter-rouge">ref</code> in our code, they will be referring to the same mutable state and we don’t really want that. We can make sure this doesn’t happen and a way to achieve this is to wrap the creation of <code class="language-plaintext highlighter-rouge">IORef</code> in <code class="language-plaintext highlighter-rouge">IO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">class</span> <span class="nc">IORef</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">a</span> <span class="k">=</span> <span class="n">n</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">get</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">IO</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">IORef</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IORef</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">IORef</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have now regained purity. So whenever you create an <code class="language-plaintext highlighter-rouge">IORef</code> you’ll get an <code class="language-plaintext highlighter-rouge">IO[IORef]</code> instead of a mutable reference to <code class="language-plaintext highlighter-rouge">IORef</code>. This means that when you invoke <code class="language-plaintext highlighter-rouge">flatMap</code> on it twice you’ll get two different mutable states, and this is the power of <code class="language-plaintext highlighter-rouge">Referential Transparency</code>. It gives you way more control than having a <code class="language-plaintext highlighter-rouge">val ref</code> hanging around in your code and gives you <strong><em>local reasoning</em></strong>.</p>

<p><em>All these examples are written in terms of <code class="language-plaintext highlighter-rouge">IO</code> for the sake of simplicity but in practice they are polymorphic on the effect type.</em></p>

<h2 id="applying-the-technique-in-other-libraries">Applying the technique in other libraries</h2>

<p>Although in the example above we only see how it’s done with the <code class="language-plaintext highlighter-rouge">cats-effect</code> library, this principle expands to other FP libraries as well.</p>

<p>For example, when writing an <code class="language-plaintext highlighter-rouge">http4s</code> application you might need to create an <code class="language-plaintext highlighter-rouge">HttpClient</code> that needs to be used by more than one of your services. So again, create it at startup and <code class="language-plaintext highlighter-rouge">flatMap</code> it once:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">HttpServer</span> <span class="k">extends</span> <span class="nc">StreamApp</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">stream</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">requestShutdown</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">httpClient</span> <span class="k">&lt;-</span> <span class="nv">Http1Client</span><span class="o">.</span><span class="py">stream</span><span class="o">[</span><span class="kt">IO</span><span class="o">]()</span>
      <span class="n">endpoint1</span>  <span class="k">=</span> <span class="k">new</span> <span class="nc">HttpEndpointOne</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">httpClient</span><span class="o">)</span>
      <span class="n">endpoint2</span>  <span class="k">=</span> <span class="k">new</span> <span class="nc">HttpEndpointTwo</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">httpClient</span><span class="o">)</span>
      <span class="n">exitCode</span>   <span class="k">&lt;-</span> <span class="nc">BlazeBuilder</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
                      <span class="o">.</span><span class="py">bindHttp</span><span class="o">(</span><span class="mi">8080</span><span class="o">,</span> <span class="s">"0.0.0.0"</span><span class="o">)</span>
                      <span class="o">.</span><span class="py">mountService</span><span class="o">(</span><span class="n">endpoint1</span><span class="o">)</span>
                      <span class="o">.</span><span class="py">mountService</span><span class="o">(</span><span class="n">endpoint2</span><span class="o">)</span>
                      <span class="o">.</span><span class="py">serve</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">exitCode</span>

<span class="o">}</span>

<span class="k">class</span> <span class="nc">HttpEndpointOne</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">client</span><span class="k">:</span> <span class="kt">Client</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">HttpEndpointTwo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">client</span><span class="k">:</span> <span class="kt">Client</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>When writing <code class="language-plaintext highlighter-rouge">fs2</code> applications you can apply the same technique, for example between processes that share a <code class="language-plaintext highlighter-rouge">Queue</code>, <code class="language-plaintext highlighter-rouge">Topic</code>, <code class="language-plaintext highlighter-rouge">Signal</code>, <code class="language-plaintext highlighter-rouge">Semaphore</code>, etc.</p>

<p>Remember that if you are forced to call <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> other than in your <code class="language-plaintext highlighter-rouge">main</code> method it might be a <em>code smell</em>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>To conclude this post I would like to give a big shout out to <a href="https://github.com/SystemFw">@SystemFW</a> who has been untiringly teaching this concept in the Gitter channels. And here’s a quote from his response on <a href="https://www.reddit.com/r/scala/comments/8ofc8j/shared_state_in_pure_functional_programming_github/e050wy2/">Reddit</a>:</p>

<blockquote>
  <p>At the end of the day all the benefits from <em>referential transparency</em> boil down to being able to understand and build code compositionally. That is, understanding code by understanding individual parts and putting them back together, and building code by building individual parts and combining them together. This is only possible if <em>local reasoning</em> is guaranteed, because otherwise there will be weird interactions when you put things back together, and referential transparency is <em>defined</em> as something that guarantees local reasoning.</p>
</blockquote>

<blockquote>
  <p>In the specific case of state sharing, this gives rise to a really nice property: since the only way to share is passing things as an argument, <em>the regions of sharing are exactly the same of your call graph</em>, so you transform an important aspect of the behaviour (“who shares this state?”) into a straightforward syntactical property (“what methods take this argument”?). This makes shared state in pure FP a lot easier to reason about than its side-effectful counterpart imho.</p>
</blockquote>

<p>In simple terms, remind yourself about this: <strong>“flatMap once and pass the reference as an argument!”</strong></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 07 Jun 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/06/07/shared-state-in-fp.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/06/07/shared-state-in-fp.html</guid>
      </item>
    
      <item>
        <title>Tagless Final algebras and Streaming</title>
        
          <dc:creator>gvolpe</dc:creator>
                
        <description><![CDATA[<p>There have been a couple of really <a href="https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html">nice blog posts</a> about <code class="language-plaintext highlighter-rouge">Tagless Final</code> and some related topics. However, I have faced some design problems when writing some algebras and haven’t seen anybody talking about. So please let me introduce this problem to you.</p>

<h3 id="algebra-definition">Algebra definition</h3>

<p>Given the following data definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">ItemName</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Item</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">,</span> <span class="n">price</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">)</span>
</code></pre></div></div>

<p>Consider the following algebra:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">findAll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s go through each method’s definition:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">findAll</code> needs to return many Items, obtainable inside a context: <code class="language-plaintext highlighter-rouge">F[List[Item]]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">find</code> might or might not return an Item inside a context: <code class="language-plaintext highlighter-rouge">F[Option[Item]]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">save</code> and <code class="language-plaintext highlighter-rouge">remove</code> will perform some actions without returning any actual value: <code class="language-plaintext highlighter-rouge">F[Unit]</code>.</li>
</ul>

<p>Everything is clear and you might have seen this kind of pattern before, so let’s create an interpreter for it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">doobie.implicits._</span>
<span class="k">import</span> <span class="nn">doobie.util.transactor.Transactor</span>
<span class="k">import</span> <span class="nn">cats.effect.Sync</span>

<span class="c1">// Doobie implementation (not fully implemented, what matters here are the types).
</span><span class="k">class</span> <span class="nc">PostgreSQLItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                    <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">findAll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select name, price from items"</span>
                                           <span class="o">.</span><span class="py">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
                                           <span class="o">.</span><span class="py">to</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span>
                                           <span class="o">.</span><span class="py">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">unit</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">unit</span>
<span class="o">}</span>

</code></pre></div></div>

<p>Here we are using <a href="http://tpolecat.github.io/doobie/">Doobie</a>, defined as <code class="language-plaintext highlighter-rouge">A principled JDBC layer for Scala</code> and one of the most popular DB libraries in the Typelevel ecosystem. And it comes with one super powerful feature: it supports <code class="language-plaintext highlighter-rouge">Streaming</code> results, since it’s built on top of <a href="https://functional-streams-for-scala.github.io/fs2/">fs2</a>.</p>

<p>Now it could be very common to have a huge amount of <code class="language-plaintext highlighter-rouge">Item</code>s in our DB that a <code class="language-plaintext highlighter-rouge">List</code> will not fit into memory and / or it will be a very expensive operation. So we might want to stream the results of <code class="language-plaintext highlighter-rouge">findAll</code> instead of have them all in memory on a <code class="language-plaintext highlighter-rouge">List</code>, making <code class="language-plaintext highlighter-rouge">Doobie</code> a great candidate for the job. But wait… We have a problem now. Our <code class="language-plaintext highlighter-rouge">ItemRepository</code> algebra has fixed the definition of <code class="language-plaintext highlighter-rouge">findAll</code> as <code class="language-plaintext highlighter-rouge">F[List[Item]]</code> so we won’t be able to create an interpreter that returns a streaming result instead.</p>

<h3 id="rethinking-our-algebra">Rethinking our algebra</h3>

<p>We should think about abstracting over that <code class="language-plaintext highlighter-rouge">List</code> and two of the most common abstractions that immediately come to mind are <code class="language-plaintext highlighter-rouge">Foldable</code> and <code class="language-plaintext highlighter-rouge">Traverse</code>. But although these typeclasses are very useful, they are not enough to represent a stream of values, so we should come up with a better abstraction.</p>

<p>Well, it seems that our options are either adding another higher-kinded parameter <code class="language-plaintext highlighter-rouge">G[_]</code> to our algebra or just define an abstract member <code class="language-plaintext highlighter-rouge">G[_]</code>. So let’s go with the first one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">findAll</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Great! This looks good so far.</p>

<h3 id="streaming-support-interpreter">Streaming support interpreter</h3>

<p>Now let’s write a new <code class="language-plaintext highlighter-rouge">PostgreSQL</code> interpreter with streaming support:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">doobie.implicits._</span>
<span class="k">import</span> <span class="nn">doobie.util.transactor.Transactor</span>
<span class="k">import</span> <span class="nn">fs2.Stream</span>

<span class="c1">// Doobie implementation (not fully implemented, what matters here are the types).
</span><span class="k">class</span> <span class="nc">StreamingItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                   <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">findAll</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select name, price from items"</span>
                                           <span class="o">.</span><span class="py">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
                                           <span class="o">.</span><span class="py">stream</span>
                                           <span class="o">.</span><span class="py">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">delay</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Saving item: $item"</span><span class="o">))</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">delay</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Removing item: $item"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Voilà! We got our streaming implementation of <code class="language-plaintext highlighter-rouge">findAll</code>.</p>

<h3 id="test-interpreter">Test interpreter</h3>

<p>That’s all we wanted, but what about testing it? Sure, we might prefer to have a simple implementation by just using a plain <code class="language-plaintext highlighter-rouge">List</code>, so what can we possibly do?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">MemRepository</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="nv">mem</span> <span class="k">=</span> <span class="nv">MutableMap</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Item</span><span class="o">]</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">findAll</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="nv">mem</span><span class="o">.</span><span class="py">headOption</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">_2</span><span class="o">).</span><span class="py">toList</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">mem</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="nv">name</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">mem</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="nv">item</span><span class="o">.</span><span class="py">name</span><span class="o">.</span><span class="py">value</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nv">mem</span><span class="o">.</span><span class="py">remove</span><span class="o">(</span><span class="nv">name</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
    <span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s pretty much it! We managed to abstract over the return type of <code class="language-plaintext highlighter-rouge">findAll</code> by just adding an extra parameter to our algebra.</p>

<h3 id="about-composition">About composition</h3>

<p>At this point the avid reader might have thought, what if I want to write a generic function that takes all the items (using <code class="language-plaintext highlighter-rouge">findAll</code>), applies some discounts and writes them back to the DB (using <code class="language-plaintext highlighter-rouge">save</code>)?</p>

<p>Short answer is, you might want to define a different algebra where <code class="language-plaintext highlighter-rouge">findAll</code> and <code class="language-plaintext highlighter-rouge">save</code> have the same types (eg: both of them are streams) but in case you find yourself wanting to make this work with the current types then let’s try and find out!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">],</span> <span class="n">join</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">discount</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">items</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="nv">repo</span><span class="o">.</span><span class="py">findAll</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">item</span> <span class="k">=&gt;</span> <span class="nv">item</span><span class="o">.</span><span class="py">copy</span><span class="o">(</span><span class="n">price</span> <span class="k">=</span> <span class="nv">item</span><span class="o">.</span><span class="py">price</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">discount</span><span class="o">)))</span>
    <span class="k">val</span> <span class="nv">saved</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">items</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">repo</span><span class="o">.</span><span class="py">save</span><span class="o">)</span>
    <span class="nf">join</span><span class="o">(</span><span class="n">saved</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We defined a <code class="language-plaintext highlighter-rouge">join</code> function responsible for evaluating the effects and flatten the result to <code class="language-plaintext highlighter-rouge">F[Unit]</code>. As you can see below, this works for both a streaming interpreter and a list interpreter (shout out to <a href="https://github.com/fthomas">fthomas</a> for proposing this solution):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">StreamingDiscountInterpreter</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="nv">join</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">_</span><span class="o">.</span><span class="py">evalMap</span><span class="o">(</span><span class="n">identity</span><span class="o">).</span><span class="py">compile</span><span class="o">.</span><span class="py">drain</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]](</span><span class="n">repo</span><span class="o">,</span> <span class="n">join</span><span class="o">)</span>

<span class="o">}</span>

<span class="k">object</span> <span class="nc">ListDiscountInterpreter</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="nv">join</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">list</span> <span class="k">=&gt;</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">sequence</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="py">void</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">])</span><span class="k">:</span> <span class="kt">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">](</span><span class="n">repo</span><span class="o">,</span> <span class="n">join</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>While in this case it was possible to make it generic I don’t recommend to do this at home because:</p>

<ol>
  <li>it involves some extra boilerplate and the code becomes harder to understand / maintain.</li>
  <li>as soon as the logic gets more complicated you might run out of options to make it work in a generic way.</li>
  <li>you lose the ability to use the <code class="language-plaintext highlighter-rouge">fs2 DSL</code> which is super convenient.</li>
</ol>

<p>What I recommend instead, is to write this kind of logic in the streaming interpreter itself. You could also write a generic program that implements the parts that can be abstracted (eg. applying a discount to an item <code class="language-plaintext highlighter-rouge">f: Item =&gt; Item</code>) and leave the other parts to the interpreter.</p>

<h3 id="design-alternative">Design alternative</h3>

<p>Another possible and very interesting alternative suggested by <a href="https://github.com/mpilquist">Michael Pilquist</a>, would be to define our repository as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">findAll</span><span class="k">:</span> <span class="kt">S</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Item</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Where the second type parameter matches the shape of <code class="language-plaintext highlighter-rouge">fs2.Stream</code>. In this case our streaming repository will remain the same (it should just extend <code class="language-plaintext highlighter-rouge">ItemRepository[F, Stream]</code> instead of <code class="language-plaintext highlighter-rouge">ItemRepository[F, Stream[F, ?]]</code>) but our in memory interpreter will now rely on <code class="language-plaintext highlighter-rouge">fs2.Stream</code> instead of a parametric <code class="language-plaintext highlighter-rouge">G[_]</code>, for example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">MemRepositoryAlt</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Stream</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">findAll</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">sql</span><span class="s">"select name, price from items"</span>
      <span class="o">.</span><span class="py">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
      <span class="o">.</span><span class="py">stream</span>
      <span class="o">.</span><span class="py">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>I think it’s an alternative worth exploring further that might require a blog post on its own, so I’ll leave it here for reference :)</p>

<h3 id="source-of-inspiration">Source of inspiration</h3>

<p>I’ve come up with most of the ideas presented here during my work on <a href="https://gvolpe.github.io/fs2-rabbit/">Fs2 Rabbit</a>, a stream based client for <code class="language-plaintext highlighter-rouge">Rabbit MQ</code>, where I make heavy use of this technique as I originally described in <a href="https://partialflow.wordpress.com/2018/02/01/a-tale-of-tagless-final-cats-effect-and-streaming-fs2-rabbit-v0-1/">this blog post</a>.</p>

<p>Another great source of inspiration was <a href="https://www.youtube.com/watch?v=1h11efA4k8E">this talk</a> given by <a href="https://github.com/LukaJCB">Luka Jacobowitz</a> at Scale by the Bay.</p>

<h3 id="abstracting-over-the-effect-type">Abstracting over the effect type</h3>

<p>One thing you might have noticed in the examples above is that both <code class="language-plaintext highlighter-rouge">ItemRepository</code> interpreters are not fixed to <code class="language-plaintext highlighter-rouge">IO</code> or <code class="language-plaintext highlighter-rouge">Task</code> or any other effect type but rather requiring a parametric <code class="language-plaintext highlighter-rouge">F[_]</code> and an implicit instance of <code class="language-plaintext highlighter-rouge">Sync[F]</code>. This is a quite powerful technique for both library authors and application developers. Well know libraries such as <a href="https://http4s.org/">Http4s</a>, <a href="https://monix.io/">Monix</a> and <a href="https://functional-streams-for-scala.github.io/fs2/">Fs2</a> make a heavy use of it.</p>

<p>And by requiring a <code class="language-plaintext highlighter-rouge">Sync[F]</code> instance we are just saying that our implementation will need to suspend synchronous side effects.</p>

<p>Once at the edge of our program, commonly the main method, we can give <code class="language-plaintext highlighter-rouge">F[_]</code> a concrete type. At the moment, there are two options: <code class="language-plaintext highlighter-rouge">cats.effect.IO</code> and <code class="language-plaintext highlighter-rouge">monix.eval.Task</code>. But hopefully soon we’ll have a <code class="language-plaintext highlighter-rouge">Scalaz 8 IO</code> implementation as well (fingers crossed).</p>

<h3 id="principle-of-least-power">Principle of least power</h3>

<p>Abstracting over the effect type doesn’t only mean that we should require <code class="language-plaintext highlighter-rouge">Sync[F]</code>, <code class="language-plaintext highlighter-rouge">Async[F]</code> or <code class="language-plaintext highlighter-rouge">Effect[F]</code>. It also means that we should only require the minimal typeclass instance that satisfies our predicate. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Functor</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="nf">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">fa</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
</code></pre></div></div>

<p>Here our <code class="language-plaintext highlighter-rouge">bar</code> method just returns a pure value in the <code class="language-plaintext highlighter-rouge">F</code> context, thus we need an <code class="language-plaintext highlighter-rouge">Applicative[F]</code> instance that defines <code class="language-plaintext highlighter-rouge">pure</code>. On the other hand, our <code class="language-plaintext highlighter-rouge">foo</code> method just converts the inner <code class="language-plaintext highlighter-rouge">Int</code> into <code class="language-plaintext highlighter-rouge">String</code>, what we call a pure data transformation. So all we need here is a <code class="language-plaintext highlighter-rouge">Functor[F]</code> instance. Another example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>

<span class="k">def</span> <span class="nf">fp</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="o">`</span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>The above implementation makes use of a <code class="language-plaintext highlighter-rouge">for-comprehension</code> which is a syntactic sugar for <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">map</code>, so all we need is a <code class="language-plaintext highlighter-rouge">Monad[F]</code> instance because we also need an <code class="language-plaintext highlighter-rouge">Applicative[F]</code> instance for <code class="language-plaintext highlighter-rouge">bar</code>, otherwise we could just use a <code class="language-plaintext highlighter-rouge">FlatMap[F]</code> instance.</p>

<h3 id="final-thoughts">Final thoughts</h3>

<p>I think we got quite far with all these abstractions, giving us the chance to write clean and elegant code in a pure functional programming style, and there’s even more! Other topics worth mentioning that might require a blog post on their own are:</p>

<ul>
  <li>Dependency Injection
    <ul>
      <li>Tagless Final + implicits (MTL style) enables DI in an elegant way.</li>
    </ul>
  </li>
  <li>Algebras Composition
    <ul>
      <li>It is very common to have multiple algebras with a different <code class="language-plaintext highlighter-rouge">F[_]</code> implementation. In some cases, <code class="language-plaintext highlighter-rouge">FunctionK</code> (a.k.a. natural transformation) can be the solution.</li>
    </ul>
  </li>
</ul>

<p>What do you think about it? Have you come across a similar design problem? I’d love to hear your thoughts!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/05/09/tagless-final-streaming.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/05/09/tagless-final-streaming.html</guid>
      </item>
    
      <item>
        <title>Product with Serializable</title>
        
          <dc:creator>ceedubs</dc:creator>
                
        <description><![CDATA[<p>A somewhat common Scala idiom is to make an <code class="language-plaintext highlighter-rouge">abstract</code> type extend <code class="language-plaintext highlighter-rouge">Product with Serializable</code>. There isn’t an obvious reason to do this, and people have asked me a number of times why I’ve done this. While I don’t think that <code class="language-plaintext highlighter-rouge">Product</code> or <code class="language-plaintext highlighter-rouge">Serializable</code> are particularly good abstractions, there’s a reason that I extend them.</p>

<p>Let’s say that I’m writing a simple enum-like <code class="language-plaintext highlighter-rouge">Status</code> type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">EnumExample1</span> <span class="o">{</span>
  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Pending</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">InProgress</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Finished</span> <span class="k">extends</span> <span class="nc">Status</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let’s create a <code class="language-plaintext highlighter-rouge">Set</code> of statuses that represent incomplete items:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">EnumExample1._</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">incomplete</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="nc">Pending</span><span class="o">,</span> <span class="nc">InProgress</span><span class="o">)</span>
<span class="c1">// incomplete: scala.collection.immutable.Set[Product with Serializable with EnumExample1.Status] = Set(Pending, InProgress)
</span></code></pre></div></div>

<p>Here, I didn’t give in explicit return type to <code class="language-plaintext highlighter-rouge">incomplete</code> and you may have noticed that the compiler inferred a somewhat bizarre one: <code class="language-plaintext highlighter-rouge">Set[Product with Serializable with Status]</code>. Why is that?</p>

<p>The compiler generally tries to infer the most specific type possible. Usually this makes sense. If you write <code class="language-plaintext highlighter-rouge">val x = 3</code> you probably don’t want it to infer <code class="language-plaintext highlighter-rouge">val x: Any = 3</code>. And in the example above, I didn’t want the return type for <code class="language-plaintext highlighter-rouge">incomplete</code> to be inferred as <code class="language-plaintext highlighter-rouge">Any</code> or even <code class="language-plaintext highlighter-rouge">Set[Any]</code>. However, the compiler was a bit <em>too</em> clever and realized that not only is every item in the set an instance of <code class="language-plaintext highlighter-rouge">Status</code>, they are also instances of <code class="language-plaintext highlighter-rouge">Product</code> and <code class="language-plaintext highlighter-rouge">Serializable</code> since every <code class="language-plaintext highlighter-rouge">case object</code> (and <code class="language-plaintext highlighter-rouge">case class</code>) automatically extends <code class="language-plaintext highlighter-rouge">Product</code> and <code class="language-plaintext highlighter-rouge">Serializable</code>. Therefore, when it calculates the least upper bound (LUB) of the types in the set, it comes up with <code class="language-plaintext highlighter-rouge">Product with Serializable with Status</code>.</p>

<p>While there’s nothing inherently wrong with the return type of <code class="language-plaintext highlighter-rouge">Product with Serializable with Status</code>, it is verbose, it wasn’t what I intended, and in certain situations it might cause inference issues. Luckily there’s a simple workaround to get the inferred type that I want:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">EnumExample2</span> <span class="o">{</span>
  <span class="c1">// note the `extends` addition here
</span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Status</span> <span class="k">extends</span> <span class="nc">Product</span> <span class="k">with</span> <span class="nc">Serializable</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Pending</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">InProgress</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Finished</span> <span class="k">extends</span> <span class="nc">Status</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">EnumExample2._</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">incomplete</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="nc">Pending</span><span class="o">,</span> <span class="nc">InProgress</span><span class="o">)</span>
<span class="c1">// incomplete: scala.collection.immutable.Set[EnumExample2.Status] = Set(Pending, InProgress)
</span></code></pre></div></div>

<p>Now since <code class="language-plaintext highlighter-rouge">Status</code> itself already includes <code class="language-plaintext highlighter-rouge">Product</code> and <code class="language-plaintext highlighter-rouge">Serializable</code>, <code class="language-plaintext highlighter-rouge">Status</code> is the LUB type of <code class="language-plaintext highlighter-rouge">Pending</code>, <code class="language-plaintext highlighter-rouge">InProgress</code>, and <code class="language-plaintext highlighter-rouge">Finished</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/05/09/product-with-serializable.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/05/09/product-with-serializable.html</guid>
      </item>
    
      <item>
        <title>Rethinking MonadError</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p><code class="language-plaintext highlighter-rouge">MonadError</code> is a very old type class, hackage shows me it was originally added in 2001, long before I had ever begun doing functional programming, just check the <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error-Class.html">hackage page</a>.
In this blog post I’d like to rethink the way we use <code class="language-plaintext highlighter-rouge">MonadError</code> today.
It’s usually used to signal that a type might be capable of error handling and is basically like a type class encoding of <code class="language-plaintext highlighter-rouge">Either</code>s ability to short circuit.
That makes it pretty useful for building computations from sequences of values that may fail and then halt the computation or to catch those errors in order to resume the computation.
It’s also parametrized by its error type, making it one of the most common example of multi-parameter type classes.
Some very common instances include <code class="language-plaintext highlighter-rouge">Either</code> and <code class="language-plaintext highlighter-rouge">IO</code>, but there are a ton more.</p>

<p>We can divide instances into 3 loosely defined groups:</p>

<p>First we have simple data types like <code class="language-plaintext highlighter-rouge">Either</code>, <code class="language-plaintext highlighter-rouge">Option</code> or <code class="language-plaintext highlighter-rouge">Ior</code> (with <code class="language-plaintext highlighter-rouge">Validated</code> not having a <code class="language-plaintext highlighter-rouge">Monad</code> instance).</p>

<p>Secondly we’ve got the <code class="language-plaintext highlighter-rouge">IO</code>-like types, the various <code class="language-plaintext highlighter-rouge">IO</code>s, <code class="language-plaintext highlighter-rouge">Task</code>s and the like. These are used to suspend side effects which might have errors and therefore need to be able to handle these.</p>

<p>Thirdly and least importantly, we have monad transformers, which get their instances from their respective underlying monads. Since they basically just propagate their underlying instances we’re only going to talk about the first two groups for now.</p>

<p>The simple data types all define <code class="language-plaintext highlighter-rouge">MonadError</code> instances, but I wager they’re not actually used as much. This is because <code class="language-plaintext highlighter-rouge">MonadError</code> doesn’t actually allow us to deconstruct e.g. an <code class="language-plaintext highlighter-rouge">Either</code> to actually handle the errors. We’ll see more on that later, next let’s look at the <code class="language-plaintext highlighter-rouge">IO</code>-like types and their instances.</p>

<p><code class="language-plaintext highlighter-rouge">cats.effect.IO</code> currently defines a <code class="language-plaintext highlighter-rouge">MonadError[IO, Throwable]</code>, meaning that it’s fully able to raise and catch errors that might be thrown during evaluation of encapsulated side effects.
Using <code class="language-plaintext highlighter-rouge">MonadError</code> with these effect types seems a lot more sensical at first, as you can’t escape <code class="language-plaintext highlighter-rouge">IO</code> even when you handle errors, so it looks like it makes sense to stay within <code class="language-plaintext highlighter-rouge">IO</code> due to the side effect capture.</p>

<p>The problem I see with <code class="language-plaintext highlighter-rouge">MonadError</code> is that it does not address the fundamental difference between these two types of instances. I can pattern match an <code class="language-plaintext highlighter-rouge">Option[A]</code> with a default value to get back an <code class="language-plaintext highlighter-rouge">A</code>. With <code class="language-plaintext highlighter-rouge">IO</code> that is just not possible. So these two groups of types are pretty different, when does it actually make sense to abstract over both of them?
Well, it turns out there a few instances where it might be useful, but as we’ll see later, I’m proposing something that will be equally useful to both groups.</p>

<p>Now before we continue, let’s look at the <code class="language-plaintext highlighter-rouge">MonadError</code> type class in a bit more detail.
<code class="language-plaintext highlighter-rouge">MonadError</code> currently comprises two parts, throwing and catching errors.
To begin let’s have a look at the <code class="language-plaintext highlighter-rouge">throw</code> part, sometimes also called <code class="language-plaintext highlighter-rouge">MonadThrow</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks fine for now, but one thing that strikes me is that the <code class="language-plaintext highlighter-rouge">F</code> type seems to “swallow” errors.
If we look at <code class="language-plaintext highlighter-rouge">F[A]</code> we have no clue that it might actually yield an error of type <code class="language-plaintext highlighter-rouge">E</code>, that fact is not required to be represented at all.
However, that’s not a really big issue, so now let’s look at the <code class="language-plaintext highlighter-rouge">catch</code> part:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MonadThrow</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Immediately I have a few questions, if the errors are handled, why does it return the exact same type?
Furthermore if this is really supposed to handle errors, what happens if I have errors in the <code class="language-plaintext highlighter-rouge">E =&gt; F[A]</code> function? 
This is even more blatant in the <code class="language-plaintext highlighter-rouge">attempt</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">attempt</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here there is no way the outer <code class="language-plaintext highlighter-rouge">F</code> still has any errors, so why does it have the same type?
Shouldn’t we represent the fact that we handled all the errors in the type system?
This means you can’t actually observe that the errors are now inside <code class="language-plaintext highlighter-rouge">Either</code>. That leads to this being fully legal code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="nc">Option</span><span class="o">(</span><span class="mi">42</span><span class="o">).</span><span class="py">attempt</span><span class="o">.</span><span class="py">attempt</span><span class="o">.</span><span class="py">attempt</span><span class="o">.</span><span class="py">attempt</span>
<span class="c1">// res0: Option[Either[Unit,Either[Unit,Either[Unit,Either[Unit,Int]]]]] = Some(Right(Right(Right(Right(42)))))
</span></code></pre></div></div>

<p>Another example that demonstrates this is the fact that calling <code class="language-plaintext highlighter-rouge">handleError</code>, which looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handleError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>
<p>also returns an <code class="language-plaintext highlighter-rouge">F[A]</code>. This method takes a pure function <code class="language-plaintext highlighter-rouge">E =&gt; A</code> and thus can not fail during recovery like <code class="language-plaintext highlighter-rouge">handleErrorWith</code>, yet it still doesn’t give us any sign that it doesn’t throw errors.
For <code class="language-plaintext highlighter-rouge">IO</code>-like types this is somewhat excusable as something like an unexceptional <code class="language-plaintext highlighter-rouge">IO</code> is still very uncommon, but for simple data types like <code class="language-plaintext highlighter-rouge">Either</code> or <code class="language-plaintext highlighter-rouge">Some</code> that function should just return an <code class="language-plaintext highlighter-rouge">A</code>, since that’s the only thing it can be.
Just like with <code class="language-plaintext highlighter-rouge">attempt</code>, we can infinitely chain calls to <code class="language-plaintext highlighter-rouge">handleError</code>, as it will never change the type.</p>

<p>Ideally our type system should stop us from being able to write this nonsensical code and give us a way to show anyone reading the code that we’ve already handled errors.
Now I’m not saying that the functions on <code class="language-plaintext highlighter-rouge">MonadError</code> aren’t useful, but only that they could be more constrained and thus more accurate in their representation.</p>

<p>For this purpose let’s try to write a different <code class="language-plaintext highlighter-rouge">MonadError</code> type class, one that’s designed to leverage the type system to show when values are error-free, we’ll call it <code class="language-plaintext highlighter-rouge">MonadBlunder</code> for now.</p>

<p>To mitigate the problems with <code class="language-plaintext highlighter-rouge">MonadError</code> we have a few options, the first one I’d like to present is using two different type constructors to represent types that might fail and types that are guaranteed not to. So instead of only a single type constructor our <code class="language-plaintext highlighter-rouge">MonadBlunder</code> class will have two:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
</code></pre></div></div>

<p>Our type class now has the shape <code class="language-plaintext highlighter-rouge">(* -&gt; *) -&gt; (* -&gt; *) -&gt; * -&gt; *</code>, which is quite a handful, but I believe we can justify its usefulness.
The first type parameter <code class="language-plaintext highlighter-rouge">F[_]</code> will represent our error-handling type, which will be able to yield values of type <code class="language-plaintext highlighter-rouge">E</code>.
The second type parameter <code class="language-plaintext highlighter-rouge">G[_]</code> will represent a corresponding type that does not allow any errors and can therefore guarantee that computations of the form <code class="language-plaintext highlighter-rouge">G[A]</code> will always yield a value of type <code class="language-plaintext highlighter-rouge">A</code>.</p>

<p>Now that we figured out the shape, let’s see what we can actually do with it.
For throwing errors, we’ll create a <code class="language-plaintext highlighter-rouge">raiseError</code> function that should return a value inside <code class="language-plaintext highlighter-rouge">F</code>, as it will obviously be able to yield an error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This definition looks identical to the one defined one <code class="language-plaintext highlighter-rouge">MonadError</code> so let’s move on to error-handling.
For handled errors, we want to return a value inside <code class="language-plaintext highlighter-rouge">G</code>, so our <code class="language-plaintext highlighter-rouge">handleErrorWith</code> function should indeed return a <code class="language-plaintext highlighter-rouge">G[A]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Looks good so far, right? 
Well, we still have the problem that <code class="language-plaintext highlighter-rouge">f</code> might return an erronous value, so if we want to guarantee that the result won’t have any errors, we’ll have to change that to <code class="language-plaintext highlighter-rouge">G[A]</code> as well:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And now we’re off to a pretty good start, we fixed one short coming of <code class="language-plaintext highlighter-rouge">MonadError</code> with this approach.</p>

<p>Another approach, maybe more obvious to some, might be to require the type constructor to take two arguments, one for the value and one for the error type.
Let’s see if we can define <code class="language-plaintext highlighter-rouge">raiseError</code> on top of it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">raiseError</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span>

  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks pretty similar to what we already have, though now we have the guarantee that our type doesn’t actually “hide” the error-type somewhere.
Next up is <code class="language-plaintext highlighter-rouge">handleErrorWith</code>. Ideally after we handled the error we should again get back a type that signals that it doesn’t have any errors. 
We can do exactly that by choosing an unhabited type like <code class="language-plaintext highlighter-rouge">Nothing</code> as our error-type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">handleErrorWith</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And this approach works as well, however now we’ve forced the two type parameter shape onto implementors. This <code class="language-plaintext highlighter-rouge">MonadBlunder</code> has the following kind <code class="language-plaintext highlighter-rouge">(* -&gt; * -&gt; *) -&gt; *</code>.
This means we can very easily define instances for types with two type parameters like <code class="language-plaintext highlighter-rouge">Either</code>.
However, one issue might be that it’s much easier to fit a type with two type parameters onto a type class that expects a single type constructor <code class="language-plaintext highlighter-rouge">(* -&gt; *)</code> than to do it the other way around.</p>

<p>For example try to implement the above <code class="language-plaintext highlighter-rouge">MonadBlunder[F[_, _]]</code> for the standard <code class="language-plaintext highlighter-rouge">cats.effect.IO</code>.
It’s not going to be simple, whereas with the first encoding we can easily encode both <code class="language-plaintext highlighter-rouge">Either</code> and <code class="language-plaintext highlighter-rouge">IO</code>. For this reason, I will continue this article with the first encoding using the two different type constructors.</p>

<p>Next we’re going to look at laws we can define to make sense of the behaviour we want.
The first two laws should be fairly obvious. 
If we <code class="language-plaintext highlighter-rouge">flatMap</code> over a value created by <code class="language-plaintext highlighter-rouge">raiseError</code> it shouldn’t propogate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">raiseErrorStops</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>Next we’re going to formulate a law that states, that raising an error and then immediatly handling it with a given function should be equivalent to just calling that function on the error value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">raiseErrorHandleErrorWith</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">).</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="nf">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>Another law could state that handling errors for a pure value lifted into the <code class="language-plaintext highlighter-rouge">F</code> context does nothing and is equal to the pure value in the <code class="language-plaintext highlighter-rouge">G</code> context:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">handleErrorPureIsPure</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nv">a</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="nv">a</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
</code></pre></div></div>

<p>Those should be good for now, but we’ll be able to find more when we add more derived functions to our type class.
Also note that none of the laws are set in stone, these are just the ones I came up with for now, it’s completely possible that we’ll need to revise these in the future.</p>

<p>Now let’s focus on adding extra functions to our type class. <code class="language-plaintext highlighter-rouge">MonadError</code> offer us a bunch of derived methods that can be really useful. For most of those however we need access to methods like <code class="language-plaintext highlighter-rouge">flatMap</code> for both <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">G</code>, so before we figure out derived combinators, let’s revisit how exactly we define the type class.</p>

<p>The easiest would be to give both <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">G</code> a <code class="language-plaintext highlighter-rouge">Monad</code> constraint and move on. 
But then we’d have two type classes that both define a <code class="language-plaintext highlighter-rouge">raiseError</code> function extends <code class="language-plaintext highlighter-rouge">Monad</code>, and we wouldn’t be able to use them together, since that would cause ambiguities and as I’ve said before, the functions on <code class="language-plaintext highlighter-rouge">MonadError</code> are useful in some cases.</p>

<p>Instead, since I don’t really like duplication and the fact that we’re not going to deprecate <code class="language-plaintext highlighter-rouge">MonadError</code> overnight, I decided to extend <code class="language-plaintext highlighter-rouge">MonadBlunder</code> from <code class="language-plaintext highlighter-rouge">MonadError</code> for the <code class="language-plaintext highlighter-rouge">F</code> type, to get access to the <code class="language-plaintext highlighter-rouge">raiseError</code> function.
If <code class="language-plaintext highlighter-rouge">raiseError</code> and <code class="language-plaintext highlighter-rouge">handleErrorWith</code> were instead separated into separate type classes (as is currently the case in the PureScript prelude), we could extend only the <code class="language-plaintext highlighter-rouge">raiseError</code> part.
This also allows us to define laws that our counterparts of functions like <code class="language-plaintext highlighter-rouge">attempt</code> and <code class="language-plaintext highlighter-rouge">ensure</code> are consistent with the ones defined on <code class="language-plaintext highlighter-rouge">MonadError</code>.
So the type signature now looks like this (expressed in Haskell, since it’s easier on the eyes):</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="p">(</span><span class="kt">MonadError</span> <span class="n">f</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">MonadBlunder</span> <span class="n">f</span> <span class="n">g</span> <span class="n">e</span> <span class="o">|</span><span class="err"> </span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="kr">where</span>
  <span class="o">...</span>
</code></pre></div></div>

<p>In Scala, we can’t express this as nicely, so we’re going to have to use something close to the <code class="language-plaintext highlighter-rouge">cats-mtl</code> encoding:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="nv">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
  
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now since this means that any instance of <code class="language-plaintext highlighter-rouge">MonadBlunder</code> will also have an instance of <code class="language-plaintext highlighter-rouge">MonadError</code> on <code class="language-plaintext highlighter-rouge">F</code>, we might want to rename the functions we’ve got so far.
Here’s a complete definition of what we’ve come up with with <code class="language-plaintext highlighter-rouge">raiseError</code> removed and <code class="language-plaintext highlighter-rouge">handleErrorWith</code> renamed to <code class="language-plaintext highlighter-rouge">handleBlunderWith</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="nv">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let us go back to defining more derived functions for <code class="language-plaintext highlighter-rouge">MonadBlunder</code>.
The easiest probably being <code class="language-plaintext highlighter-rouge">handleError</code>, so let’s see if we can come up with a good alternative:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">handleBlunder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nf">handleBlunderWith</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span> <span class="nf">andThen</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">G</span><span class="o">]))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This one is almost exactly like <code class="language-plaintext highlighter-rouge">handleBlunderWith</code>, but takes a function from <code class="language-plaintext highlighter-rouge">E</code> to <code class="language-plaintext highlighter-rouge">A</code> instead of to <code class="language-plaintext highlighter-rouge">G[A]</code>. We can easily reuse <code class="language-plaintext highlighter-rouge">handleBlunderWith</code> by using <code class="language-plaintext highlighter-rouge">pure</code> to go back to <code class="language-plaintext highlighter-rouge">E =&gt; G[A]</code>.</p>

<p>Next another function that’s really useful is <code class="language-plaintext highlighter-rouge">attempt</code>.
Our alternative, let’s call it <code class="language-plaintext highlighter-rouge">endeavor</code> for now, should return a value in <code class="language-plaintext highlighter-rouge">G</code> instead, which doesn’t have a <code class="language-plaintext highlighter-rouge">MonadError</code> instance and therefore can not make any additional calls to <code class="language-plaintext highlighter-rouge">endeavor</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">endeavor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nf">handleBlunder</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)))(</span><span class="nc">Left</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The implementation is fairly straightforward as well, we just handle all the errors by lifting them into the left side of an <code class="language-plaintext highlighter-rouge">Either</code> and map successful values to the right side of <code class="language-plaintext highlighter-rouge">Either</code>.</p>

<p>Next, let’s look at the dual to <code class="language-plaintext highlighter-rouge">attempt</code>, called <code class="language-plaintext highlighter-rouge">rethrow</code> in Cats. 
For <code class="language-plaintext highlighter-rouge">MonadError</code> it turns an <code class="language-plaintext highlighter-rouge">F[Either[E, A]]</code> back into an <code class="language-plaintext highlighter-rouge">F</code>, but we’re going to use our unexceptional type again:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">absolve</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But looking at this signature, we quickly realize that we need a way to get back to <code class="language-plaintext highlighter-rouge">F[A]</code> from <code class="language-plaintext highlighter-rouge">G[A]</code>.
So we’re going to add another function to our minimal definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="nv">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="o">}</span>
</code></pre></div></div>

<p>This function <code class="language-plaintext highlighter-rouge">accept</code>, allows us to lift any value without errors into a context where errors might be present.</p>

<p>We can now formulate a law that values in <code class="language-plaintext highlighter-rouge">G</code> never stop propagating, so <code class="language-plaintext highlighter-rouge">flatMap</code> should always work, we do this by specifying that calling <code class="language-plaintext highlighter-rouge">handleBlunder</code> after calling <code class="language-plaintext highlighter-rouge">accept</code> on any <code class="language-plaintext highlighter-rouge">G[A]</code>, is never going to actually change the value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gNeverHasErrors</span><span class="o">(</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nf">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">).</span><span class="py">handleBlunder</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">ga</span>
</code></pre></div></div>

<p>Now we can go back to implementing the <code class="language-plaintext highlighter-rouge">absolve</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">absolve</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">gea</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">accept</span><span class="o">(</span><span class="n">gea</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="nv">_</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]))</span>
</code></pre></div></div>

<p>Now that we’ve got the equivalent of both <code class="language-plaintext highlighter-rouge">attempt</code> and <code class="language-plaintext highlighter-rouge">rethrow</code>, let’s add a law that states that the two should cancel each other out:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">endeavorAbsolve</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nf">absolve</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">endeavor</span><span class="o">)</span> <span class="o">===</span> <span class="n">fa</span>
</code></pre></div></div>

<p>We can also add laws so that <code class="language-plaintext highlighter-rouge">handleBlunder</code> and <code class="language-plaintext highlighter-rouge">endeavor</code> are consistent with their counterparts now that we have <code class="language-plaintext highlighter-rouge">accept</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">deriveHandleError</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nf">accept</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">handleBlunder</span><span class="o">(</span><span class="n">f</span><span class="o">))</span> <span class="o">===</span> <span class="nv">fa</span><span class="o">.</span><span class="py">handleError</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">deriveAttempt</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nf">accept</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">endeavor</span><span class="o">)</span> <span class="o">===</span> <span class="nv">fa</span><span class="o">.</span><span class="py">attempt</span>
</code></pre></div></div>

<p>One nice thing about <code class="language-plaintext highlighter-rouge">attempt</code>, is that it’s really easy to add a derivative combinator that doesn’t go to <code class="language-plaintext highlighter-rouge">F[Either[E, A]]</code>, but to the isomorphic monad transformer <code class="language-plaintext highlighter-rouge">EitherT[F, E, A]</code>.
We can do the exact same thing with <code class="language-plaintext highlighter-rouge">endeavor</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">endeavorT</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">EitherT</span><span class="o">(</span><span class="nf">endeavor</span><span class="o">(</span><span class="n">fa</span><span class="o">))</span>
</code></pre></div></div>

<p>One last combinator I’d like to “port” from <code class="language-plaintext highlighter-rouge">MonadError</code> is the <code class="language-plaintext highlighter-rouge">ensureOr</code> function.
<code class="language-plaintext highlighter-rouge">ensureOr</code> turns a successful value into an error if it does not satisfy a given predicate.
We’re going to name the counterpart <code class="language-plaintext highlighter-rouge">assureOr</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">assureOr</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">error</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">E</span><span class="o">)(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nf">predicate</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="nv">a</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">else</span> <span class="nf">raiseError</span><span class="o">(</span><span class="nf">error</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
  <span class="o">)</span>
</code></pre></div></div>

<p>This plays nicely with the rest of our combinators and we can again add a law that dictates it must be consistent with <code class="language-plaintext highlighter-rouge">ensureOr</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">deriveEnsureOr</span><span class="o">(</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">error</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">E</span><span class="o">)(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="nf">ensureOr</span><span class="o">(</span><span class="nf">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">))(</span><span class="n">error</span><span class="o">)(</span><span class="n">predicate</span><span class="o">)</span> <span class="o">===</span> <span class="nf">assureOr</span><span class="o">(</span><span class="n">ga</span><span class="o">)(</span><span class="n">error</span><span class="o">)(</span><span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>

<p>Now we have a great base to work with laws that should guarantee principled and sensible behaviour.
Next we’ll actually start defining some instances for our type class.</p>

<p>The easiest definitions are for <code class="language-plaintext highlighter-rouge">Either</code> and <code class="language-plaintext highlighter-rouge">Option</code>, though I’m not going to cover both, as the instances for <code class="language-plaintext highlighter-rouge">Option</code> can simply be derived by <code class="language-plaintext highlighter-rouge">Either[Unit, A]</code>and I’m going to link to the code at the end.
For <code class="language-plaintext highlighter-rouge">Either[E, A]</code>, when we handle all errors of type <code class="language-plaintext highlighter-rouge">E</code>, all we end up with is <code class="language-plaintext highlighter-rouge">A</code>, so the corresponding <code class="language-plaintext highlighter-rouge">G</code> type for our instance should be <code class="language-plaintext highlighter-rouge">Id</code>.
That leaves us with the following definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">monadBlunderEither</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Id</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Id</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
    <span class="k">val</span> <span class="nv">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">Id</span><span class="o">]</span>

    <span class="k">def</span> <span class="nf">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Right</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Fairly straightforward, as <code class="language-plaintext highlighter-rouge">Id[A]</code> is just <code class="language-plaintext highlighter-rouge">A</code>, but with this instance we can already see a small part of the power we gain over <code class="language-plaintext highlighter-rouge">MonadError</code>.
When we handle errors with <code class="language-plaintext highlighter-rouge">handleBlunder</code>, we’re no longer “stuck” inside the <code class="language-plaintext highlighter-rouge">Either</code> Monad, but instead have a guarantee that our value is free of errors.
Sometimes it’ll make sense to stay inside <code class="language-plaintext highlighter-rouge">Either</code>, but we can easily get back into <code class="language-plaintext highlighter-rouge">Either</code>, so we have full control over what we want to do.</p>

<p>Next up, we’ll look at <code class="language-plaintext highlighter-rouge">IO</code> and the type that inspired this whole blog post <code class="language-plaintext highlighter-rouge">UIO</code>.
<code class="language-plaintext highlighter-rouge">UIO</code> is equivalent to an <code class="language-plaintext highlighter-rouge">IO</code> type where all errors are handled and is short for “unexceptional IO”.
<code class="language-plaintext highlighter-rouge">UIO</code> currently lives inside my own <code class="language-plaintext highlighter-rouge">cats-uio</code> library, but if things go well, we might see it inside <code class="language-plaintext highlighter-rouge">cats-effect</code> eventually. This would also work for <code class="language-plaintext highlighter-rouge">IO</code> types who use two type parameters <code class="language-plaintext highlighter-rouge">IO[E, A]</code> where the first represents the error type and the second the actual value. There you’d choose <code class="language-plaintext highlighter-rouge">IO[E, A]</code> as the <code class="language-plaintext highlighter-rouge">F</code> type and <code class="language-plaintext highlighter-rouge">IO[Nothing, A]</code> as the <code class="language-plaintext highlighter-rouge">G</code> type. <code class="language-plaintext highlighter-rouge">IO[Nothing, A]</code> there is equivalent to <code class="language-plaintext highlighter-rouge">UIO[A]</code>.</p>

<p>As one might expect, you can not simply go from <code class="language-plaintext highlighter-rouge">IO[A]</code> to <code class="language-plaintext highlighter-rouge">UIO[A]</code>, but we’ll need to go from <code class="language-plaintext highlighter-rouge">IO[A]</code> to <code class="language-plaintext highlighter-rouge">UIO[Either[E, A]]</code> instead, which if you look at it, is exactly the definition of <code class="language-plaintext highlighter-rouge">endeavor</code>.
Now let’s have a look at how the <code class="language-plaintext highlighter-rouge">MonadBlunder</code> instance for <code class="language-plaintext highlighter-rouge">IO</code> and <code class="language-plaintext highlighter-rouge">UIO</code> looks:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">monadBlunderIO</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UIO</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UIO</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Throwable</span><span class="o">]</span>
    <span class="k">val</span> <span class="nv">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">UIO</span><span class="o">]</span>

    <span class="k">def</span> <span class="nf">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">UIO</span><span class="o">.</span><span class="py">unsafeFromIO</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="n">f</span> <span class="n">andThen</span> <span class="n">accept</span><span class="o">))</span>

    <span class="k">def</span> <span class="nf">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">UIO</span><span class="o">.</span><span class="py">runUIO</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And voila! We’ve got a fully working implementation that will allow us to switch between these two types whenever we have a guarantee that all errors are handled.
This makes a lot of things much simpler.
For example, if one wants to use <code class="language-plaintext highlighter-rouge">bracket</code> with <code class="language-plaintext highlighter-rouge">UIO</code>, you just need to <code class="language-plaintext highlighter-rouge">flatMap</code> to the finalizer, as <code class="language-plaintext highlighter-rouge">flatMap</code> is always guaranteed to not short-circuit.</p>

<p>We can also define instances for <code class="language-plaintext highlighter-rouge">EitherT</code> and <code class="language-plaintext highlighter-rouge">OptionT</code> (being isomorphic to <code class="language-plaintext highlighter-rouge">EitherT[F, Unit, A]</code>), where the corresponding unexceptional type is just the outer <code class="language-plaintext highlighter-rouge">F</code>, so <code class="language-plaintext highlighter-rouge">endeavor</code> is just a call to <code class="language-plaintext highlighter-rouge">.value</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">catsEndeavorForEitherT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
    <span class="k">val</span> <span class="nv">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">endeavor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
      <span class="nv">fa</span><span class="o">.</span><span class="py">value</span>

    <span class="k">def</span> <span class="nf">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">fa</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">a</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="nf">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">EitherT</span><span class="o">.</span><span class="py">liftF</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>

  <span class="o">}</span>
</code></pre></div></div>

<p>Finally, it’s also possible to create instances for other standard monad transformers like <code class="language-plaintext highlighter-rouge">WriterT</code>, <code class="language-plaintext highlighter-rouge">ReaderT</code> or <code class="language-plaintext highlighter-rouge">StateT</code> as long as their underlying monads themselves have instances for <code class="language-plaintext highlighter-rouge">MonadBlunder</code>, as is typical in mtl.
As their implementations are very similar we’ll only show the <code class="language-plaintext highlighter-rouge">StateT</code> transformer instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">catsEndeavorForStateT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="nv">F</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="nv">M</span><span class="o">.</span><span class="py">monadErrorF</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="nv">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="nv">M</span><span class="o">.</span><span class="py">monadG</span>

      <span class="k">val</span> <span class="nv">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
      <span class="k">val</span> <span class="nv">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]]</span>

      <span class="k">def</span> <span class="nf">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">ga</span><span class="o">.</span><span class="py">mapK</span><span class="o">(</span><span class="nf">new</span> <span class="o">(</span><span class="n">G</span> <span class="o">~&gt;</span> <span class="n">F</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nv">M</span><span class="o">.</span><span class="py">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
      <span class="o">})</span>

      <span class="k">def</span> <span class="nf">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
        <span class="nc">IndexedStateT</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nv">M</span><span class="o">.</span><span class="py">handleBlunderWith</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">s</span><span class="o">))(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="py">run</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>

    <span class="o">}</span>
</code></pre></div></div>

<p>In practice this means we can call <code class="language-plaintext highlighter-rouge">handleBlunderWith</code> on things like <code class="language-plaintext highlighter-rouge">StateT[IO, S, A]</code> and get back a <code class="language-plaintext highlighter-rouge">StateT[UIO, S, A]</code>. Pretty neat!
You can also create instances for pretty much any <code class="language-plaintext highlighter-rouge">MonadError</code> using <code class="language-plaintext highlighter-rouge">Unexceptional</code>, e.g.: <code class="language-plaintext highlighter-rouge">MonadBlunder[Future, Unexceptional[Future, ?], Throwable]</code>. The <code class="language-plaintext highlighter-rouge">Unexceptional</code> type is designed to turn any erroring type into one that doesn’t throw errors by catching them with <code class="language-plaintext highlighter-rouge">attempt</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, I’ve tried to present the argument that <code class="language-plaintext highlighter-rouge">MonadError</code> is insufficient for principled error handling.
We also tried to build a solution that deals with the shortcomings described earlier.
Thereby it seeks not to replace, but to expand on <code class="language-plaintext highlighter-rouge">MonadError</code> to get a great variety of error handling capabilities.
I believe the <code class="language-plaintext highlighter-rouge">MonadBlunder</code> type class, or whatever it will be renamed to, can be a great addition not just to the Cats community, but to the functional community at large, especially as it’s much easier to express in languages like <code class="language-plaintext highlighter-rouge">PureScript</code> and <code class="language-plaintext highlighter-rouge">Haskell</code>.</p>

<p>For now, all of the code lives inside the <a href="https://github.com/LukaJCB/cats-uio">cats-uio repo</a>, which houses the <code class="language-plaintext highlighter-rouge">MonadBlunder</code> type class the <code class="language-plaintext highlighter-rouge">UIO</code> data type and the <code class="language-plaintext highlighter-rouge">Unexceptional</code> data type.
I hope that this blog post gave a motivation as to why I created the library and why it might be nice to adopt some of its features into the core typelevel libraries.</p>

<p>Note again, that none of this is final or set in stone and before it arrives anywhere might still change a lot, especially in regards to naming (which I’m not really happy with at the moment), so if you have any feedback of any sorts, please do chime in! Would love to hear your thoughts and thank you for reading this far!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 13 Apr 2018 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2018/04/13/rethinking-monaderror.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/04/13/rethinking-monaderror.html</guid>
      </item>
    
      <item>
        <title>Optimizing Tagless Final – Saying farewell to Free</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p>The Tagless Final encoding has gained some steam recently, with some people hailing 2017 as the year of Tagless Final.
Being conceptually similar to the Free Monad, different comparisons have been brought up and the one trade-off that always comes up is the lack or the difficulty of inspection of tagless final programs and in fact, I couldn’t find a single example on the web.
This seems to make sense, as programs in the tagless final encoding aren’t values, like programs expressed in terms of free structures. 
However, in this blog post, I’d like to dispell the myth that inspecting and optimizing tagless final programs is more difficult than using <code class="language-plaintext highlighter-rouge">Free</code>.</p>

<p>Without further ado, let’s get into it, starting with our example algebra, a very simple key-value store:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To get the easiest example out of the way, here’s how to achieve parallelism in a tagless final program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">FlatMap</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">K</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">M</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">P</span><span class="k">:</span> <span class="kt">Parallel</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">F</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">K</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="nv">K</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"B"</span><span class="o">),</span> <span class="nv">K</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"C"</span><span class="o">)).</span><span class="py">parMapN</span><span class="o">(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">K</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="s">"X"</span><span class="o">,</span> <span class="nv">x</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="s">"-"</span><span class="o">))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span>
</code></pre></div></div>

<p>This programs makes use of the <code class="language-plaintext highlighter-rouge">cats.Parallel</code> type class, that allows us to make use of the <code class="language-plaintext highlighter-rouge">parMapN</code> combinator to use independent computations with a related <code class="language-plaintext highlighter-rouge">Applicative</code> type. This is already much simpler than doing the same thing with <code class="language-plaintext highlighter-rouge">Free</code> and <code class="language-plaintext highlighter-rouge">FreeApplicative</code>. For more info on <code class="language-plaintext highlighter-rouge">Parallel</code> check out the cats docs <a href="https://typelevel.org/cats/typeclasses/parallel.html">here</a>.</p>

<p>However this is kind of like cheating, we’re not really inspecting the structure of our program at all, so let’s look at an example where we actually have access to the structure to do optimizations with.</p>

<p>Let’s say we have the following program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="s">"42"</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
      <span class="o">.</span><span class="py">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="py">flatten</span><span class="o">)</span>
</code></pre></div></div>

<p>Not a very exciting program, but it has some definite optimization potential.
Right now, if our KVStore implementation is an asynchronous one with a network boundary, our program will make 4 network requests sequentially if interpreted with the standard <code class="language-plaintext highlighter-rouge">Apply</code> instance of something like <code class="language-plaintext highlighter-rouge">cats.effect.IO</code>.
We also have a duplicate request with the <code class="language-plaintext highlighter-rouge">"Cats"</code>-key.</p>

<p>So let’s look at what we could potentially do about this.
The first thing we should do, is extract the static information.
The easiest way to do so, is to interpret it into something we can use using a <code class="language-plaintext highlighter-rouge">Monoid</code>.
This is essentially equivalent to the <code class="language-plaintext highlighter-rouge">analyze</code> function commonly found on <code class="language-plaintext highlighter-rouge">FreeApplicative</code>.</p>

<p>Getting this done, is actually quite simple, as we can use <code class="language-plaintext highlighter-rouge">cats.Const</code> as our <code class="language-plaintext highlighter-rouge">Applicative</code> data type, whenever the lefthand side of <code class="language-plaintext highlighter-rouge">Const</code> is a <code class="language-plaintext highlighter-rouge">Monoid</code>. 
I.e. if <code class="language-plaintext highlighter-rouge">M</code> has a <code class="language-plaintext highlighter-rouge">Monoid</code> instance, <code class="language-plaintext highlighter-rouge">Const[M, A]</code> has an <code class="language-plaintext highlighter-rouge">Applicative</code> instance.
You can read more about <code class="language-plaintext highlighter-rouge">Const</code> <a href="https://typelevel.org/cats/datatypes/const.html">here</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">analysisInterpreter</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">((</span><span class="nc">Set</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="nv">Map</span><span class="o">.</span><span class="py">empty</span><span class="o">))</span>
    <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">((</span><span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">)))</span>
  <span class="o">}</span>

<span class="nf">program</span><span class="o">(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="py">getConst</span>
<span class="c1">// res0: (Set[String], Map[String,String]) = (Set(Cats, Dogs),Map(Mice -&gt; 42))
</span>
</code></pre></div></div>

<p>By using a Tuple of <code class="language-plaintext highlighter-rouge">Set</code> and <code class="language-plaintext highlighter-rouge">Map</code> as our <code class="language-plaintext highlighter-rouge">Monoid</code>, we now get all the unique keys for our <code class="language-plaintext highlighter-rouge">get</code> and <code class="language-plaintext highlighter-rouge">put</code> operations.
Next, we can use this information to recreate our program in an optimized way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">val</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=</span> <span class="nf">program</span><span class="o">(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="py">getConst</span>

  <span class="nv">puts</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">traverse</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">*&gt;</span> <span class="nv">gets</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">flatten</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And we got our first very simple optimization.
It’s not much, but we can imagine the power of this technique.
For example, if we were using something like <code class="language-plaintext highlighter-rouge">GraphQL</code>, we could sum all of our <code class="language-plaintext highlighter-rouge">get</code> requests into one large request, so only one network roundtrip is made.
We could imagine similar things for other use cases, e.g. if we’re querying a bunch of team members that all belong to the same team, it might make sense to just make one request to all the team’s members instead of requesting them all individually.</p>

<p>Other more complex optimizations could involve writing a new interpreter with the information we gained from our static analysis.
One could also precompute some of the computations and then create a new interpreter with those computations in mind.</p>

<p>Embedding our Applicative program inside a larger monadic program is also trivial:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="n">mouse</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="py">flatten</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">val</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=</span> <span class="nf">program</span><span class="o">(</span><span class="n">mouse</span><span class="o">)(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="py">getConst</span>

  <span class="nv">puts</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">traverse</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">*&gt;</span> <span class="nv">gets</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">flatten</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">monadicProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">mouse</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">)</span>
  <span class="n">list</span> <span class="k">&lt;-</span> <span class="nf">optimizedProgram</span><span class="o">(</span><span class="nv">mouse</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="s">"64"</span><span class="o">))(</span><span class="n">F</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="s">"Birds"</span><span class="o">,</span> <span class="nv">list</span><span class="o">.</span><span class="py">headOption</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="s">"128"</span><span class="o">))</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Here we refactor our <code class="language-plaintext highlighter-rouge">optimizedProgram</code> to take an extra parameter <code class="language-plaintext highlighter-rouge">mouse</code>. Then in our larger <code class="language-plaintext highlighter-rouge">monadicProgram</code>, we perform a <code class="language-plaintext highlighter-rouge">get</code> operation and then apply its result to <code class="language-plaintext highlighter-rouge">optimizedProgram</code>.</p>

<p>So now we have a way to optimize our one specific program, next we should see if we can introduce some abstraction.
Sadly Scala lacks Rank-N types, which makes this a bit difficult as we’ll see.</p>

<p>First we’ll have to look at the shape of a generic program, they usually are functions from an interpreter <code class="language-plaintext highlighter-rouge">Algebra[F]</code> to an expression inside the type constructor <code class="language-plaintext highlighter-rouge">F</code>, such as <code class="language-plaintext highlighter-rouge">F[A]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>The problem of Rank-N types becomes apparent when we want to write a function where we interpret our program with two different interpreters, as we did before when interpreting into <code class="language-plaintext highlighter-rouge">Const</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">M:</span> <span class="kt">Monoid</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span>
  <span class="o">(</span><span class="n">restructure</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interp</span> <span class="k">=&gt;</span>

    <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nf">program</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="py">getConst</span> <span class="c1">// error: type mismatch;
</span>    <span class="c1">// found   : extract.type (with underlying type Alg[[β$0$]cats.data.Const[M,β$0$]])
</span>    <span class="c1">// required: Alg[F]
</span>
    <span class="nf">restructure</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>
<p>So, because of the lack of Rank-N types, this simple definition for our program is not enough to say that our program works for ALL type constructors <code class="language-plaintext highlighter-rouge">F[_]: Applicative</code>.</p>

<p>Fortunately there is a workaround, albeit requiring a bit more boilerplate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Program</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">interpreter</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">M:</span> <span class="kt">Monoid</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span>
  <span class="o">(</span><span class="n">restructure</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interp</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nf">program</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="py">getConst</span>

    <span class="nf">restructure</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And now it should compile without a problem.
Now we should be able to express our original optimization with this new generic approach:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="n">mouse</span><span class="o">),</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="py">flatten</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Program</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">alg</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nf">program</span><span class="o">(</span><span class="n">mouse</span><span class="o">)(</span><span class="n">alg</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="nf">optimize</span><span class="o">(</span><span class="nf">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="o">))(</span><span class="n">analysisInterpreter</span><span class="o">)</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nv">puts</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">traverse</span> <span class="o">{</span> <span class="nf">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> <span class="o">*&gt;</span> <span class="nv">gets</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">traverseFilter</span><span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>So far so good, we’ve managed to write a function to generically optimize tagless final programs.
However, one of the main advantages of tagless final is that implementation and logic should be separate concerns.
With what we have right now, we’re violating the separation, by mixing the optimization part with the program logic part.
Our optimization should be handled by the interpreter, just as the sequencing of individual steps of a monadic program is the job of the target <code class="language-plaintext highlighter-rouge">Monad</code> instance.</p>

<p>One way to go forward, is to create a typeclass that requires certain algebras to be optimizable.
This typeclass could be written using the generic function we wrote before, so let’s see what we can come up with:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Optimizer</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span>

  <span class="k">def</span> <span class="nf">monoidM</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">monadF</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="k">def</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">interpreter</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>

  <span class="k">def</span> <span class="nf">optimize</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">M</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="k">=</span> <span class="n">monoidM</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="n">monadF</span>

    <span class="k">val</span> <span class="nv">m</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=</span> <span class="nf">p</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="py">getConst</span>

    <span class="nf">rebuild</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">interpreter</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">interp</span> <span class="k">=&gt;</span> <span class="nf">p</span><span class="o">(</span><span class="n">interp</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This might look a bit daunting at first, but we’ll go through it bit by bit.
First we define our type class <code class="language-plaintext highlighter-rouge">Optimizer</code> parameterized by an algebra <code class="language-plaintext highlighter-rouge">Alg[_[_]]</code> and a type constructor <code class="language-plaintext highlighter-rouge">F[_]</code>.
This means we can define different optimizations for different algebras and different target types.
For example, we might want a different optimization for a production <code class="language-plaintext highlighter-rouge">Optimizer[KVStore, EitherT[Task, E, ?]]</code> and a testing <code class="language-plaintext highlighter-rouge">Optimizer[KVStore, Id]</code>.
Next, for our interpreter we need a <code class="language-plaintext highlighter-rouge">Monoid M</code> for our static analysis, however we don’t to parameterize our <code class="language-plaintext highlighter-rouge">Optimizer</code> with an extra type parameter, since the actual type of <code class="language-plaintext highlighter-rouge">M</code> isn’t necessary for the API, so we use an abstract type member instead.</p>

<p>Next we need actual <code class="language-plaintext highlighter-rouge">Monoid</code> and <code class="language-plaintext highlighter-rouge">Monad</code> instances for <code class="language-plaintext highlighter-rouge">F[_]</code> and <code class="language-plaintext highlighter-rouge">M</code> respectively.
The other two functions should seem familiar, the <code class="language-plaintext highlighter-rouge">extract</code> function defines an interpreter to get an <code class="language-plaintext highlighter-rouge">M</code> out of our program.
The <code class="language-plaintext highlighter-rouge">rebuild</code> function takes that value of <code class="language-plaintext highlighter-rouge">M</code> and the interpreter and produces an <code class="language-plaintext highlighter-rouge">F[Alg[F]]</code>, which can be understood as an <code class="language-plaintext highlighter-rouge">F</code> of an interpreter.
This means that we can statically analyze a program and then use the result of that to create a new optimized interpreter and this is exactly what the <code class="language-plaintext highlighter-rouge">optimize</code> function does.
This is also why we needed the <code class="language-plaintext highlighter-rouge">Monad</code> constraint on <code class="language-plaintext highlighter-rouge">F</code>, we could also get away with returning just a new interpreter <code class="language-plaintext highlighter-rouge">Alg[F]</code> from the <code class="language-plaintext highlighter-rouge">rebuild</code> method and get away with an <code class="language-plaintext highlighter-rouge">Applicative</code> constraint, but we can do more different things this way.</p>

<p>We’ll also define some quick syntax sugar for this type class to make using it a tiny bit more ergonomic.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">OptimizerOps</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="nv">value</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">optimize</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">O</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">O</span><span class="o">.</span><span class="py">optimize</span><span class="o">(</span><span class="n">value</span><span class="o">)(</span><span class="n">interp</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s see what our program would look like with this new functionality:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">monadicProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">O</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">mouse</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">)</span>
  <span class="n">list</span> <span class="k">&lt;-</span> <span class="nf">wrappedProgram</span><span class="o">(</span><span class="nv">mouse</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="s">"64"</span><span class="o">)).</span><span class="py">optimize</span><span class="o">(</span><span class="n">F</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">F</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="s">"Birds"</span><span class="o">,</span> <span class="nv">list</span><span class="o">.</span><span class="py">headOption</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="s">"128"</span><span class="o">))</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Looking good so far, now all we need to run this is an actual instance of <code class="language-plaintext highlighter-rouge">Optimizer</code>.
We’ll use a Monix <code class="language-plaintext highlighter-rouge">Task</code> for this and for simplicity our new optimization will only look at the <code class="language-plaintext highlighter-rouge">get</code> operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">kvStoreTaskOptimizer</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">Task</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">monoidM</span> <span class="k">=</span> <span class="n">implicitly</span>

  <span class="k">def</span> <span class="nf">monadF</span> <span class="k">=</span> <span class="n">implicitly</span>

  <span class="k">def</span> <span class="nf">extract</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">(</span><span class="nc">Set</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
    <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">(</span><span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">rebuild</span><span class="o">(</span><span class="n">gs</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nv">gs</span><span class="o">.</span><span class="py">toList</span>
      <span class="o">.</span><span class="py">parTraverse</span><span class="o">(</span><span class="n">key</span> <span class="k">=&gt;</span> <span class="nv">interp</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">s</span><span class="o">))))</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">flattenOption</span><span class="o">.</span><span class="py">toMap</span><span class="o">)</span>
      <span class="o">.</span><span class="py">map</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span>
        <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
          <span class="k">override</span> <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nv">m</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">v</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">v</span><span class="o">.</span><span class="py">pure</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nv">interp</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
          <span class="o">}</span>

          <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">interp</span><span class="o">.</span><span class="py">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">Monoid</code> type is just a simple <code class="language-plaintext highlighter-rouge">Set[String]</code> here, as the <code class="language-plaintext highlighter-rouge">extract</code> function will only extract the <code class="language-plaintext highlighter-rouge">get</code> operations inside the <code class="language-plaintext highlighter-rouge">Set</code>.
Then with the <code class="language-plaintext highlighter-rouge">rebuild</code> we build up our new interpreter.
First we want to precompute all the values of the program.
To do so, we just run all the operations in parallel and put them into a <code class="language-plaintext highlighter-rouge">Map</code>, while discarding values where the <code class="language-plaintext highlighter-rouge">get</code> operation returned <code class="language-plaintext highlighter-rouge">None</code>.
Now when we have that precomputed <code class="language-plaintext highlighter-rouge">Map</code>, we’ll create a new interpreter with it, that will check if the key given to <code class="language-plaintext highlighter-rouge">get</code> operation is in the precomputed <code class="language-plaintext highlighter-rouge">Map</code> instead of performing an actual request.
We can then lift the value into a <code class="language-plaintext highlighter-rouge">Task[Option[String]]</code>.
For all the <code class="language-plaintext highlighter-rouge">put</code> operations, we’ll simply run the interpreter.</p>

<p>Now we should have a great optimizer for <code class="language-plaintext highlighter-rouge">KVStore</code> programs interpreted into a <code class="language-plaintext highlighter-rouge">Task</code>.
Let’s see how we did by interpreting into a silly implementation that only prints whenever you use one of the operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">TestInterpreter</span> <span class="k">extends</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>

    <span class="nf">println</span><span class="o">(</span><span class="s">"Hit network for "</span> <span class="o">+</span> <span class="n">key</span><span class="o">)</span>

    <span class="nc">Option</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Put something: "</span> <span class="o">+</span> <span class="n">a</span><span class="o">)</span>

    <span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let’s run our program with this interpreter and the optimizations!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">monadicProgram</span><span class="o">(</span><span class="nc">TestInterpreter</span><span class="o">).</span><span class="py">runAsync</span>
<span class="c1">// Hit network for Mice
// Hit network for Cats
// Hit network for Dogs
// Put something: Mice!
// Put something: Cats!
</span></code></pre></div></div>

<p>And it works, we’ve now got a principled way to write programs that can then be potentially optimized.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Designing a way to completely separate the problem description from the actual problem solution is fairly difficult. The tagless final encoding allows us one such fairly simple way.
Using the technique described in this blog post, we should be able to have even more control over the problem solution by inspecting the structure of our program statically.
We’ve seen a few roadblocks along the way, such as the lack of Rank-N types in Scala, but we might be able to come up with a macro for that in the future, making it even more ergonomic.
Another thing we haven’t covered here, are programs with multiple algebras, which is quite a bit more complex as you can surely imagine, maybe that will be the topic of a follow up blog post.</p>

<p>The code is published <a href="https://github.com/LukaJCB/sphynx">right here</a>, but might still change after getting a feeling for which API feels best.</p>

<p>What kind of problems and techniques would you like to see with regards to tagless final?
Would love to hear from you in the comments!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html</guid>
      </item>
    
      <item>
        <title>Announcement: cats 1.0.0</title>
        
          <dc:creator>kailuowang</dc:creator>
                
        <description><![CDATA[<p>The <a href="https://github.com/typelevel/cats">cats</a> maintainer team is proud to announce the <strong>cats 1.0.0</strong> release.
Cats has been striving to provide functional programming abstractions that are core, modular, approachable and efficient. 
Cats 1.0.0 marks the point where we believe that our API is robust and stable enough to start guarantee backward binary compatibility going forward until Cats 2.0. We expect the Cats 1.x series to be fully backwards compatible for at least one year. This is a major milestone towards
our goal of providing a solid foundation for an ecosystem of pure, typeful functional libraries.</p>

<h2 id="migration">Migration</h2>

<p>The vast majority of changes since 1.0.0-RC1 are API compatible, with scalafix scripts ready for those that do not.
 <a href="https://github.com/typelevel/cats/blob/master/CHANGES.md">Here is the change list and migration guide</a>.</p>

<h2 id="binary-compatibility">Binary compatibility</h2>
<p>After 1.0.0 release, we’ll use the <em>MAJOR.MINOR.PATCH</em> <a href="https://semver.org/">Semantic Versioning 2.0.0</a> going forward, which is different from the <em>EPOCH.MAJOR.MINOR</em> scheme common among Java and Scala libraries (including the Scala lang).  In this semantic versioning, backward breaking change is ONLY allowed between <em>MAJOR</em> versions. We will maintain backward binary compatibility between <em>PATCH</em> and <em>MINOR</em> versions. For example, when we release cats 1.1.0, it will be backward binary compatible with the previous 1.0.x versions. I.E. the new JAR will be a drop-in replacement for the old one. This is critical when your application has a diamond dependency on Cats - depending on two or more libraries that all depend on Cats. If one library upgrades to the new 1.1.0 Cats before the other one does, your application still runs thanks to this backward binary compatibility.</p>

<p>We will also consider using organization and package name for <em>MAJOR</em> versioning with binary breaking changes in the future. But that decision is yet to be made.</p>

<h2 id="community">Community</h2>
<p>Cats is built for the FP Scala community by the FP Scala community. We can’t thank enough to our <a href="https://github.com/typelevel/cats/graphs/contributors">190 (and growing) contributors</a> and our users who provided feedbacks and suggestions.<br />
Congratulations to all of us. Let’s celebrate this exciting milestone together.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/12/25/cats-1.0.0.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/12/25/cats-1.0.0.html</guid>
      </item>
    
      <item>
        <title>Who implements the typeclass instance?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>The typeclass pattern in Scala invites you to place
implementation-specific knowledge directly in the typeclass instances,
with the interface defined as the typeclass’s abstract interface.</p>

<p>However, GADTs permit a different organization of code. It is even
possible to define a typeclass that seems to do nothing at all, yet
still permits full type-safe typeclass usage.</p>

<p>The possibilities between these two extremes form a design space. If
you wish to practice ad-hoc polymorphism in Scala, this space is well
worth exploring.</p>

<h2 id="a-glorified-overloader">A glorified overloader</h2>

<p>Refactoring a set of overloads into a typeclass is a fine way to get
some free flexibility and dynamism, because expressing overloads as a
typeclass gives you free fixes for common overload problems.</p>

<ol>
  <li>Methods calling the overloaded method do not themselves need to be
overloaded just to avoid suppressing the flexibility of the
overload beneath.  (See <code class="language-plaintext highlighter-rouge">addThree</code> and <code class="language-plaintext highlighter-rouge">zipAdd</code> below for
examples.)</li>
  <li>Return-type overloading works, even in Scala, where it does not
when attempting to write overloads in the Java style, i.e. multiple
methods with the same name.</li>
  <li>Overloads may be defined as recursive type rules, admitting a
combinatorial explosion or even infinite “effective overloads”.</li>
</ol>

<p>Let’s make a quick example of something like a typical overload.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">OverAdd</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
  
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span><span class="s">"$x$y"</span>
  
  <span class="k">def</span> <span class="nf">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">l</span> <span class="o">++</span> <span class="n">r</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This mechanically translates to a newly introduced type, some implicit
instances of that type, and a function to let us call <code class="language-plaintext highlighter-rouge">add</code> the same
way we used to.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// typeclasses are often defined with trait, but this is not required
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Adder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">addImpl</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span>

<span class="c1">// easier if all implicits are in this block
</span><span class="k">object</span> <span class="nc">Adder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">addInts</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Adder</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
  
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">addStrings</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Adder</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span><span class="o">)</span>
    
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">addVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Adder</span><span class="o">((</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">++</span> <span class="n">r</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// and to tie it back together
</span><span class="k">def</span> <span class="nf">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">adder</span><span class="o">.</span><span class="py">addImpl</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="overloaded-wrapping-without-overloading">Overloaded wrapping without overloading</h2>

<p>While a bit more ceremonious, this allows us to write some nice
functions more easily. Here’s a function to add three values.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">addThree</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">m</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nf">add</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">addThree</code> supports all three “overloads” of <code class="language-plaintext highlighter-rouge">add</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">addThree</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">addThree</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"ba"</span><span class="o">,</span> <span class="s">"cus"</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abacus</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">addThree</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>With the overload style, we need three variants of this function, too,
each with the exact same body. The typeclass version need only be
written once, and automatically supports new overloads, that is, new
instances of <code class="language-plaintext highlighter-rouge">Adder</code>.</p>

<p>Same with this function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">zipAdd</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">l</span> <span class="n">zip</span> <span class="n">r</span> <span class="n">map</span> <span class="o">{</span><span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)}</span>
</code></pre></div></div>

<p>Functions like <code class="language-plaintext highlighter-rouge">addThree</code> and <code class="language-plaintext highlighter-rouge">zipAdd</code> are called <em>derived
combinators</em>. The more that you can do in derived combinators, the
more abstract and orthogonal your program will be.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   +=============+            |   +=============+
   |   derived   |  (open     |   |  primitive  |  (closed
   | combinators |    set)    |   | combinators |      set)
   +=============+            |   +=============+
                              |
   +----------+               |    +----------+
   | addThree |---→---→---→---→---→| Adder    |
   +----------+       calls   |    | -addImpl |    +===========+
    ↑                       |→---→ +----------+    | Instances |
    | +--------+            | |                    +===========+
    | | zipAdd |---→---→---→- |
    | +--------+    calls     |  +------+ +---------+ +-------+
    ↑        ↑                |  | Ints | | Strings | | Vects |
    |   calls|                |  +------+ +---------+ +-------+
    |      +-----+            |      |
    |      | ??? |            |      |
    ↑      +-----+            |      |
    |  (derived combinators          ↓
    |   can derive from each other)  ---→---→---→
    |                                           |
    ↑          -------------------------------  |
    |          To evaluate `addThree(1, 2, 3)`  |
    |          -------------------------------  ↓
    |          1. Fetch `Adder` implicitly      |
    |-←---←---←---←---←---←---←---←---←---←---←-|
               2. Pass to `addThree`
               3. `addThree` uses the abstract interface to
                  invoke the primitive `add` combinator on what,
                  to it, is an abstract type, `A`.
</code></pre></div></div>

<h2 id="infinite-overloads-via-recursion">Infinite overloads via recursion</h2>

<p>Making derived combinators easier to write is very useful, but
typeclasses go further by letting you describe overloading rules that
would be impossible with normal overloading.</p>

<p>Given that I can add <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Int</code> together, I should be able to add
<code class="language-plaintext highlighter-rouge">(Int, Int)</code> and <code class="language-plaintext highlighter-rouge">(Int, Int)</code> to get <code class="language-plaintext highlighter-rouge">(Int, Int)</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">addIntPairs</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Adder</span><span class="o">{</span><span class="nf">case</span> <span class="o">((</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">),</span> <span class="o">(</span><span class="n">y1</span><span class="o">,</span> <span class="n">y2</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">y1</span><span class="o">,</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span><span class="o">)}</span>
    
<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">add</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">))</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">15</span><span class="o">)</span>
</code></pre></div></div>

<p>But I should also be able to add pairs of <code class="language-plaintext highlighter-rouge">String</code>. And <code class="language-plaintext highlighter-rouge">(Int,
String)</code> pairs. And <code class="language-plaintext highlighter-rouge">(String, Vector[Boolean])</code> pairs. And pairs of
pairs of pairs.</p>

<p>Typeclasses let you declare newly supported types recursively, with an
implicit argument list to the <code class="language-plaintext highlighter-rouge">implicit def</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">addPairs</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span>, <span class="kt">B:</span> <span class="kt">Adder</span><span class="o">]</span>
    <span class="k">:</span> <span class="kt">Adder</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Adder</span><span class="o">{</span><span class="nf">case</span> <span class="o">((</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">),</span> <span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="nf">add</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">),</span> <span class="nf">add</span><span class="o">(</span><span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="surely-this-must-be-going-somewhere-new">Surely this must be going somewhere new</h2>

<p>If you’re familiar with type classes, all this must be old hat. But
this time, we’re going to expand the boundaries of the typeclass
design space, by exploiting <em>GADT pattern matching</em>.</p>

<p>We could have designed the <code class="language-plaintext highlighter-rouge">Adder</code> type class to include <code class="language-plaintext highlighter-rouge">addThree</code> as
a primitive combinator, and implemented it afresh for each of the four
instances we’ve defined so far, as well as any future instances
someone might define. Thinking orthogonally, however, shows us that
there’s a more primitive concept which strictly generalizes it: if we
primitively define a two-value adder, we can use it to add three
items, simply by using it twice.</p>

<p>This has a direct impact on how we structure the functions related to
<code class="language-plaintext highlighter-rouge">Adder</code>. The primitives must be split up, their separate
implementations appearing directly in the implicit instances. Derived
combinators may occur anywhere that is convenient to us: outside the
typeclass for full flexibility of location, or within the typeclass
for possible overrides for performance.</p>

<p>But how much of the primitive implementations must occur in the
instances, really?</p>

<h2 id="empty-tags-as-instances">Empty tags as instances</h2>

<p>There is a progression of design refinements here.</p>

<ol>
  <li>Ad hoc overloads, Java-style, impossible to abstract over.</li>
  <li>Flip into a typeclass.</li>
  <li>Refine the primitive/derived distinction to minimize code in
instances.</li>
</ol>

<p>For some typeclasses, <em>no</em> code needs to be put in the instances. For
example, if we want to support only <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">String</code>, and <code class="language-plaintext highlighter-rouge">Vector</code>,
here is a perfectly sensible typeclass definition.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">object</span> <span class="nc">ISAdder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddInts</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddStrs</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span>
  
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">addVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">AddVects</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If the instances cannot add values of the types indicated by the type
parameters, surely that code must exist somewhere! And it has a place,
in the definition of <code class="language-plaintext highlighter-rouge">add</code>.</p>

<p>If you recall, this method merely called <code class="language-plaintext highlighter-rouge">addImpl</code> on the typeclass
instance before. Now there is no such thing; the instances are empty.</p>

<p>Well, they are not quite empty; they contain a type.  So we can define
<code class="language-plaintext highlighter-rouge">add</code>, with complete type safety, as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isadd</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nv">ISAdder</span><span class="o">.</span><span class="py">AddInts</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">case</span> <span class="nv">ISAdder</span><span class="o">.</span><span class="py">AddStrings</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span>
    <span class="k">case</span> <span class="nv">ISAdder</span><span class="o">.</span><span class="py">AddVects</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="n">x</span> <span class="o">++</span> <span class="n">y</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>More specifically, they contain a runtime tag, which allows
information about the type of <code class="language-plaintext highlighter-rouge">A</code> to be extracted with a pattern
match. For example, determining that <code class="language-plaintext highlighter-rouge">adder</code> is <code class="language-plaintext highlighter-rouge">AddInts</code> reveals that
<code class="language-plaintext highlighter-rouge">A = Int</code>, because that’s what the <code class="language-plaintext highlighter-rouge">extends</code> clause says.  This is
<em>GADT pattern matching</em>.</p>

<p>The <code class="language-plaintext highlighter-rouge">Vector</code> case is a little tricky here, because we can only
determine that <code class="language-plaintext highlighter-rouge">A</code> is <code class="language-plaintext highlighter-rouge">Vector[e]</code> <em>for some unknown e</em>, but that’s
enough information to invoke <code class="language-plaintext highlighter-rouge">++</code> and get a result also of <code class="language-plaintext highlighter-rouge">Vector[e]</code>
for the same <code class="language-plaintext highlighter-rouge">e</code>.</p>

<p>You can see this in action by using a <a href="https://groups.google.com/d/msg/scala-user/JlCsy48poIU/DjsQDnzeZboJ">variable type
pattern</a>
to assign the name <code class="language-plaintext highlighter-rouge">e</code> (a lowercase type parameter is required for
this usage), so you can refer to it in types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="k">_:</span> <span class="kt">ISAdder.AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">e</span><span class="o">])</span> <span class="o">++</span> <span class="n">y</span>
</code></pre></div></div>

<h2 id="the-lowercase-e-names-a-gadt-skolem">The lowercase <code class="language-plaintext highlighter-rouge">e</code> names a GADT skolem</h2>

<p>In the <code class="language-plaintext highlighter-rouge">AddVects[e]</code> pattern immediately above, <code class="language-plaintext highlighter-rouge">e</code> is a <em>variable
type pattern</em>. This is a type that exists only in the scope of the
<code class="language-plaintext highlighter-rouge">case</code>.</p>

<p>It’s <em>existential</em> because we don’t know what it is, only that it is
<em>some type</em> and we don’t get to pick here what that is. In this way,
it is no different from a type parameter’s treatment by the
implementation, which is
<a href="/blog/2016/01/28/existential-inside.html">existential on the inside</a>.</p>

<p>It’s a <em>GADT skolem</em> because it was bound by the pattern matching
mechanism to a “fresh” type, unequal to any other. Recall the way
<code class="language-plaintext highlighter-rouge">AddVects</code> was defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">AddVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span>
</code></pre></div></div>

<p>Matching <code class="language-plaintext highlighter-rouge">ISAdder</code> with <code class="language-plaintext highlighter-rouge">AddVects</code> doesn’t tell us anything about
bounds on the type passed to <code class="language-plaintext highlighter-rouge">AddVects</code> at construction time. This
isn’t true of all
<a href="/blog/2016/09/19/variance-phantom.html#a-gadt-skolem">GADT skolems</a>,
but is only natural for this one.</p>

<p><code class="language-plaintext highlighter-rouge">scalac</code> will create this GADT skolem <em>regardless of whether we give
it a name</em>. In the pattern <code class="language-plaintext highlighter-rouge">case AddVects()</code>, it’s still known that
<code class="language-plaintext highlighter-rouge">A = Vector[e]</code> for some <code class="language-plaintext highlighter-rouge">e</code>; the only difference is that you haven’t
bound the <code class="language-plaintext highlighter-rouge">e</code> name, so you can’t actually refer to this <em>unspeakable</em>
type.</p>

<p>Usually, you do not need to assign names such as <code class="language-plaintext highlighter-rouge">e</code> to such types;
<code class="language-plaintext highlighter-rouge">_</code> is sufficient.  However, if you have problems getting <code class="language-plaintext highlighter-rouge">scalac</code> to
apply all the type equalities it ought to know about, a good first
step is to assign names to any skolems and try type
ascriptions. You’ll need a variable type pattern in other situations
that don’t infer, too. By contrast, with the <code class="language-plaintext highlighter-rouge">e</code> name bound, we can
confirm that <code class="language-plaintext highlighter-rouge">x: Vector[e]</code> in the above example, and <code class="language-plaintext highlighter-rouge">y</code> is
sufficiently well-typed for the whole expression to type-check.</p>

<h2 id="porting-addpairs-and-other-recursive-cases">Porting <code class="language-plaintext highlighter-rouge">addPairs</code> and other recursive cases</h2>

<p>Suppose we add support for pairs to <code class="language-plaintext highlighter-rouge">ISAdder</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddPairs</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span>
    <span class="k">val</span> <span class="nv">fst</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
    <span class="k">val</span> <span class="nv">snd</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>This <em>should</em> permit us to pattern-match in <code class="language-plaintext highlighter-rouge">isadd</code> to make complex
determinations about the <code class="language-plaintext highlighter-rouge">A</code> type given to <code class="language-plaintext highlighter-rouge">isadd</code>. This <em>ought to be</em>
a big win for GADT-style typeclasses, allowing “short-circuiting”
patterns that work in an obvious way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// this pattern means A=(Int, String)
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>

<span class="c1">// this pattern means A=(ea, Vector[eb])
// where ea and eb are GADT skolems
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>

<span class="c1">// here, A=(ea, eb) (again, GADT skolems)
// calling `isadd` recursively is the most
// straightforward implementation
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="nf">val</span> <span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
  <span class="nf">val</span> <span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="nf">y</span>
  <span class="o">(</span><span class="nf">isadd</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">f2</span><span class="o">)(</span><span class="n">fst</span><span class="o">),</span> <span class="nf">isadd</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)(</span><span class="n">snd</span><span class="o">))</span>
</code></pre></div></div>

<p>The final <code class="language-plaintext highlighter-rouge">case</code>’s body is fine. <code class="language-plaintext highlighter-rouge">scalac</code> effectively introduces
skolems <code class="language-plaintext highlighter-rouge">ea</code> and <code class="language-plaintext highlighter-rouge">eb</code> so that <code class="language-plaintext highlighter-rouge">A = (ea, eb)</code>, <code class="language-plaintext highlighter-rouge">fst: Adder[ea]</code>, and so
on, and everything lines up nicely. We are not so lucky with the other
cases.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">....</span><span class="py">scala</span><span class="k">:</span><span class="err">76</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddInts.type</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
                    <span class="o">^</span>
<span class="o">....</span><span class="py">scala</span><span class="k">:</span><span class="err">76</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>

 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddStrs.type</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
                             <span class="o">^</span>
<span class="o">....</span><span class="py">scala</span><span class="k">:</span><span class="err">79</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>
                            <span class="o">^</span>
</code></pre></div></div>

<p>This is nonsensical; the underlying code is sound, we just have to go
the long way around so that <code class="language-plaintext highlighter-rouge">scalac</code> doesn’t get confused. Instead of
the above form, you must assign names to the <code class="language-plaintext highlighter-rouge">AddPairs</code> skolems as we
described above, and do a sub-pattern-match.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">AddPairs</span><span class="o">[</span><span class="kt">ea</span>, <span class="kt">eb</span><span class="o">]</span> <span class="k">=&gt;</span>
  <span class="nf">val</span> <span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
  <span class="nf">val</span> <span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="nf">y</span>
  <span class="o">(</span><span class="nv">p</span><span class="o">.</span><span class="py">fst</span><span class="o">,</span> <span class="nv">p</span><span class="o">.</span><span class="py">snd</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=&gt;</span>
</code></pre></div></div>

<p>Note that we had to give up on the <code class="language-plaintext highlighter-rouge">AddPairs</code> pattern entirely,
because</p>

<ol>
  <li>More complex situations require type ascription.</li>
  <li>You cannot ascribe with skolems unless you’ve bound the skolems to
names with variable type patterns.</li>
  <li>You can’t use variable type patterns with the structural
“ADT-style” patterns; you must instead use inelegant and
inconvenient [non-variable] type patterns. (This may be
<a href="https://github.com/typelevel/scala/blob/typelevel-readme/notes/typelevel-4.md#type-arguments-on-patterns-pull5774-paulp">improved in Typelevel Scala 4</a>.)</li>
</ol>

<p>Yet this remains entirely up to shortcomings in the current pattern
matcher implementation. An improved pattern matcher could make the
nice version work, safely and soundly.</p>

<p>As such, I don’t want these shortcomings to discourage you from trying
out the pure type-tagging, “GADT-style” typeclasses. It is simply
nicer for many applications, and you aren’t going to code yourself
into a hole with them, because should you wind up in the buggy
territory we’ve been exploring, there’s still a way out.</p>

<h2 id="same-typeclass-new-primitive-combinators">Same typeclass, new “primitive” combinators</h2>

<p>“Empty” typeclasses like <code class="language-plaintext highlighter-rouge">ISAdder</code> contain no implementations of
primitive combinators, only “tags”. As such, they are in a sense the
purest form of “typeclass”; <em>to classify types</em> is the beginning and
end of what they do!</p>

<p>Every type that is a member of the “class of types” <code class="language-plaintext highlighter-rouge">ISAdder</code> is
either</p>

<ol>
  <li>the type <code class="language-plaintext highlighter-rouge">Int</code>,</li>
  <li>the type <code class="language-plaintext highlighter-rouge">String</code>,</li>
  <li>a type <code class="language-plaintext highlighter-rouge">Vector[e]</code>, where <code class="language-plaintext highlighter-rouge">e</code> is any type, or</li>
  <li>a type <code class="language-plaintext highlighter-rouge">(x, y)</code> where <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are types that are <em>also</em> in the
<code class="language-plaintext highlighter-rouge">ISAdder</code> class.</li>
</ol>

<p>This is the end of <code class="language-plaintext highlighter-rouge">ISAdder</code>’s definition; in particular, there is
nothing here about “adding two values to get a value”. All that
is said is what types are in the class!</p>

<p>Given this ‘undefinedness’, if we have another function we want to
write over the exact same class-of-types, we can just write it without
making any changes to <code class="language-plaintext highlighter-rouge">ISAdder</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">backwards</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">X</span><span class="o">])</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=</span> <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="n">x</span>
  <span class="k">case</span> <span class="nc">AddStrs</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">reverse</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">reverse</span>
  <span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">AddPairs</span><span class="o">[</span><span class="kt">ea</span>, <span class="kt">eb</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">ea</span><span class="o">,</span> <span class="kt">eb</span><span class="o">)</span> <span class="k">=</span> <span class="nf">x</span>
    <span class="o">(</span><span class="nf">backwards</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="nv">p</span><span class="o">.</span><span class="py">fst</span><span class="o">),</span> <span class="nf">backwards</span><span class="o">(</span><span class="n">b</span><span class="o">)(</span><span class="nv">p</span><span class="o">.</span><span class="py">snd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Set aside the question of whether the class of “backwards-able” types
ought to remain in lockstep with the class of “addable”
types. Supposing that it <em>should</em>, the class need be defined only
once.</p>

<p>More practically speaking, if you expose the subclasses of a typeclass
to users of your library, they can define primitives “in lockstep”,
too.  The line between primitive and derived combinators is also
blurred: a would-be derived combinator can pattern-match on the
typeclass to supply special cases for improved performance, becoming
“semi-primitive” in the process.  You decide whether these are good
things or not.</p>

<h2 id="hybrid-clopen-typeclasses">Hybrid “clopen” typeclasses</h2>

<p>Pattern-matching typeclass GADTs is subject to the same exhaustiveness
concerns and compiler warnings as pattern-matching ordinary ADTs. If
you eliminate a <code class="language-plaintext highlighter-rouge">case</code> from <code class="language-plaintext highlighter-rouge">def isadd</code>, you’ll see something like</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">....</span><span class="py">scala</span><span class="k">:</span><span class="err">57</span><span class="kt">:</span> <span class="kt">match</span> <span class="kt">may</span> <span class="kt">not</span> <span class="kt">be</span> <span class="kt">exhaustive.</span>
<span class="kt">It</span> <span class="kt">would</span> <span class="kt">fail</span> <span class="kt">on</span> <span class="kt">the</span> <span class="kt">following</span> <span class="kt">input:</span> <span class="kt">AddInts</span>
    <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
    <span class="o">^</span>
</code></pre></div></div>

<p>We could unseal <code class="language-plaintext highlighter-rouge">ISAdder</code>, which would eliminate the warning, but
wouldn’t really solve anything. The function would still crash upon
encountering the missing case.</p>

<p>Pattern matches of unsealed hierarchies typically include a “fallback”
case, code used when none of the “special” cases match. However, for
pure typeclasses like <code class="language-plaintext highlighter-rouge">ISAdder</code>, this strategy is a dead end
too. Consider a hypothetical fallback case.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">???</span>
</code></pre></div></div>

<p>Each of the other patterns in <code class="language-plaintext highlighter-rouge">isadd</code>, by their success, taught us
something useful about the <code class="language-plaintext highlighter-rouge">A</code> type parameter. For example, <code class="language-plaintext highlighter-rouge">case
AddInts</code> tells us that <code class="language-plaintext highlighter-rouge">A = Int</code>, and accordingly <code class="language-plaintext highlighter-rouge">x: Int</code> and <code class="language-plaintext highlighter-rouge">y:
Int</code>. It also meant that the expected result type of that block is
also <code class="language-plaintext highlighter-rouge">Int</code>. That’s plenty of information to actually implement
“adding”.</p>

<p>By contrast, <code class="language-plaintext highlighter-rouge">case _</code> tells us <em>nothing</em> about the <code class="language-plaintext highlighter-rouge">A</code> type. We don’t
know anything new about <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, or the type of value we ought to
return. All we can do is return either <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">y</code> without further
combination; while this is a sort of “adding” <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:First">in abstract
algebra</a>,
there’s a good chance it’s not really what the caller was expecting.</p>

<p>Instead, we can reformulate a closed typeclass like <code class="language-plaintext highlighter-rouge">ISAdder</code> with one
extension point, where the typeclass is specially encoded in the usual
“embedded implementation” style. It’s closed and open, so
<a href="https://mail.haskell.org/pipermail/haskell-cafe/2014-April/113373.html">“clopen”</a>.</p>

<h2 id="sealed-doesnt-seal-subclasses"><code class="language-plaintext highlighter-rouge">sealed</code> doesn’t seal subclasses</h2>

<p>Our GADT typeclass instances work by embedding type information within
the instances, to be rediscovered at runtime. To support open
extension, we need a data case that contains <em>functions</em> instead of
types. We know how to encode that, because that is how standard,
non-GADT typeclasses work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">trait</span> <span class="nc">ExtISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">addImpl</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">ISOAdder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddInts</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddStrs</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  
  <span class="k">final</span> <span class="k">class</span> <span class="nc">AddVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">addVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">ISOAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddVects</span>
    
  <span class="k">def</span> <span class="nf">isoadd</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="k">case</span> <span class="nc">AddStrs</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span>
      <span class="k">case</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">e</span><span class="o">])</span> <span class="o">++</span> <span class="n">y</span>
      <span class="c1">// NB: no unchecked warning here, which makes sense
</span>      <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">ExtISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span>
        <span class="nv">e</span><span class="o">.</span><span class="py">addImpl</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>By sealing <code class="language-plaintext highlighter-rouge">ISOAdder</code>, we ensure that the pattern match in <code class="language-plaintext highlighter-rouge">isoadd</code>
remains exhaustive. However, one of those cases, <code class="language-plaintext highlighter-rouge">ExtISOAdder</code>, admits
new subclasses, itself! This is fine because no matter how many
subclasses of <code class="language-plaintext highlighter-rouge">ExtISOAdder</code> we make, they’ll still match the last
pattern of <code class="language-plaintext highlighter-rouge">isoadd</code>.</p>

<p>We could also define <code class="language-plaintext highlighter-rouge">ExtISOAdder</code> as a <code class="language-plaintext highlighter-rouge">final case class</code>. The point
is that you can make this “extension point” in your otherwise-closed
typeclass using whatever style you like.</p>

<p>One caveat, though: “clopen” typeclasses cannot have arbitrary new
primitive combinators added to them. They are like ordinary open
typeclasses in that regard. Consider a version of <code class="language-plaintext highlighter-rouge">backwards</code> for
<code class="language-plaintext highlighter-rouge">ISOAdder</code>: what you could do in the <code class="language-plaintext highlighter-rouge">ExtISOAdder</code> case?</p>

<h2 id="whoever-you-like">Whoever you like</h2>

<p>With type parameters vs. members, you can get pretty far with
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">the “rule of thumb”</a>.
Beyond that, even bugs in <code class="language-plaintext highlighter-rouge">scalac</code> typechecking can guide you to the
“right” choice.</p>

<p>There is no similar rule for this design space. It might seem that
typeclass newcomers might have an easier time with the OO-style
“unimplemented method” signposts in the open style, but I have also
seen them lament the loss of flexibility that would be provided by the
GADT style.</p>

<p>Likewise, as an advanced practitioner, your heart will be rent by the
tug-of-war between the boilerplate of the open style and the
pattern-matcher’s finickiness with the GADT style. You may then be
tempted to adopt the hybrid ‘clopen’ style, but this, too, is too
often a form of design excess.</p>

<p>Given all that, the only help I can offer, aside from describing the
design space above, is “pick whichever you like”. You know your
program; if you are not sure which will be nicer, try both!</p>

<p><em>This article was tested with Scala 2.12.4.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/12/20/who-implements-typeclass.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/12/20/who-implements-typeclass.html</guid>
      </item>
    
      <item>
        <title>There are at least three types of strings</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><a href="https://contributors.scala-lang.org/t/pre-sip-unboxed-wrapper-types/987">Newtype mechanisms</a>
are a great way to introduce wrapper-free, global distinctions of
“different” instances of the same type. But we can do that on a local
level, too,
<a href="https://gist.github.com/jbgi/d6b677d084fafc641fe01f7ffd00591c/70842ca600e53e8c237c681773fe4e16bd679628#file-label-java-L32">by using type parameters</a>.</p>

<p>Consider these two signatures.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mungeIDs</span><span class="o">(</span><span class="n">uids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">gids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
             <span class="n">oids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Magic</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">mungeIDsSafely</span><span class="o">[</span><span class="kt">UID</span> <span class="k">&lt;:</span> <span class="kt">String</span>, <span class="kt">GID</span> <span class="k">&lt;:</span> <span class="kt">String</span>, <span class="kt">OID</span> <span class="k">&lt;:</span> <span class="kt">String</span><span class="o">]</span>
            <span class="o">(</span><span class="n">uids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">UID</span><span class="o">],</span> <span class="n">gids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">GID</span><span class="o">],</span>
             <span class="n">oids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">OID</span><span class="o">])</span><span class="k">:</span> <span class="kt">Magic</span><span class="o">[</span><span class="kt">UID</span>, <span class="kt">GID</span>, <span class="kt">OID</span><span class="o">]</span> 
</code></pre></div></div>

<p>The second function is a strictly more general interface; the first,
concrete signature can be implemented by calling the second function,
passing <code class="language-plaintext highlighter-rouge">[String, String, String]</code> as the type arguments. There is no
need to even have the first signature; anywhere in your program where
you pass three <code class="language-plaintext highlighter-rouge">List[String]</code>s as arguments to <code class="language-plaintext highlighter-rouge">mungeIDsSafely</code>, the
proper type arguments will be inferred.</p>

<p>Yet, assuming you don’t wish <code class="language-plaintext highlighter-rouge">mungeIDs</code> to be oracular (i.e. a source
of UIDs, GIDs, and OIDs), the second signature is probably much more
reliable, because type parameters are quite as
<a href="/blog/2017/02/13/more-types-than-classes.html#it-must-not-necessarily-be-anything">mysterious</a>
as the opaque abstract type members of the newtype mechanism.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">mungeIDsSafely</code> can’t invent new IDs, not even with <code class="language-plaintext highlighter-rouge">null</code>.</li>
  <li>It can’t combine them to produce new IDs.</li>
  <li>It <em>can</em> treat the three list arguments as <code class="language-plaintext highlighter-rouge">List[String]</code>. However,
it cannot convert any <code class="language-plaintext highlighter-rouge">String</code> back into an ID; any UIDs, GIDs, or
OIDs that appear in the result <code class="language-plaintext highlighter-rouge">Magic[UID, GID, OID]</code> must have
come from one of the argument lists, directly. (That’s not to say
that <code class="language-plaintext highlighter-rouge">mungeIDsSafely</code> can’t <em>use</em> the string-nature to make that
decision; for example, it could always choose the
smallest-as-string UID to put into the resulting <code class="language-plaintext highlighter-rouge">Magic</code>. But, that
UID is <em>still</em> enforced to be a proper element of the <code class="language-plaintext highlighter-rouge">uids</code>
argument, and cannot be gotten from anywhere else.</li>
  <li>Perhaps most importantly, it cannot mix up UIDs, GIDs, and
OIDs. Even though, “really”, they’re all strings!</li>
</ol>

<p>It is entirely irrelevant that you cannot subclass <code class="language-plaintext highlighter-rouge">String</code> in Scala,
Java, or whatever.
<a href="/blog/2017/02/13/more-types-than-classes.html">There are more types than classes</a>.</p>

<p>Given the advantages, it’s very unfortunate that the signature of
<code class="language-plaintext highlighter-rouge">mungeIDsSafely</code> is so much noisier than that of <code class="language-plaintext highlighter-rouge">mungeIDs</code>.  At least
you have the small consolation of eliminating more useless unit tests.</p>

<p>This is a good first approximation at moving away from the dangers of
concreteness in Scala, and has the advantage of working in Java, too
(sort of; the <code class="language-plaintext highlighter-rouge">null</code> prohibition is sadly relaxed).</p>

<h2 id="non-supertype-constraints">Non-supertype constraints</h2>

<p>In Scala, you can also use implicits to devise arbitrary constraints,
similar to typeclasses in Haskell, and sign your functions using
implicits instead, for much finer-grained control, improved safety,
and types-as-documentation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a typeclass for "IDish types" (imagine instances)
</span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IDish</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">def</span> <span class="n">mungeIDsTCey</span><span class="o">[</span><span class="kt">UID:</span> <span class="kt">IDish</span>, <span class="kt">GID:</span> <span class="kt">IDish</span>, <span class="kt">OID:</span> <span class="kt">IDish</span><span class="o">]</span>
            <span class="o">(</span><span class="n">uids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">UID</span><span class="o">],</span> <span class="n">gids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">GID</span><span class="o">],</span>
             <span class="n">oids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">OID</span><span class="o">])</span><span class="k">:</span> <span class="kt">Magic</span><span class="o">[</span><span class="kt">UID</span>, <span class="kt">GID</span>, <span class="kt">OID</span><span class="o">]</span> 
</code></pre></div></div>

<p>Though all three types have the same constraint, <code class="language-plaintext highlighter-rouge">IDish</code>, they are
still distinct types.  And now, the coupling with <code class="language-plaintext highlighter-rouge">String</code> is broken;
as the program author, you get to decide whether you want that or not.</p>

<h2 id="pitfalls-avoided-for-you">Pitfalls avoided for you</h2>

<p>Luckily, Java doesn’t make the mistake of “reified generics”. If it
did, you could ask whether <code class="language-plaintext highlighter-rouge">UID = GID = OID = String</code>, and all your
safety guarantees would be gone. Forcing all generics to be reified
does not grant you any new expressive power; all it does is
permanently close off large swaths of the spectrum of mystery to you,
forbidding you from using the full scope of the design space to
improve the reliability of your well-typed programs.</p>

<p>The same goes for claiming that <code class="language-plaintext highlighter-rouge">null</code> ought to be a default member of
<em>every</em> type, even the abstract ones that ought to be a little more
mysterious; it’s easy to add new capabilities (e.g. Scala’s <code class="language-plaintext highlighter-rouge">&gt;: Null</code>
constraint, if you really <em>must</em> use <code class="language-plaintext highlighter-rouge">null</code>), but taking them away is
much, much harder.</p>

<p>Furthering this spirit of making good programs easier to write and bad
programs harder to write, a useful area of research in Scala might be
making signatures such as that of <code class="language-plaintext highlighter-rouge">mungeIDsSafely</code> nicer, or
signatures such as that of <code class="language-plaintext highlighter-rouge">mungeIDs</code> uglier.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/09/05/three-types-of-strings.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/09/05/three-types-of-strings.html</guid>
      </item>
    
      <item>
        <title>Announcement: cats 1.0.0-MF</title>
        
          <dc:creator>kailuowang</dc:creator>
                
        <description><![CDATA[<p>The <a href="https://github.com/typelevel/cats">cats</a> maintainer team is proud to announce the <strong>cats 1.0.0-MF</strong> release.</p>

<p><strong>MF</strong> stands for <em>milestone final</em>,
this will be the last release before cats 1.0.0-RC1 which will be followed by cats 1.0 shortly.</p>

<p>The main purpose/focus of this release is to offer a relatively stable API to work with prior to the official 1.0.
It can be deemed as a proposal for the final cats 1.0 API. Please help test it and report any improvements/fixes
needed either in the <a href="https://gitter.im/typelevel/cats-dev">cats-dev gitter channel</a> or as <a href="https://github.com/typelevel/cats/issues/new">github issues</a>.
Post cats 1.0, we will keep API stable and maintain strong binary compatibility.</p>

<p>Highlights of the major new features include but not limited to:</p>

<ul>
  <li><a href="https://github.com/typelevel/cats/pull/1117">#1117</a>: Stack safe <code class="language-plaintext highlighter-rouge">foldLeftM</code> without <code class="language-plaintext highlighter-rouge">Free</code>, by @TomasMikula</li>
  <li><a href="https://github.com/typelevel/cats/pull/1598">#1598</a>: A <code class="language-plaintext highlighter-rouge">ReaderWriterStateT</code> data type, by @iravid</li>
  <li><a href="https://github.com/typelevel/cats/pull/1526">#1526</a> and <a href="https://github.com/typelevel/cats/pull/1596">#1596</a>: <code class="language-plaintext highlighter-rouge">InjectK</code> for free programs, by @tpolecat and @andyscott</li>
  <li><a href="https://github.com/typelevel/cats/pull/1602">#1602</a>: Stack-safe <code class="language-plaintext highlighter-rouge">Coyoneda</code>, by @edmundnoble</li>
  <li><a href="https://github.com/typelevel/cats/pull/1728">#1728</a>: <code class="language-plaintext highlighter-rouge">As</code> class which represents subtyping relationships (<code class="language-plaintext highlighter-rouge">Liskov</code>), by @stew</li>
  <li><a href="https://github.com/typelevel/cats/pull/1178">#1178</a>: <code class="language-plaintext highlighter-rouge">Is</code> constructor for Leibniz equality, by @tel</li>
  <li><a href="https://github.com/typelevel/cats/pull/1748">#1748</a>: Stack-safe <code class="language-plaintext highlighter-rouge">FreeApplicative</code>, by @edmundnoble</li>
  <li><a href="https://github.com/typelevel/cats/pull/1611">#1611</a>: <code class="language-plaintext highlighter-rouge">NonEmptyTraverse</code>. by @LukaJCB</li>
</ul>

<p>Overall 1.0.0-MF has over 120 merged pull requests of API additions, bug fixes, documentation and misc
improvements from 44 contributors. For the complete change list please go to the <a href="https://github.com/typelevel/cats/releases/tag/v1.0.0-MF">release notes</a>.</p>

<h3 id="migration">Migration</h3>
<p>There are more breaking changes in this release - we want to include as many necessary breaking changes as possible in this release
to reach stability. Please follow the <a href="https://github.com/typelevel/cats/blob/master/CHANGES.md#to-migrate-from-090">migration guide</a> from 0.9.0 in the  <a href="https://github.com/typelevel/cats/releases/tag/v1.0.0-MF">release notes</a>.</p>

<h3 id="whats-next">What’s next</h3>

<p>Although we made many improvements to the documentation in this release, it’s still by and large a WIP.
The next release 1.0.0-RC1 will focus documentation and API refinement based on community feedback.
RC1 is scheduled to be released in September. Unless the amount of bug fixes warrants a RC2, it’s likely that
we’ll release cats 1.0.0 within a couple weeks after RC1.</p>

<h3 id="credits">Credits</h3>
<p>Last but not least, many thanks to the contributors that make this release possible:</p>

<ul>
  <li>@alexandru</li>
  <li>@andyscott</li>
  <li>@BenFradet</li>
  <li>@Blaisorblade</li>
  <li>@cb372</li>
  <li>@ceedubs</li>
  <li>@cranst0n</li>
  <li>@DavidGregory084</li>
  <li>@denisftw</li>
  <li>@DieBauer</li>
  <li>@diesalbla</li>
  <li>@djspiewak</li>
  <li>@durban</li>
  <li>@edmundnoble</li>
  <li>@iravid</li>
  <li>@jtjeferreira</li>
  <li>@julien-truffaut</li>
  <li>@jyane</li>
  <li>@kailuowang</li>
  <li>@larsrh</li>
  <li>@Leammas</li>
  <li>@leandrob13</li>
  <li>@LukaJCB</li>
  <li>@markus1189</li>
  <li>@milessabin</li>
  <li>@n4to4</li>
  <li>@oskoi</li>
  <li>@peterneyens</li>
  <li>@PeterPerhac</li>
  <li>@raulraja</li>
  <li>@RawToast</li>
  <li>@sellout</li>
  <li>@stew</li>
  <li>@sullivan-</li>
  <li>@SystemFw</li>
  <li>@takayuky</li>
  <li>@tel</li>
  <li>@TomasMikula</li>
  <li>@tpolecat</li>
  <li>@wedens</li>
  <li>@xavier-fernandez</li>
  <li>@xuwei-k</li>
  <li>@yilinwei</li>
  <li>@zainab-ali</li>
</ul>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 04 Aug 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/08/04/cats-1.0-mf.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/08/04/cats-1.0-mf.html</guid>
      </item>
    
      <item>
        <title>Validated Configurations with Ciris</title>
        
          <dc:creator>vlovgr</dc:creator>
                
        <description><![CDATA[<p>The need for configuration arises in almost every application, as we want to be able to run in different environments – for example, local, testing, and production environments. Configurations are also used as a way to keep secrets, like passwords and keys, out of source code and version control. By having configurations as untyped structured data in files, we can change and override settings without having to recompile our software.</p>

<p>In this blog post, we’ll take a look at configurations with configuration files, to see how we can make the loading process less error-prone, while overcoming obstacles with boilerplate, testing, and validation. We’ll also identify when it’s suitable to use Scala as a configuration language for improved compile-time safety, convenience, and flexibility; and more specifically, how <a href="https://cir.is">Ciris</a> helps out.</p>

<h3 id="configuration-files">Configuration Files</h3>
<p>Traditionally, configuration files, and libraries like <a href="https://github.com/typesafehub/config">Typesafe Config</a>, have been used to load configurations. This involves writing your configuration file, declaring values and how they’re loaded, and then writing very similar Scala code for loading that configuration. That kind of boilerplate code typically looks something along the lines of the following example.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.typesafe.config.</span><span class="o">{</span><span class="nc">Config</span><span class="o">,</span> <span class="nc">ConfigFactory</span><span class="o">}</span>

<span class="c1">// The settings class, wrapping Typesafe Config
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">config</span><span class="k">:</span> <span class="kt">Config</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">http</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apiKey</span> <span class="k">=</span> <span class="nv">config</span><span class="o">.</span><span class="py">getString</span><span class="o">(</span><span class="s">"http.api-key"</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">timeoutSeconds</span> <span class="k">=</span> <span class="nv">config</span><span class="o">.</span><span class="py">getInt</span><span class="o">(</span><span class="s">"http.timeout-seconds"</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">port</span> <span class="k">=</span> <span class="nv">config</span><span class="o">.</span><span class="py">getInt</span><span class="o">(</span><span class="s">"http.port"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// The configuration file, here represented in code
</span><span class="k">val</span> <span class="nv">config</span> <span class="k">=</span>
  <span class="nv">ConfigFactory</span><span class="o">.</span><span class="py">parseString</span><span class="o">(</span>
    <span class="s">"""
      |http {
      |  api-key = ${?API_KEY}
      |  timeout-seconds = 10
      |  port = 989
      |}
    """</span><span class="o">.</span><span class="py">stripMargin</span>
  <span class="o">).</span><span class="py">resolve</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">settings</span> <span class="k">=</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">config</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">show</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span>
<span class="c1">// Settings(Config(SimpleConfigObject({"http":{"port":989,"timeout-seconds":10}})))
</span></code></pre></div></div>

<p>This is a tedious, error-prone process that rarely sees any testing efforts. <a href="https://github.com/pureconfig/pureconfig">PureConfig</a> (and other libraries, like <a href="https://github.com/47deg/case-classy">Case Classy</a>) were created to remove that boilerplate. Using macros and conventions, they inspect your configuration model (nested case classes) and generate the necessary configuration loading code. This eliminates a lot of errors typically associated with configuration loading. Following is an example of how you can load that very same configuration with PureConfig.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HttpSettings</span><span class="o">(</span>
  <span class="n">apiKey</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">timeoutSeconds</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">http</span><span class="k">:</span> <span class="kt">HttpSettings</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">settings</span> <span class="k">=</span> <span class="nv">pureconfig</span><span class="o">.</span><span class="py">loadConfig</span><span class="o">[</span><span class="kt">Settings</span><span class="o">](</span><span class="n">config</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">show</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span>
<span class="c1">// Left(ConfigReaderFailures(KeyNotFound("http.api-key", None, Set()), List()))
</span></code></pre></div></div>

<h3 id="encoding-validation">Encoding Validation</h3>
<p>In both previous examples, we do not check whether our configurations are valid to use with our application. In the case of Typesafe Config, we hit a runtime exception if the key is missing or if the type conversion fails, and in PureConfig’s case, we will instead get a <code class="language-plaintext highlighter-rouge">ConfigReaderFailures</code>. But in neither case do we care what values are being loaded, as long as they can be converted to the appropriate types. For example, we might require a key of certain length and that it only contains certain characters, the timeout needs to be positive, and the port must be a non-system port number (value in the inclusive range between 1024 and 65535).</p>

<p>You could write an additional validation step to ensure the configuration is valid after it has been loaded – which can be tedious to write and requires testing. One could also argue that the types of the configuration values are too permissive: why use <code class="language-plaintext highlighter-rouge">String</code> for the key if you do not accept all <code class="language-plaintext highlighter-rouge">String</code> values? And why use an <code class="language-plaintext highlighter-rouge">Int</code> for timeout and port, if you only allow a limited subset of values?</p>

<p>We could write these custom types ourselves, including the validation logic, and tell PureConfig how to load them – which would be tedious to write for many types and would require testing. Another alternative is to use <a href="https://github.com/fthomas/refined">refined</a>, which allows you to do type-level refinements (apply predicates) to types. I found this approach so useful that I wrote a small integration between PureConfig and refined at the end of last year (see <a href="https://blog.vlovgr.se/posts/2016-12-24-refined-configuration.html">blog post</a>), so that PureConfig can now load refined’s types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.api.Refined</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.numeric.Interval</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.pureconfig._</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.string.MatchesRegex</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.types.numeric.PosInt</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.W</span>

<span class="k">type</span> <span class="kt">ApiKey</span> <span class="o">=</span> <span class="nc">String</span> <span class="nc">Refined</span> <span class="nc">MatchesRegex</span><span class="o">[</span><span class="kt">W.`</span><span class="err">"</span><span class="o">[</span><span class="kt">a-zA-Z0-</span><span class="err">9</span><span class="o">]{</span><span class="err">25</span>,<span class="err">40</span><span class="o">}</span><span class="err">"</span><span class="kt">`.T</span><span class="o">]</span>

<span class="k">type</span> <span class="kt">NonSystemPort</span> <span class="o">=</span> <span class="nc">Int</span> <span class="nc">Refined</span> <span class="nv">Interval</span><span class="o">.</span><span class="py">Closed</span><span class="o">[</span><span class="kt">W.`</span><span class="err">1024</span><span class="kt">`.T</span>, <span class="kt">W.`</span><span class="err">65535</span><span class="kt">`.T</span><span class="o">]</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HttpSettings</span><span class="o">(</span>
  <span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span><span class="o">,</span>
  <span class="n">timeoutSeconds</span><span class="k">:</span> <span class="kt">PosInt</span><span class="o">,</span>
  <span class="n">port</span><span class="k">:</span> <span class="kt">NonSystemPort</span>
<span class="o">)</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">http</span><span class="k">:</span> <span class="kt">HttpSettings</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">settings</span> <span class="k">=</span> <span class="nv">pureconfig</span><span class="o">.</span><span class="py">loadConfig</span><span class="o">[</span><span class="kt">Settings</span><span class="o">](</span><span class="n">config</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">show</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span>
<span class="c1">// Left(
//   ConfigReaderFailures(
//     KeyNotFound("http.api-key", None, Set()),
//     List(
//       CannotConvert(
//         "989",
//         "eu.timepit.refined.api.Refined[Int,eu.timepit.refined.boolean.And[eu.timepit.refined.boolean.Not[eu.timepit.refined.numeric.Less[Int(1024)]],eu.timepit.refined.boolean.Not[eu.timepit.refined.numeric.Greater[Int(65535)]]]]",
//         "Left predicate of (!(989 &lt; 1024) &amp;&amp; !(989 &gt; 65535)) failed: Predicate (989 &lt; 1024) did not fail.",
//         None,
//         "http.port"
//       )
//     )
//   )
// )
</span></code></pre></div></div>

<p>As you can see in the example above, refined already contains type aliases for many common refinement types, like <code class="language-plaintext highlighter-rouge">PosInt</code> (for <code class="language-plaintext highlighter-rouge">Int</code> values greater than zero). You can also easily define your own predicates, like the one for the key and port. The <code class="language-plaintext highlighter-rouge">W</code> here is a shorthand for <a href="https://github.com/milessabin/shapeless">shapeless</a>’ <code class="language-plaintext highlighter-rouge">Witness</code>: a way to encode literal-based singleton types (essentially, values on the type-level). If you’re using <a href="https://typelevel.org/scala/">Typelevel Scala</a> with the <code class="language-plaintext highlighter-rouge">-Yliteral-types</code> flag, you can write values directly in the type declaration, without having to use <code class="language-plaintext highlighter-rouge">Witness</code>.</p>

<p>If you’re not convinced configurations need to be validated, I can recommend reading the paper <a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-xu.pdf">Early Detection of Configuration Errors to Reduce Failure Damage</a>, and to read through the slides of Leif Wickland’s (one of the authors behind PureConfig) recent presentation <a href="http://leifwickland.github.io/presentations/configBomb/">Defusing the Configuration Time Bomb</a> on the subject.</p>

<p>In many ways, think of configurations as user input – would you happily accept any values provided to your application from its users? Probably not: you would validate the input, and sanitize it if possible. Think about configurations in the same way, except that the user here might happen to be a developer of the application. The key here, as discussed in the paper linked above, is to check that your configuration is valid as soon as possible, ideally at compile-time, or as soon as the application starts. We want to avoid situations where we’re running the application and suddenly discover that configuration values are invalid or cannot be loaded – or worse, continue running with an invalid configuration, not to discover issues until much later on.</p>

<h3 id="improving-compile-time-safety">Improving Compile-time Safety</h3>
<p>We’ve now got a way to encode validation in the types of our configurations, and a boilerplate-free way of loading values of those types from configuration files – is there still room for improvement? To answer that question, we first need to ask why we are using configuration files in the first place.</p>

<p>Whether you thought about it or not, the main reason for using configuration files is so that we can change settings without having to recompile the software. In my experience, most developers default to using configuration files, and almost always change values by pushing commits to a version control repository. This is followed by a new release of the software, either manually or via a <a href="https://www.agilealliance.org/glossary/continuous-integration">continuous integration</a> system. In scenarios like this, and in general when it’s easy to change and release software (particularly when employing <a href="https://www.agilealliance.org/glossary/continuous-deployment/">continuous deployment</a> practices), configuration files are not used for the benefit of being able to change values without recompile.</p>

<p>In such cases, why are we not writing the configurations directly in source code? Christopher Vogt has written an excellent <a href="https://medium.com/@cvogt/scala-as-a-configuration-language-f075b058a660">blog post</a> (and given a <a href="https://www.youtube.com/watch?v=ox4IhIL6ojg">presentation</a>) on the subject. The tricky part here is managing values which need to be dynamic in the environment (like the port to bind) and are secret (like passwords and keys). Depending on your requirements and preferences, you more or less have two alternatives.</p>

<ul>
  <li>
    <p>If you know which environments your application will run in, and what the configuration values will be in those environments, you can just include the configurations in your application code (if it has no secrets), or store, compile, and bundle the configuration separately. If you have a requirement that secrets shouldn’t touch persistent storage, this might not be a feasible alternative. You might also appreciate the fact that all code relating to your application is in the same version control repository and gets compiled together, in which case this approach might not be suitable.</p>
  </li>
  <li>
    <p>Alternatively, you can include the configuration in your application, but load secrets and values which need to be dynamic from the environment during runtime. This is necessary when configuration values cannot be determined beforehand – because you do not know what environment your application will run in, or if you use a vault (like <a href="https://github.com/fugue/credstash">credstash</a>, for example) or a configuration service (like <a href="https://zookeeper.apache.org">ZooKeeper</a>, for example) – or if you prefer having your configuration together with your application code and in the same version control repository.</p>
  </li>
</ul>

<p>In this post, we’ll only focus on the latter case. While it’s possible to not use any libraries in the latter case, loading values from the environment typically means dealing with: different environments and configuration sources, type conversions, error handling, and validation. This is where <a href="https://cir.is">Ciris</a> comes in: a small library, dependency-free at its core, helping you to deal with all of that more easily.</p>

<h3 id="introducing-ciris">Introducing Ciris</h3>
<p>Imagine for the moment that no part of your configuration is secret and that your application only ever runs in one environment. You can then just write your configuration in code.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.auto._</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Config</span><span class="o">(</span>
  <span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span><span class="o">,</span>
  <span class="n">timeoutSeconds</span><span class="k">:</span> <span class="kt">PosInt</span><span class="o">,</span>
  <span class="n">port</span><span class="k">:</span> <span class="kt">NonSystemPort</span>
<span class="o">)</span>

<span class="k">val</span> <span class="nv">config</span> <span class="k">=</span>
  <span class="nc">Config</span><span class="o">(</span>
    <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
    <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
    <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
  <span class="o">)</span>
</code></pre></div></div>

<p>You then realize that it’s a bad idea to put the key in the source code, because source code can easily get into the wrong hands. You decide that you’ll instead read an environment variable for the key. Since you want to make sure that your configuration is valid, you have used refinement types, so you’ll have to make sure to check that the key conforms to the predicate. You would also welcome a helpful error message if the key is missing or invalid. This sounds like more work than it should be, so let’s see how <a href="https://cir.is">Ciris</a> can help us.</p>

<p>Ciris method for loading configurations is <code class="language-plaintext highlighter-rouge">loadConfig</code> and it works in two steps: first define what to load, and then how to load the configuration. For reading a key from an environment variable, you can use <code class="language-plaintext highlighter-rouge">env[ApiKey]("API_KEY")</code> which reads the environment variable <code class="language-plaintext highlighter-rouge">API_KEY</code> as an <code class="language-plaintext highlighter-rouge">ApiKey</code>. Ciris has a refined integration in a separate module, so you just need to add an appropriate import. Loading the configuration is then just a function accepting the loaded values as arguments.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ciris._</span>
<span class="k">import</span> <span class="nn">ciris.refined._</span>

<span class="k">val</span> <span class="nv">config</span> <span class="k">=</span>
  <span class="nf">loadConfig</span><span class="o">(</span>
    <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">)</span>
  <span class="o">)</span> <span class="o">{</span> <span class="n">apiKey</span> <span class="k">=&gt;</span>
    <span class="nc">Config</span><span class="o">(</span>
      <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
      <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
      <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
    <span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">show</span><span class="o">(</span><span class="n">config</span><span class="o">)</span>
<span class="c1">// Left(ConfigErrors(MissingKey(API_KEY, Environment)))
</span></code></pre></div></div>

<p>Ciris deals with type conversions, error handling, and error accumulation, so you can focus on your configuration. The <code class="language-plaintext highlighter-rouge">loadConfig</code> method returns an <code class="language-plaintext highlighter-rouge">Either[ConfigErrors, T]</code> instance back, where <code class="language-plaintext highlighter-rouge">T</code> is the result of your configuration loading function. You can retrieve the accumulated error messages by using <code class="language-plaintext highlighter-rouge">messages</code> on <code class="language-plaintext highlighter-rouge">ConfigErrors</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="nv">config</span><span class="o">.</span><span class="py">left</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">messages</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// Left(Vector("Missing environment variable [API_KEY]"))
</span></code></pre></div></div>

<p>If we decided that the port needs to be dynamic as well, we can simply make that change. In the example below, we are using <code class="language-plaintext highlighter-rouge">prop</code> to read the <code class="language-plaintext highlighter-rouge">http.port</code> system property for the port to use. As you can see, you are free to mix configuration sources as you please. While we are reading environment variables and system properties in these examples, you could just as well use sources for some configuration services or vaults.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">config</span> <span class="k">=</span>
  <span class="nf">loadConfig</span><span class="o">(</span>
    <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
    <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
  <span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">apiKey</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Config</span><span class="o">(</span>
      <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
      <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
      <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
    <span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="nv">config</span><span class="o">.</span><span class="py">left</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">messages</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Missing environment variable [API_KEY]",
//     "Missing system property [http.port]"
//   )
// )
</span></code></pre></div></div>

<p>You might recognize the similarities between <code class="language-plaintext highlighter-rouge">loadConfig</code> and <code class="language-plaintext highlighter-rouge">ValidatedNel</code> with an <code class="language-plaintext highlighter-rouge">Apply</code> instance from <a href="https://typelevel.org/cats/">Cats</a>. That’s because it’s more or less how <code class="language-plaintext highlighter-rouge">loadConfig</code> works behind the scenes, except Ciris has its own custom implementation in order to be dependency-free in the core module.</p>

<h4 id="multiple-environments">Multiple Environments</h4>
<p>We still have to deal with multiple environments in our configuration, assuming there are differences between configurations, or how they are loaded, in the different environments. There are several ways you can do this with Ciris – one way is to define an enumeration with <a href="https://github.com/lloydmeta/enumeratum">enumeratum</a> and load values of that enumeration. Let’s say we want to use a default configuration when running the application locally, but want to keep the key and port dynamic in the other environments (testing and production). We start by defining an enumeration of the different environments.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">_root_.enumeratum._</span>

<span class="k">object</span> <span class="nc">environments</span> <span class="o">{</span>
  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">AppEnvironment</span> <span class="k">extends</span> <span class="nc">EnumEntry</span>
  <span class="k">object</span> <span class="nc">AppEnvironment</span> <span class="k">extends</span> <span class="nc">Enum</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Local</span> <span class="k">extends</span> <span class="nc">AppEnvironment</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Testing</span> <span class="k">extends</span> <span class="nc">AppEnvironment</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Production</span> <span class="k">extends</span> <span class="nc">AppEnvironment</span>

    <span class="k">val</span> <span class="nv">values</span> <span class="k">=</span> <span class="n">findValues</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can use the <code class="language-plaintext highlighter-rouge">withValue</code> method to define a requirement on a configuration value in order to be able to load our configuration. It works just like <code class="language-plaintext highlighter-rouge">loadConfig</code>, except it wraps your <code class="language-plaintext highlighter-rouge">loadConfig</code> statements (think of it as <code class="language-plaintext highlighter-rouge">flatMap</code>, while <code class="language-plaintext highlighter-rouge">loadConfig</code> is <code class="language-plaintext highlighter-rouge">map</code>). If no environment was specified in the environment variable <code class="language-plaintext highlighter-rouge">APP_ENV</code> or if it was set to <code class="language-plaintext highlighter-rouge">Local</code>, we will use a default configuration. We’ll load the configuration just like before for any other valid environments (testing and production).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">environments._</span>
<span class="k">import</span> <span class="nn">ciris.enumeratum._</span>

<span class="k">val</span> <span class="nv">config</span> <span class="k">=</span>
  <span class="nf">withValue</span><span class="o">(</span><span class="n">env</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]](</span><span class="s">"APP_ENV"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nv">AppEnvironment</span><span class="o">.</span><span class="py">Local</span><span class="o">)</span> <span class="o">|</span> <span class="nc">None</span> <span class="k">=&gt;</span>
      <span class="n">loadConfig</span> <span class="o">{</span>
        <span class="nc">Config</span><span class="o">(</span>
          <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
          <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
          <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
        <span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nf">loadConfig</span><span class="o">(</span>
        <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
        <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
      <span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">apiKey</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">Config</span><span class="o">(</span>
          <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
          <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
          <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
        <span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">show</span><span class="o">(</span><span class="n">config</span><span class="o">)</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span></code></pre></div></div>

<p>An alternative to the above is to have multiple entrypoints (<code class="language-plaintext highlighter-rouge">main</code> methods) in your application, each running the application with different configuration loading code (or using a default configuration) for the respective environment. Depending on how packaging and running of your application looks like across different environments, this may or may not be a suitable solution. Note that it’s very much possible to mix these approaches, and you should strive to find what works best in your case.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Runs the application with the provided configuration
</span><span class="k">def</span> <span class="nf">runApplication</span><span class="o">(</span><span class="n">config</span><span class="k">:</span> <span class="kt">Config</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="cm">/* omitted */</span> <span class="o">}</span>

<span class="k">object</span> <span class="nc">Local</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">runApplication</span> <span class="o">{</span>
      <span class="nc">Config</span><span class="o">(</span>
        <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
        <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
        <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
      <span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">TestingOrProduction</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">runApplication</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">config</span> <span class="k">=</span>
        <span class="nf">loadConfig</span><span class="o">(</span>
          <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
          <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
        <span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">apiKey</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">Config</span><span class="o">(</span>
            <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
            <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
            <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
          <span class="o">)</span>
        <span class="o">}</span>

      <span class="nv">config</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span>
        <span class="n">errors</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="n">s</span><span class="s">"Unable to load configuration: ${errors.messages}"</span><span class="o">),</span>
        <span class="n">identity</span>
      <span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="testing-configurations">Testing Configurations</h4>
<p>Writing your configurations in Scala means you have the flexibility to work with them as you want. You’re no longer limited to what can be done with configuration files. Sharing configurations between your application and tests is also very straightforward – simply make the configuration loading function (and the default configuration) available for the tests.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This can now be accessed from the tests
</span><span class="k">val</span> <span class="nv">defaultConfig</span> <span class="k">=</span>
  <span class="nc">Config</span><span class="o">(</span>
    <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
    <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
    <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
  <span class="o">)</span>

<span class="c1">// This can now be accessed from the tests
</span><span class="k">val</span> <span class="nv">configWith</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">NonSystemPort</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Config</span><span class="o">(</span>
      <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
      <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
      <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
    <span class="o">)</span>

<span class="k">val</span> <span class="nv">config</span> <span class="k">=</span>
  <span class="nf">withValue</span><span class="o">(</span><span class="n">env</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]](</span><span class="s">"APP_ENV"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nv">AppEnvironment</span><span class="o">.</span><span class="py">Local</span><span class="o">)</span> <span class="o">|</span> <span class="nc">None</span> <span class="k">=&gt;</span>
      <span class="nf">loadConfig</span><span class="o">(</span><span class="n">defaultConfig</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nf">loadConfig</span><span class="o">(</span>
        <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
        <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
      <span class="o">)(</span><span class="n">configWith</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>If you really want to unit test the configuration loading as well, you can do so with minor rewrites. Currently, we depend on some fixed configuration sources for environment variables and system properties (technically, system properties are mutable), but if we instead pass sources (<code class="language-plaintext highlighter-rouge">ConfigSource</code>s) as arguments, we can read values from those sources using the <code class="language-plaintext highlighter-rouge">read</code> method.</p>

<p>The <code class="language-plaintext highlighter-rouge">read</code> method normally looks for an implicit <code class="language-plaintext highlighter-rouge">ConfigSource</code> to read from, which would have been perfect if we only used a single source. But since we have multiple sources here, we instead use <code class="language-plaintext highlighter-rouge">read</code> to redefine <code class="language-plaintext highlighter-rouge">env</code> and <code class="language-plaintext highlighter-rouge">prop</code> to read from the provided sources. <code class="language-plaintext highlighter-rouge">ConfigReader[T]</code> captures the ability to convert from <code class="language-plaintext highlighter-rouge">String</code> to <code class="language-plaintext highlighter-rouge">T</code>, where the <code class="language-plaintext highlighter-rouge">String</code> value has been read from a <code class="language-plaintext highlighter-rouge">ConfigSource</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">config</span><span class="o">(</span>
  <span class="n">envs</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
  <span class="n">props</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">ConfigErrors</span>, <span class="kt">Config</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Custom env which reads from envs
</span>  <span class="k">def</span> <span class="nf">env</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ConfigReader</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">read</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">)(</span><span class="n">envs</span><span class="o">,</span> <span class="nc">ConfigReader</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

  <span class="c1">// Custom prop which reads from props
</span>  <span class="k">def</span> <span class="nf">prop</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ConfigReader</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">read</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">)(</span><span class="n">props</span><span class="o">,</span> <span class="nc">ConfigReader</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

  <span class="nf">withValue</span><span class="o">(</span><span class="n">env</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]](</span><span class="s">"APP_ENV"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nv">AppEnvironment</span><span class="o">.</span><span class="py">Local</span><span class="o">)</span> <span class="o">|</span> <span class="nc">None</span> <span class="k">=&gt;</span>
      <span class="nf">loadConfig</span><span class="o">(</span><span class="n">defaultConfig</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nf">loadConfig</span><span class="o">(</span>
        <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
        <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
      <span class="o">)(</span><span class="n">configWith</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We’ll then define a couple of helper methods for creating <code class="language-plaintext highlighter-rouge">ConfigSource</code>s from key-value pairs. The <code class="language-plaintext highlighter-rouge">ConfigSource</code> type parameter is the type of keys the source can read, which is <code class="language-plaintext highlighter-rouge">String</code> for both environment variables and system properties. The <code class="language-plaintext highlighter-rouge">ConfigKeyType</code> is basically the name of the key that can be read, for example <code class="language-plaintext highlighter-rouge">environment variable</code>. Below we’re using predefined instances in the <code class="language-plaintext highlighter-rouge">ConfigKeyType</code> companion object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">envs</span><span class="o">(</span><span class="n">entries</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">ConfigSource</span><span class="o">.</span><span class="py">fromMap</span><span class="o">(</span><span class="nv">ConfigKeyType</span><span class="o">.</span><span class="py">Environment</span><span class="o">)(</span><span class="nv">entries</span><span class="o">.</span><span class="py">toMap</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">props</span><span class="o">(</span><span class="n">entries</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">ConfigSource</span><span class="o">.</span><span class="py">fromMap</span><span class="o">(</span><span class="nv">ConfigKeyType</span><span class="o">.</span><span class="py">Property</span><span class="o">)(</span><span class="nv">entries</span><span class="o">.</span><span class="py">toMap</span><span class="o">)</span>
</code></pre></div></div>

<p>We can test our <code class="language-plaintext highlighter-rouge">config</code> method using different combinations of environment variables and system properties. Note that <code class="language-plaintext highlighter-rouge">envs</code> and <code class="language-plaintext highlighter-rouge">props</code> have the same type, so if you want to avoid using them interchangeably, you can define custom wrapper types for them. We’ll leave that out here for sake of simplicity. I’ve found that it’s not very common to read values from more than one <code class="language-plaintext highlighter-rouge">ConfigSource</code>, but as it’s definitely possible, it can be worth making sure you do not mix them up.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="nf">config</span><span class="o">(</span><span class="nf">envs</span><span class="o">(),</span> <span class="nf">props</span><span class="o">())</span> <span class="o">}</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="nf">config</span><span class="o">(</span>
    <span class="nf">envs</span><span class="o">(</span><span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Local"</span><span class="o">),</span>
    <span class="nf">props</span><span class="o">()</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="nf">config</span><span class="o">(</span>
    <span class="nf">envs</span><span class="o">(</span><span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"QA"</span><span class="o">),</span>
    <span class="nf">props</span><span class="o">()</span>
  <span class="o">).</span><span class="py">left</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Environment variable [APP_ENV] with value [QA] cannot be converted to type [$line34.$read$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$environments$AppEnvironment]"
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="nf">config</span><span class="o">(</span>
    <span class="nf">envs</span><span class="o">(</span><span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">),</span>
    <span class="nf">props</span><span class="o">()</span>
  <span class="o">).</span><span class="py">left</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Missing environment variable [API_KEY]",
//     "Missing system property [http.port]"
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="nf">config</span><span class="o">(</span>
    <span class="nf">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"changeme"</span>
    <span class="o">),</span>
    <span class="nf">props</span><span class="o">()</span>
  <span class="o">).</span><span class="py">left</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Environment variable [API_KEY] with value [changeme] cannot be converted to type [eu.timepit.refined.api.Refined[String,eu.timepit.refined.string.MatchesRegex[java.lang.String(\"[a-zA-Z0-9]{25,40}\")]]]: Predicate failed: \"changeme\".matches(\"[a-zA-Z0-9]{25,40}\").",
//     "Missing system property [http.port]"
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="nf">config</span><span class="o">(</span>
    <span class="nf">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"X9aKACPtircCrrFKYhwPr7fXx8srow"</span>
    <span class="o">),</span>
    <span class="nf">props</span><span class="o">()</span>
  <span class="o">).</span><span class="py">left</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(Vector("Missing system property [http.port]"))
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="nf">config</span><span class="o">(</span>
    <span class="nf">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"X9aKACPtircCrrFKYhwPr7fXx8srow"</span>
    <span class="o">),</span>
    <span class="nf">props</span><span class="o">(</span><span class="s">"http.port"</span> <span class="o">-&gt;</span> <span class="s">"900"</span><span class="o">)</span>
  <span class="o">).</span><span class="py">left</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "System property [http.port] with value [900] cannot be converted to type [eu.timepit.refined.api.Refined[Int,eu.timepit.refined.numeric.Interval.Closed[Int(1024),Int(65535)]]]: Left predicate of (!(900 &lt; 1024) &amp;&amp; !(900 &gt; 65535)) failed: Predicate (900 &lt; 1024) did not fail."
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="nf">config</span><span class="o">(</span>
    <span class="nf">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"X9aKACPtircCrrFKYhwPr7fXx8srow"</span>
    <span class="o">),</span>
    <span class="nf">props</span><span class="o">(</span><span class="s">"http.port"</span> <span class="o">-&gt;</span> <span class="s">"4000"</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Right(Config(X9aKACPtircCrrFKYhwPr7fXx8srow, 10, 4000))
</span></code></pre></div></div>

<p>Finally, when running the application, simply provide the actual <code class="language-plaintext highlighter-rouge">ConfigSource</code>s for environment variables and system properties.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="nf">config</span><span class="o">(</span><span class="nv">ConfigSource</span><span class="o">.</span><span class="py">Environment</span><span class="o">,</span> <span class="nv">ConfigSource</span><span class="o">.</span><span class="py">Properties</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span></code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>
<p>In this blog post, we’ve seen how we can make the configuration loading process, with configuration files, less error-prone, by eliminating the boilerplate code with <a href="https://github.com/pureconfig/pureconfig">PureConfig</a>, and encoding validation with <a href="https://github.com/fthomas/refined">refined</a> – seeing how the two libraries can work together seamlessly.</p>

<p>We’ve also identified cases where we can use Scala as a configuration language, seeing that it’s particularly suitable in cases where it’s easy to change and deploy software. We’ve introduced the challenge of loading configuration values from the environment and seen how <a href="https://cir.is">Ciris</a> can help you with that, letting you focus on the configuration. We’ve seen that Scala configurations can provide more compile-time safety and flexibility than traditional configurations with configuration files.</p>

<p>If you’re looking for more information on Ciris, the project’s website (<a href="https://cir.is">https://cir.is</a>) is a good start.<br />
There’s also a <a href="https://cir.is/docs/basics">usage guide</a> and <a href="https://cir.is/api">API documentation</a> which expands on what’s been discussed here.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/06/21/ciris.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/06/21/ciris.html</guid>
      </item>
    
      <item>
        <title>Compile time dimensional analysis with Libra</title>
        
          <dc:creator>zainabali</dc:creator>
                
        <description><![CDATA[<h2 id="dimensional-analysis">Dimensional analysis</h2>

<p>When we code, we code in numbers - doubles, floats and ints.  Those numbers always represent real world quantities.</p>

<p>For example, the number of people in a room can be represented as an integer, as can the number of chairs.
Adding people and chairs together gives a nonsensical result, but dividing the number of people by the number of chairs gives a useful indicator of how full up the room is.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">numberOfPeople</span> <span class="k">=</span> <span class="mi">9</span>
<span class="k">val</span> <span class="nv">numberOfChairs</span> <span class="k">=</span> <span class="mi">10</span>
<span class="n">numberOfPeople</span> <span class="o">+</span> <span class="n">numberOfChairs</span> <span class="c1">// this is a bug
</span><span class="nv">numberOfPeople</span><span class="o">.</span><span class="py">toDouble</span> <span class="o">/</span> <span class="nv">numberOfChairs</span><span class="o">.</span><span class="py">toDouble</span> <span class="c1">// this is useful
</span></code></pre></div></div>

<p>This is actually a form of dimensional analysis.  We’re mentally assigning the dimension <code class="language-plaintext highlighter-rouge">Person</code> to the quantity of people, and <code class="language-plaintext highlighter-rouge">Chair</code> to the quantity of chairs.  Dimensional analysis can be summarized in two laws.</p>

<ol>
  <li>Quantities can only be added or subtracted to quantities of the same dimension</li>
  <li>Quantities of different dimensions can be multiplied or divided</li>
</ol>

<h3 id="why-is-it-important">Why is it important?</h3>

<p>Ignoring the laws can result in serious problems. 
Take the Mars Climate Orbiter, a $200 million space probe which successfully reached Mars after a year long voyage, but suddenly crashed into the Martian atmosphere on arrival.  Most components on the orbiter were using metric units, however a single component was sending instructions in Imperial units.  The other components did not detect this, and instead began a sudden descent causing the orbiter to burn up.  This was a simple unit conversion error!  It was a basic mistake that could have been easily avoided.  It should have been picked up during testing, or in the runtime validation layer.</p>

<p>In fact, it could even have been caught at compile time.</p>

<h3 id="compile-time-dimensional-analysis">Compile time dimensional analysis</h3>

<p>We’re going to use a similar problem to demonstrate compile time dimensional analysis.
To fit with the theme of rocket physics, we will tackle a rocket launch towards the distant constellation of Libra.
We’ll begin by working through our calculation in doubles before adding compile time safety with dependent types and finally supporting compile time dimensional analysis with typeclass induction.</p>

<h2 id="destination-alpha-librae">Destination: Alpha Librae</h2>

<p>The star that we’re aiming for is Alpha Librae.  This is pretty far, so we can only send one very small person.  We have been given the following quantities to work with:</p>

<ul>
  <li>rocket mass of a small person - 40kg</li>
  <li>fuel mass of a lot of fuel - 10<sup>4</sup>kg</li>
  <li>exhaust speed of a decent fuel - 10<sup>6</sup>ms<sup>-1</sup></li>
  <li>distance to Alpha Librae - 77 ly</li>
</ul>

<p>We want to calculate when the rocket will arrive.</p>

<p>To do so, we’re going to make use of a formula known as the <em>Ideal Rocket Equation</em>.
This calculates the speed of a rocket in ideal conditions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketSpeed</span> <span class="k">=</span> <span class="n">exhaustSpeed</span> <span class="o">*</span> <span class="nf">log</span><span class="o">((</span><span class="n">rocketMass</span> <span class="o">+</span> <span class="n">fuelMass</span><span class="o">)</span> <span class="o">/</span> <span class="n">rocketMass</span><span class="o">)</span>
</code></pre></div></div>
<p>Once we have the speed, we can work out the travel time.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">rocketSpeed</span>
</code></pre></div></div>

<h3 id="plugging-the-numbers-in">Plugging the numbers in</h3>

<p>Let’s do what we’re used to doing and use doubles:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketSpeed</span> <span class="k">=</span> <span class="mf">1000000.0</span> <span class="o">*</span> <span class="nf">log</span><span class="o">((</span><span class="mf">40.0</span> <span class="o">+</span> <span class="mf">10000.0</span><span class="o">)</span> <span class="o">/</span> <span class="mf">40.0</span><span class="o">)</span>
<span class="c1">// rocketSpeed: Double = 5525452.939131783
</span>
<span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="mf">77.0</span> <span class="o">/</span> <span class="n">rocketSpeed</span>
<span class="c1">// time: Double = 1.39355091515989E-5
</span></code></pre></div></div>

<p>Fantastic! We can get to Libra in less than a day!</p>

<p>Unfortunately, this time estimate is too far off to be valid.  We can’t get to Libra that quickly at light speed, let alone rocket speed.  We’ve clearly made a mistake somewhere.  Instead of pouring over our code to find out where that is, let’s try and use the compiler.</p>

<h3 id="using-types">Using types</h3>

<p>We can add some type safety to this problem by using a case class to represent each quantity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">A</code> represents the quantity dimension. So given the following dimensions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Kilogram</span>
<span class="k">type</span> <span class="kt">Metre</span>
<span class="k">type</span> <span class="kt">Second</span>
<span class="k">type</span> <span class="kt">MetresPerSecond</span>
<span class="k">type</span> <span class="kt">C</span>
<span class="k">type</span> <span class="kt">LightYear</span>
<span class="k">type</span> <span class="kt">Year</span>
</code></pre></div></div>

<p>We can create quantities:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Kilogram</span><span class="o">](</span><span class="mf">40.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">fuelMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Kilogram</span><span class="o">](</span><span class="mf">10000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">exhaust</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecond</span><span class="o">](</span><span class="mf">1000000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">distance</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">LightYear</span><span class="o">](</span><span class="mf">77.0</span><span class="o">)</span>
</code></pre></div></div>

<p>It’s important to note that these are <em>types</em>, not classes.  We never instantiate a <code class="language-plaintext highlighter-rouge">MetresPerSecond</code> - we’re just using it to differentiate between <code class="language-plaintext highlighter-rouge">Quantity[MetresPerSecond]</code> and <code class="language-plaintext highlighter-rouge">Quantity[Year]</code> at the type level.</p>

<p>So how does this change the code?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketSpeed</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecond</span><span class="o">](</span><span class="nv">exhaust</span><span class="o">.</span><span class="py">value</span> <span class="o">*</span> <span class="nf">log</span><span class="o">((</span><span class="nv">rocketMass</span><span class="o">.</span><span class="py">value</span> <span class="o">+</span> <span class="nv">fuelMass</span><span class="o">.</span><span class="py">value</span><span class="o">)</span> <span class="o">/</span> <span class="nv">rocketMass</span><span class="o">.</span><span class="py">value</span><span class="o">))</span>
<span class="c1">// rocketSpeed: Quantity[Types.MetresPerSecond] = Quantity(5525452.939131783)
</span>
<span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Year</span><span class="o">](</span><span class="nv">distance</span><span class="o">.</span><span class="py">value</span> <span class="o">/</span> <span class="nv">rocketSpeed</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
<span class="c1">// time: Quantity[Types.Year] = Quantity(1.39355091515989E-5)
</span></code></pre></div></div>

<p>In short, it doesn’t. The code might be clearer, but we don’t know what the bug is.  This is because the compiler isn’t doing anything with the types we’ve added.</p>

<h3 id="operating-on-quantities">Operating on quantities</h3>

<p>We can encode our first law of addition at compile time by creating a function to add quantities:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">q0</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="nv">q0</span><span class="o">.</span><span class="py">value</span> <span class="o">+</span> <span class="nv">q1</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
</code></pre></div></div>

<p>This ensures that quantities can only be added to other quantities of the same type.  Trying to add quantities of different types will result in a compilation error.</p>

<p>A quantity can also be multiplied by a dimensionless scalar value to give a quantity of the same dimension.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">times</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="nv">q</span><span class="o">.</span><span class="py">value</span> <span class="o">*</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div></div>

<p>It would be great if we could divide quantities too.  Writing a divide function is more difficult:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">Magic</span><span class="o">](</span><span class="n">q0</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">Magic</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Magic</span><span class="o">](</span><span class="nv">q0</span><span class="o">.</span><span class="py">value</span> <span class="o">/</span> <span class="nv">q1</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
</code></pre></div></div>

<p>There’s a clear problem with trying to do this.  When we divide a quantity by another, we don’t know what the <code class="language-plaintext highlighter-rouge">Magic</code> output type should be.
The output type is dependent on what the input types are (for example, dividing <code class="language-plaintext highlighter-rouge">Metre</code> by <code class="language-plaintext highlighter-rouge">Second</code> should give <code class="language-plaintext highlighter-rouge">MetresPerSecond</code>).  The compiler needs a way of working out what the output is, provided that it knows the input types.</p>

<h3 id="dependent-types">Dependent types</h3>

<p>What we actually want is a dependent type.  A division operation should occur at the type level, taking two input types and supplying a dependent output type.
We can create the trait <code class="language-plaintext highlighter-rouge">Divide</code> with a dependent output type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We also need to define an <code class="language-plaintext highlighter-rouge">Aux</code> type alias.  This is known as the Aux pattern and makes it easier to refer to all three types at once.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Divide</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">Out0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Out0</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can create instances of this divide typeclass with different output types, so the output type is dependent on the value of the divide typeclass instance.</p>

<p>When dividing, the compiler looks for this implicit typeclass instance and returns a quantity corresponding to the output type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">q0</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">d.Out</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Quantity</span><span class="o">[</span><span class="kt">d.Out</span><span class="o">](</span><span class="nv">q0</span><span class="o">.</span><span class="py">value</span> <span class="o">/</span> <span class="nv">q1</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
</code></pre></div></div>

<p>So given that we want to divide <code class="language-plaintext highlighter-rouge">A</code> by <code class="language-plaintext highlighter-rouge">B</code>, the compiler will look for a value of <code class="language-plaintext highlighter-rouge">Divide[A, B]</code> and find the <code class="language-plaintext highlighter-rouge">Out</code> type of it.  If no instance exists, the code doesn’t compile.</p>

<p>We’ll need some more types to represent the result of a division:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">LightYearSecondsPerMetre</span>
<span class="k">type</span> <span class="kt">MetresPerSecondPerC</span>
<span class="k">type</span> <span class="kt">Dimensionless</span>
</code></pre></div></div>

<p>And we’ll need to write instances for all combinations of dimensions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">kgDivideKg</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="kt">Kilogram</span>, <span class="kt">Dimensionless</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="kt">Kilogram</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Dimensionless</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">lyDivideC</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">C</span>, <span class="kt">Year</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">C</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Year</span> <span class="o">}</span>
	
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">lyDivideMps</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">MetresPerSecond</span>, <span class="kt">LightYearSecondsPerMetre</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">MetresPerSecond</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">LightYearSecondsPerMetre</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">mpsDivideC</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">C</span>, <span class="kt">MetresPerSecondPerC</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">C</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">MetresPerSecondPerC</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">mpsDivideMpsPerC</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">MetresPerSecondPerC</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">MetresPerSecondPerC</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">C</span> <span class="o">}</span>
</code></pre></div></div>

<p>And so on.</p>

<p>Unfortunately, there are an infinite number of combinations, so there are an infinite number of instances.
Nevertheless, let’s plough on with the ones we’ve written.  We can modify our rocket equation to use <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">times</code> and <code class="language-plaintext highlighter-rouge">divide</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketSpeed</span> <span class="k">=</span> <span class="nf">times</span><span class="o">(</span><span class="n">exhaust</span><span class="o">,</span> <span class="nf">log</span><span class="o">(</span><span class="nf">divide</span><span class="o">(</span><span class="nf">add</span><span class="o">(</span><span class="n">rocketMass</span><span class="o">,</span> <span class="n">fuelMass</span><span class="o">),</span> <span class="n">rocketMass</span><span class="o">).</span><span class="py">value</span><span class="o">))</span>
<span class="c1">// rocketSpeed: Quantity[Types.MetresPerSecond] = Quantity(5525452.939131783)
</span>
<span class="k">val</span> <span class="nv">time</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">Year</span><span class="o">]</span> <span class="k">=</span> <span class="nf">divide</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">rocketSpeed</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:31: error: type mismatch;
//  found   : Quantity[lyDivideMps.Out]
//     (which expands to)  Quantity[MoreTypes.LightYearSecondsPerMetre]
//  required: Quantity[Types.Year]
//        val time: Quantity[Year] = divide(distance, rocketSpeed)
//                                         ^
</span></code></pre></div></div>

<p>Great!  We’ve caught our bug!  The result was in <code class="language-plaintext highlighter-rouge">LightYearSecondsPerMetre</code>, not <code class="language-plaintext highlighter-rouge">Year</code>.  We made a unit conversion error, just like the Mars orbiter.</p>

<p>We can now fix this by adding a conversion:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">metresPerSecondPerC</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecondPerC</span><span class="o">]</span> <span class="k">=</span> <span class="nf">divide</span><span class="o">(</span><span class="nc">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecond</span><span class="o">](</span><span class="mf">300000000.0</span><span class="o">),</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="mf">1.0</span><span class="o">))</span>
<span class="c1">// metresPerSecondPerC: Quantity[MoreTypes.MetresPerSecondPerC] = Quantity(3.0E8)
</span>
<span class="k">val</span> <span class="nv">speedInC</span> <span class="k">=</span> <span class="nf">divide</span><span class="o">(</span><span class="n">rocketSpeed</span><span class="o">,</span> <span class="n">metresPerSecondPerC</span><span class="o">)</span>
<span class="c1">// speedInC: Quantity[mpsDivideMpsPerC.Out] = Quantity(0.018418176463772612)
</span>
<span class="k">val</span> <span class="nv">time</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">Year</span><span class="o">]</span> <span class="k">=</span> <span class="nf">divide</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">speedInC</span><span class="o">)</span>
<span class="c1">// time: Quantity[Types.Year] = Quantity(4180.65274547967)
</span></code></pre></div></div>

<p>It seems like it’s going to take a lot longer than we hoped to get to Libra.  Perhaps it’s unwise to send a person.</p>

<h2 id="automatic-derivation">Automatic derivation</h2>

<p>We found the bug, but we needed to explicitly write out typeclass instances for every combination of dimensions.
This might have worked for our small problem, but it just doesn’t scale in the long run.
We need to figure out a way of deriving the typeclass instances automatically.
To attempt this, we first need to generalize what a combination of dimensions actually is.</p>

<h3 id="representing-dimensions">Representing dimensions</h3>

<p>We can represent a combination of dimensions as a heterogeneous list (HList) of base dimensions.  HLists are defined in <a href="https://github.com/milessabin/shapeless">shapeless</a>, a cornerstone of most functional libraries, and can be thought of as a type level list.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">LightYearSeconds</span> <span class="o">=</span> <span class="nc">LightYear</span> <span class="o">::</span> <span class="nc">Second</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>This is good for multiples of dimensions, such as <code class="language-plaintext highlighter-rouge">LightYearSeconds</code>, but doesn’t represent combinations created from division, such as <code class="language-plaintext highlighter-rouge">MetresPerSecond</code>.
To do this, we need some way of representing integer exponents as types. We can represent integers as types using Singleton types.  We actually need these singleton types in type position.  This is supported by a new feature present in <a href="https://typelevel.org/scala/">Typelevel Scala</a>, called <a href="http://docs.scala-lang.org/sips/pending/42.type.html">literal types</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scalaOrganization</span> <span class="o">:=</span> <span class="s">"org.typelevel"</span>
<span class="n">scalacOptions</span> <span class="o">+=</span> <span class="s">"-Yliteral-types"</span>
</code></pre></div></div>

<p>We need to represent a key value pair of dimension and integer exponent. We could use a <code class="language-plaintext highlighter-rouge">Tuple</code> for this, but will use a shapeless <code class="language-plaintext highlighter-rouge">FieldType</code> instead.  This is similar to a <code class="language-plaintext highlighter-rouge">Tuple</code>, but is more compatible with some of shapeless’s typeclasses.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">MetresPerSecond</span> <span class="o">=</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">Metre</span>, <span class="err">1</span><span class="o">]</span> <span class="o">::</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">Second</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>It’s important to note that the number <code class="language-plaintext highlighter-rouge">1</code> above is a type, not a value.  Because it’s a type, the compiler can work with it.</p>

<h3 id="operations-on-singleton-types">Operations on Singleton types</h3>

<p>When we multiply and divide dimensions, we want to add or subtract from these exponents.</p>

<p>We can use a library called <a href="https://github.com/fthomas/singleton-ops">singleton ops</a> to do this.  This provides us with type level integer operations using the <code class="language-plaintext highlighter-rouge">OpInt</code> typeclass:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">OpInt</span><span class="o">.</span><span class="py">Aux</span><span class="o">[</span><span class="err">1</span> <span class="kt">+</span> <span class="err">2</span>, <span class="err">3</span><span class="o">]</span>
<span class="nv">OpInt</span><span class="o">.</span><span class="py">Aux</span><span class="o">[</span><span class="err">3</span> <span class="kt">*</span> <span class="err">2</span>, <span class="err">6</span><span class="o">]</span>
</code></pre></div></div>
<p>It also provides a convenient alias for integer singleton types</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">XInt</span> <span class="o">=</span> <span class="nc">Singleton</span> <span class="k">with</span> <span class="nc">Int</span>
</code></pre></div></div>

<p>The type <code class="language-plaintext highlighter-rouge">1</code>, for example, is a subtype of <code class="language-plaintext highlighter-rouge">XInt</code>.</p>

<h3 id="deriving-typeclass-instances">Deriving typeclass instances</h3>

<p>We now need to automatically derive typeclass instances of <code class="language-plaintext highlighter-rouge">Divide</code>.
To do this, we’re going to derive instances for <code class="language-plaintext highlighter-rouge">Invert</code> and <code class="language-plaintext highlighter-rouge">Multiply</code> operations first.
Deriving <code class="language-plaintext highlighter-rouge">Divide</code> then becomes much simpler.</p>

<p>The technique we’re going to use to automatically derive instances is known as typeclass induction.</p>

<h3 id="typeclass-induction">Typeclass Induction</h3>

<p>Aaron Levin gave a great introduction to induction in his talk earlier at the <a href="https://typelevel.org/event/2017-06-summit-copenhagen/">Typelevel Summit</a>.  In summary, you can derive an implicit typeclass instance for all cases by:</p>

<ol>
  <li>Providing it for the base case</li>
  <li>Providing it for the n + 1 case, given that the n case is provided</li>
</ol>

<p>This is similar to the mathematical method of proof by induction.</p>

<h3 id="invert">Invert</h3>

<p>We’re first going to derive inductive typeclass instances for the <code class="language-plaintext highlighter-rouge">Invert</code> operation.
Inverting a quantity raises it to the exponent of <code class="language-plaintext highlighter-rouge">-1</code>.  This means that the exponents of all dimensions must be negated.</p>

<p>For example, the inverse of <code class="language-plaintext highlighter-rouge">FieldType[Metre, 1] :: HNil</code> is <code class="language-plaintext highlighter-rouge">FieldType[Metre, -1] :: HNil</code>.
<code class="language-plaintext highlighter-rouge">Invert</code> takes one input type and returns one output type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">type</span> <span class="kt">Out</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Invert</span> <span class="o">{</span>
	<span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Out0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Out0</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To inductively derive typeclass instances for inverting, we need to prove that:</p>

<ol>
  <li>We can derive an instance for <code class="language-plaintext highlighter-rouge">HNil</code> (the base case)</li>
  <li>We can derive an instance for a non-empty HList (the n + 1 case), provided there is an existing instance for its tail (the n case)</li>
</ol>

<p>The base case operates on <code class="language-plaintext highlighter-rouge">HNil</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">baseCase</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">HNil</span> <span class="o">}</span>
</code></pre></div></div>

<p>The inductive case assumes that the tail has an instance, and derives an instance for the head by negating the exponent:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">inductiveCase</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">Exp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, <span class="kt">NExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, <span class="kt">Tail</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, 
  <span class="kt">OutTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span>
    <span class="k">implicit</span> <span class="n">negateEv</span><span class="k">:</span> <span class="kt">OpInt.Aux</span><span class="o">[</span><span class="kt">Negate</span><span class="o">[</span><span class="kt">Exp</span><span class="o">]</span>, <span class="kt">NExp</span><span class="o">],</span>
    <span class="n">tailEv</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">Tail</span>, <span class="kt">OutTail</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">Exp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">Tail</span>, <span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">NExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">OutTail</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">Exp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">Tail</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">NExp</span><span class="o">]</span> <span class="o">::</span> <span class="nc">OutTail</span>
<span class="o">}</span>
</code></pre></div></div>

<p>When the compiler looks for the implicit instance for <code class="language-plaintext highlighter-rouge">FieldType[Metre, 1] :: HNil</code>:</p>
<ul>
  <li>It finds that the <code class="language-plaintext highlighter-rouge">inductiveCase</code> method has a return type which fits the signature</li>
  <li>It can find the required evidence <code class="language-plaintext highlighter-rouge">negateEv</code> for negating <code class="language-plaintext highlighter-rouge">1</code> from singleton ops</li>
  <li>It requires evidence of an implicit instance for the tail <code class="language-plaintext highlighter-rouge">HNil</code></li>
  <li>It finds that <code class="language-plaintext highlighter-rouge">baseCase</code> provides this evidence</li>
</ul>

<p>So in hunting for implicit typeclass instance for the whole list, the compiler goes and finds instances for the tail (the n case), right up until the base.  If we provide an inductive proof with a <code class="language-plaintext highlighter-rouge">baseCase</code> and an <code class="language-plaintext highlighter-rouge">inductiveCase</code>, we fit the bill for what the compiler needs.</p>

<h3 id="multiply">Multiply</h3>

<p>Now that we’ve tested a basic example of induction, we can go on to a more complex one.</p>

<p>We want to multiply two HLists of dimensions together. This means that the exponents should be added.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Multiply</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">Out0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Out0</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is harder to make inductive because there are two input lists involved.  Luckily, we only need to recurse over one of them, as we can pick dimensions from the other using shapeless’s <code class="language-plaintext highlighter-rouge">Selector</code>.  We will recurse over the left list and can pick elements from the right list.</p>

<p>Our base case can be the same:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">baseCase</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">HNil</span>, <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">HNil</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can define the inductive case using the following logic:</p>
<ol>
  <li>Pick the exponent in the right list corresponding to the head dimension in the left list</li>
  <li>Add the left and right exponents together</li>
  <li>Filter the term from the right list to get the remaining elements</li>
  <li>Look for a typeclass instance for the left list tail and the remaining elements in the right list</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">inductiveCase</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">R</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">LExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span> , <span class="kt">RExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, 
  <span class="kt">OutExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, <span class="kt">RTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">LTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">OutTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span>
  <span class="k">implicit</span> <span class="n">pickEv</span><span class="k">:</span> <span class="kt">Selector.Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">D</span>, <span class="kt">RExp</span><span class="o">],</span>
  <span class="n">addEv</span><span class="k">:</span> <span class="kt">OpInt.Aux</span><span class="o">[</span><span class="kt">LExp</span> <span class="kt">+</span> <span class="kt">RExp</span>, <span class="kt">OutExp</span><span class="o">],</span>
  <span class="n">filterEv</span><span class="k">:</span> <span class="kt">FilterNot.Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">RExp</span><span class="o">]</span>, <span class="kt">RTail</span><span class="o">],</span>
  <span class="n">tailEv</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">LTail</span>, <span class="kt">RTail</span>, <span class="kt">OutTail</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">LExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">LTail</span>, <span class="kt">R</span>, <span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">OutExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">OutTail</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">LExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">LTail</span>, <span class="kt">R</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">OutExp</span><span class="o">]</span> <span class="o">::</span> <span class="nc">OutTail</span>
<span class="o">}</span>
</code></pre></div></div>
<p>When the compiler looks for an implicit instance of multiply for <code class="language-plaintext highlighter-rouge">FieldType[Metre, -1] :: HNil</code> and <code class="language-plaintext highlighter-rouge">FieldType[Metre, 3] :: HNil</code>:</p>

<ul>
  <li>It finds that the <code class="language-plaintext highlighter-rouge">inductiveCase</code> has a return type which fits the signature</li>
  <li>Given that the head of the left list is <code class="language-plaintext highlighter-rouge">Metre</code>, it selects the exponent for <code class="language-plaintext highlighter-rouge">Metre</code> from the right list</li>
  <li>It can find the evidence <code class="language-plaintext highlighter-rouge">addEv</code> to add the exponents <code class="language-plaintext highlighter-rouge">-1</code> and <code class="language-plaintext highlighter-rouge">3</code></li>
  <li>It filters <code class="language-plaintext highlighter-rouge">Metre</code> from the right list to get <code class="language-plaintext highlighter-rouge">HNil</code></li>
  <li>It requires evidence of an instance for  <code class="language-plaintext highlighter-rouge">HNil</code> and <code class="language-plaintext highlighter-rouge">HNil</code></li>
  <li>This is provided by the base case</li>
</ul>

<p>The compiler can now find instances of <code class="language-plaintext highlighter-rouge">Multiply</code>, as long as a dimension appears in both the left and right lists.
This can be extended to when a dimension doesn’t appear by writing a few more inductive cases.</p>

<h3 id="divide">Divide</h3>

<p>The reason we went to the effort of writing <code class="language-plaintext highlighter-rouge">Invert</code> and <code class="language-plaintext highlighter-rouge">Multiply</code> was to divide.
Dividing a numerator by a denominator is as simple as inverting the denominator and multiplying it by the numerator.
We can write this in a single non-inductive instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">divide</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">R</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">RInverted</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, 
  <span class="kt">Divided</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span>
  <span class="k">implicit</span> <span class="n">invertEv</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">RInverted</span><span class="o">],</span>
  <span class="n">multiplyEv</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">RInverted</span>, <span class="kt">Divided</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span>, <span class="kt">Divided</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Divided</span>
<span class="o">}</span>
</code></pre></div></div>
<p>That’s far simpler than the work we’ve done before - we’re just building on the typeclasses we wrote to do this.</p>

<h3 id="automatically-derived-instances">Automatically derived instances</h3>

<p>We can now have compile time dimensional analysis without writing out divide instances for every combination of dimensions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">40.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">fuelMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">10000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">exhaust</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Metre</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">Second</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">1000000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">distance</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">77.0</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">rocketSpeed</span> <span class="k">=</span> <span class="nf">times</span><span class="o">(</span><span class="n">exhaust</span><span class="o">,</span> <span class="nf">log</span><span class="o">(</span><span class="nf">divide</span><span class="o">(</span><span class="nf">add</span><span class="o">(</span><span class="n">rocketMass</span><span class="o">,</span> <span class="n">fuelMass</span><span class="o">),</span> <span class="n">rocketMass</span><span class="o">).</span><span class="py">value</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">time</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Year</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nf">divide</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">rocketSpeed</span><span class="o">)</span>
<span class="c1">// error: type mismatch; found: FieldType[LightYear, 1] :: FieldType[Metre, -1] :: FieldType[Second, 1] :: HNil; required: FieldType[Year, 1] :: HNil
</span></code></pre></div></div>
<p>Yay! We’ve solved the problem!  It looks a lot more verbose than what we started with, but we can tidy this up by using extension methods:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="k">val</span> <span class="nv">d</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">ly</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">LightYear</span>,<span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">kg</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">yr</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Year</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span>     <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">mps</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Metre</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">Second</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">c</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">Year</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>
<p>We can also add symbolic infix operators for <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">times</code> and <code class="language-plaintext highlighter-rouge">divide</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">+</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="nv">q</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">*</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="n">v</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">/</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">d.Out</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">value</span> <span class="o">/</span> <span class="nv">q</span><span class="o">.</span><span class="py">value</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="weve-reached-libra">We’ve reached Libra!</h2>

<p>We started with doubles:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketSpeed</span> <span class="k">=</span> <span class="mf">1000000.0</span> <span class="o">*</span> <span class="nf">log</span><span class="o">((</span><span class="mf">40.0</span> <span class="o">+</span> <span class="mf">10000.0</span><span class="o">)</span> <span class="o">/</span> <span class="mf">40.0</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="mf">77.0</span> <span class="o">/</span> <span class="n">rocketSpeed</span>
</code></pre></div></div>
<p>And we finished with compile time dimensional analysis:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">rocketSpeed</span> <span class="k">=</span> <span class="mf">1000000.0</span><span class="o">.</span><span class="py">mps</span> <span class="o">*</span> <span class="nf">log</span><span class="o">(((</span><span class="mf">40.0</span><span class="o">.</span><span class="py">kg</span> <span class="o">+</span><span class="mf">10000.0</span><span class="o">.</span><span class="py">kg</span><span class="o">)</span> <span class="o">/</span><span class="mf">40.0</span><span class="o">.</span><span class="py">kg</span><span class="o">).</span><span class="py">value</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">speedConversion</span> <span class="k">=</span> <span class="mf">300000000.0</span><span class="o">.</span><span class="py">mps</span> <span class="o">/</span> <span class="mf">1.</span><span class="n">c</span> 
<span class="k">val</span> <span class="nv">speedInC</span> <span class="k">=</span> <span class="n">rocketSpeed</span> <span class="o">/</span> <span class="n">speedConversion</span>
<span class="k">val</span> <span class="nv">time</span> <span class="k">=</span> <span class="mf">77.0</span><span class="o">.</span><span class="py">ly</span> <span class="o">/</span> <span class="n">speedInC</span>
<span class="c1">//time: Quantity[FieldType[Year, 1] :: HNil] = Quantity(4180.65274634)
</span></code></pre></div></div>

<p>The code isn’t more verbose - if anything, it’s more explanatory and just as easy to work with.</p>

<h2 id="rolling-this-out-to-more-problems">Rolling this out to more problems</h2>

<p>All we need to provide for the business logic of our rocket launch problem are the dimensions and <code class="language-plaintext highlighter-rouge">DoubleOps</code>.
We could roll this out to any other problem.  Let’s say we wanted to do a currency conversion between <code class="language-plaintext highlighter-rouge">GBP</code> and <code class="language-plaintext highlighter-rouge">DKK</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">exchangeRate</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">DKK</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">GBP</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> 
   <span class="nf">currentExchangeRate</span><span class="o">()</span> 
<span class="nc">Val</span> <span class="n">krone</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">DKK</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="mf">10.</span><span class="n">gbp</span> <span class="o">*</span> <span class="n">exchangeRate</span>
</code></pre></div></div>

<p>We get dimensional analysis for any problem domain out of the box!</p>

<p>Most of the code we’ve written is library code.  In fact, it’s Libra code!  <a href="https://to-ithaca.github.io/libra/">Libra</a> is a dimensional analysis library based on typelevel induction.  It performs compile time dimensional analysis to any problem domain.  It also uses <a href="https://github.com/non/spire">spire</a> for its numeric typeclasses, so can be used for far more than just doubles.</p>

<h2 id="conclusion">Conclusion</h2>

<p>It’s been a long way from the humble <code class="language-plaintext highlighter-rouge">Double</code>.  We started with basic types, explored dependent types, took a look at Typelevel Scala along the way, before finally ending up performing typelevel induction.  As a result, we’ve managed to achieve compile time dimensional analysis for any problem. If you’re curious about typelevel induction take a look at <a href="https://github.com/to-ithaca/libra">the Libra codebase</a> for more examples.  Enjoy!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/06/13/libra.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/06/13/libra.html</guid>
      </item>
    
      <item>
        <title>An IO monad for cats</title>
        
          <dc:creator>djspiewak</dc:creator>
                
        <description><![CDATA[<p>Haskell is a pure language.  Every Haskell expression is <em>referentially transparent</em>, meaning that you can substitute that expression with its evaluated result without changing the program.  Or, put into code:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- this program</span>
<span class="n">f</span> <span class="n">expr</span> <span class="n">expr</span> <span class="c1">-- apply function f to arguments expr, expr</span>

<span class="c1">-- is equivalent to this one, which factors out `expr`</span>
<span class="kr">let</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span> <span class="c1">-- introduce a new variable `x` with the value of `expr`</span>
<span class="kr">in</span>
  <span class="n">f</span> <span class="n">x</span> <span class="n">x</span>
</code></pre></div></div>

<p>And this is true for <em>all</em> expressions <code class="language-plaintext highlighter-rouge">e</code>, and all functions <code class="language-plaintext highlighter-rouge">f</code>.  These could be complex expressions which describe ways of manipulating network channels or window buffers, or something trivial like a numeric literal.  You can <em>always</em> substitute the expression with its value.</p>

<p>This is not true in Scala, simply because Scala allows <em>unrestricted</em> side-effects.  Unlike Haskell, Scala puts no limitations on where and when we can use things like mutable state (<code class="language-plaintext highlighter-rouge">var</code>s) or evaluated external effects like <code class="language-plaintext highlighter-rouge">println</code> or <code class="language-plaintext highlighter-rouge">launchTheMissiles</code>.  Since there are no restrictions on where and when we can do evil, the Scala equivalent to the above just doesn’t work:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
<span class="c1">// isn't really equivalent to!
</span><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="n">e</span>
<span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>The reason it isn’t equivalent comes from the different sorts of expressions that we could find in <code class="language-plaintext highlighter-rouge">e</code>.  For example, what if <code class="language-plaintext highlighter-rouge">e</code> is <code class="language-plaintext highlighter-rouge">println("hi!")</code>.  If we make that substitution, our snippet looks like the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">f</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">),</span> <span class="nf">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">))</span>
<span class="c1">// isn't really equivalent to!
</span><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="nf">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>Clearly these are not the same two programs.  The first prints <code class="language-plaintext highlighter-rouge">"hi"</code> twice, while the second only prints it once.  This is a violation of referential transparency, and it’s why we sometimes say that Scala is an <em>impure</em> language.  Any expression which is not referentially transparent must contain <em>side-effects</em>, by definition.</p>

<p>Now of course, we found this problem by using a side-effecting function: namely, <code class="language-plaintext highlighter-rouge">println</code>.  Haskell clearly has the ability to print to standard output, so how does it avoid this issue?  If we build the same program in Haskell, can we violate referential transparency?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="p">(</span><span class="n">putStrLn</span> <span class="s">"hi"</span><span class="p">)</span> <span class="p">(</span><span class="n">putStrLn</span> <span class="s">"hi"</span><span class="p">)</span>
<span class="c1">-- is equivalent to</span>
<span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="s">"hi"</span> <span class="kr">in</span> <span class="n">f</span> <span class="n">x</span> <span class="n">x</span>
</code></pre></div></div>

<p>As it turns out, this is still referentially transparent!  These two programs still have the same meaning.  This is possible only because <em>neither</em> program actually prints anything!</p>

<p>In Haskell, effects are treated as first-class values.  The <code class="language-plaintext highlighter-rouge">putStrLn</code> function doesn’t print to standard out, it returns a value (of type <code class="language-plaintext highlighter-rouge">IO ()</code>) which describes <em>how</em> to print to standard out, but stops short of actually <em>doing</em> it.  These sorts of values can be composed using the monadic operators (in Scala, <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">pure</code>), allowing Haskell programmers to build up expressions composed of sequences of dependent effects, all of which are merely <em>descriptions</em> of the side-effects which will eventually be performed by the runtime.  Ultimately, the description which comprises your <em>whole</em> program is the return result from the <code class="language-plaintext highlighter-rouge">main</code> function.  The Haskell runtime runs the <code class="language-plaintext highlighter-rouge">main</code> function to get this description of all your effects, and then runs the effects per your instructions.</p>

<p>This is kind of a clever trick.  It allows Haskell to simultaneously be pure <em>and</em> still have excellent support for manipulating effects and interacting with the “real world”.  But why is it relevant to Scala?  After all, Scala is an impure language.  We don’t <em>need</em> to go through this complex rigmarole of describing our effects and composing those descriptions; the language lets us <em>just do it!</em>  So why wouldn’t we just, you know, evaluate the effects that we need evaluated?</p>

<p>The answer is that we want to reason about <em>where</em> and <em>when</em> our effects are evaluated.  And of course, we want to be able to leverage laws and abstractions which assume equational semantics for expressions (i.e. referential transparency).  Cats is full of these sorts of abstractions, and cats-laws provides a vast set of laws which describe them.  But all of these abstractions and all of these laws break down the <em>moment</em> you introduce some sort of side-effecting expression.  Because, much like our referential transparency example from earlier, these abstractions <em>assume</em> that you can substitute expressions with their evaluated results, and that’s just not true in the presence of side-effects.</p>

<p>What we need is a data type which allows us to encapsulate Scala-style side-effects in the form of a <em>pure</em> value, on which referential transparency holds and which we can compose using other well-defined abstractions, such as <code class="language-plaintext highlighter-rouge">Monad</code>.  Scalaz defines two such data types which meet these criteria: <code class="language-plaintext highlighter-rouge">scalaz.effect.IO</code> and <code class="language-plaintext highlighter-rouge">scalaz.concurrent.Task</code>.  But in practice, nearly everyone uses <code class="language-plaintext highlighter-rouge">Task</code> instead of <code class="language-plaintext highlighter-rouge">IO</code> because of its support for <em>asynchronous</em> effects.</p>

<p>Cats does not define any such abstraction, and what’s worse is the cats <em>ecosystem</em> also doesn’t really provide any such abstraction.  There are two <code class="language-plaintext highlighter-rouge">Task</code> implementations that are relatively commonly used with cats – namely, <code class="language-plaintext highlighter-rouge">monix.eval.Task</code> and <code class="language-plaintext highlighter-rouge">fs2.Task</code> – but these are not part of cats per se, nor are they deeply integrated into its abstraction hierarchy.  Additionally, the proliferation of broadly equivalent options has led to confusion in the ecosystem, with middleware authors often forced to choose a solution for their end-users, and end-users uncertain as to which choice is “right”.</p>

<h2 id="introducing-cats-effect">Introducing cats-effect</h2>

<p>The <a href="https://github.com/typelevel/cats-effect">cats-effect</a> project aims to change all of that.  The goal of cats-effect is to provide an “easy default” <code class="language-plaintext highlighter-rouge">IO</code> type for the cats ecosystem, deeply integrated with cats-core, with all of the features and performance that are required for real world production use.  Additionally, cats-effect defines a set of abstractions in the form of several typeclasses which describe what it means to <em>be</em> a pure effect type.  These abstractions are extremely useful both in enabling MTL-style program composition and to ensure that other pre-existing <code class="language-plaintext highlighter-rouge">Task</code> implementations remain first-class citizens of the ecosystem.  <code class="language-plaintext highlighter-rouge">IO</code> does not overshadow <code class="language-plaintext highlighter-rouge">monix.eval.Task</code> or <code class="language-plaintext highlighter-rouge">fs2.Task</code>; it <em>complements</em> them by providing a set of abstractions and laws which allow users to write safe, parametric code which supports each of them equally.</p>

<p>One important sidebar here: cats-effect does <em>not</em> provide any concurrency primitives.  <code class="language-plaintext highlighter-rouge">scalaz.concurrent.Task</code> and <code class="language-plaintext highlighter-rouge">monix.eval.Task</code> are both notable for providing functions such as <code class="language-plaintext highlighter-rouge">both</code>, which takes two <code class="language-plaintext highlighter-rouge">Task</code>s and runs them in parallel, returning a <code class="language-plaintext highlighter-rouge">Task</code> of a tuple of the results.  The <code class="language-plaintext highlighter-rouge">cats.effect.IO</code> type does not provide any such function, and while it would be possible to define such a function (and others like it!), we strongly encourage users to instead consider full-on streaming frameworks such as <strong>fs2</strong> or <strong>Monix</strong> for their concurrency needs, as these frameworks are able to provide a much sounder foundation for such functions.  See <a href="https://gist.github.com/djspiewak/a775b73804c581f4028fea2e98482b3c">here</a> for a rough outline of why this is.  Also note that some <code class="language-plaintext highlighter-rouge">Task</code> implementations, such as Monix’s, can and do provide parallelism on a sound foundation by enriching their internal algebraic structures.  Thus, <code class="language-plaintext highlighter-rouge">monix.eval.Task</code> is actually quite different from <code class="language-plaintext highlighter-rouge">cats.effect.IO</code>, despite having a similar core set of operations.</p>

<h2 id="enough-talk">Enough Talk…</h2>

<p>What does this look like in practice?  Well, ideally, as convenient as possible!  Let’s look at our println example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="n">line</span><span class="o">)</span> <span class="o">}</span>

<span class="nf">f</span><span class="o">(</span><span class="nf">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">),</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">))</span>

<span class="c1">// is equivalent to
</span>
<span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="nf">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">)</span>
<span class="nf">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>Great!  We can write Haskell fanfic in Scala.  😛</p>

<p>The notable element here is the use of the <code class="language-plaintext highlighter-rouge">IO.apply</code> constructor to wrap the <code class="language-plaintext highlighter-rouge">println</code> effect in a <em>pure</em> <code class="language-plaintext highlighter-rouge">IO</code> value.  This pattern can be applied to any side-effect.  You can think of this sort of like an FFI that converts impure code (like <code class="language-plaintext highlighter-rouge">println</code>) into pure code (like <code class="language-plaintext highlighter-rouge">putStrLn</code>).  The goal of this API was to be as simple and straightforward as possible.  If you have a curly brace block of impure side-effecting code, you can wrap it in a composable and pure abstraction by just adding two characters: <code class="language-plaintext highlighter-rouge">IO</code>.  You can wrap arbitrarily large or small blocks of code, potentially involving complex allocations, JNI calls, resource semantics, etc; but it is generally considered a best practice to wrap side-effects into the smallest composable units that make sense and do all of your sequentialization using <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">for</code>-comprehensions.</p>

<p>For example, here’s a program that performs some simple user interaction in the shell:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="nv">program</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Welcome to Scala!  What's your name?"</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nv">Console</span><span class="o">.</span><span class="py">readLine</span> <span class="o">}</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Well hello, $name!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>We could have just as easily written this program in the following way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">program</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Welcome to Scala!  What's your name?"</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">name</span> <span class="k">=</span> <span class="nv">Console</span><span class="o">.</span><span class="py">readLine</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Well hello, $name!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But this gives us less flexibility for composition.  Remember that even though <code class="language-plaintext highlighter-rouge">program</code> is a pure and referentially transparent value, its <em>definition</em> is not, which is to say that <code class="language-plaintext highlighter-rouge">IO { expr }</code> is not the same as <code class="language-plaintext highlighter-rouge">val x = expr; IO { x }</code>.  Anything inside the <code class="language-plaintext highlighter-rouge">IO {</code> … <code class="language-plaintext highlighter-rouge">}</code> block is not referentially transparent, and so should be treated with extreme care and suspicion.  The less of our program we have inside these blocks, the better!</p>

<p>As a sidebar that is actually kinda cool, we can implement a <code class="language-plaintext highlighter-rouge">readString</code> <code class="language-plaintext highlighter-rouge">IO</code> action that wraps <code class="language-plaintext highlighter-rouge">Console.readLine</code> <em>as a <code class="language-plaintext highlighter-rouge">val</code>!</em></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">readString</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nv">Console</span><span class="o">.</span><span class="py">readLine</span> <span class="o">}</span>
</code></pre></div></div>

<p>This is totally valid!  We don’t need to worry about the difference between <code class="language-plaintext highlighter-rouge">def</code> and <code class="language-plaintext highlighter-rouge">val</code> anymore, because <code class="language-plaintext highlighter-rouge">IO</code> is referentially transparent.  So you use <code class="language-plaintext highlighter-rouge">def</code> when you need parameters, and you use <code class="language-plaintext highlighter-rouge">val</code> when you don’t, and you don’t have to think about evaluation semantics.  No more subtle bugs caused by accidentally memoizing your effects!</p>

<p>Of course, if <code class="language-plaintext highlighter-rouge">program</code> is referentially transparent, then clearly repeated values of <code class="language-plaintext highlighter-rouge">program</code> cannot possibly run the effects it represents multiple times.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span>
<span class="n">program</span>
<span class="n">program</span>

<span class="c1">// must be the same as!
</span>
<span class="n">program</span>
</code></pre></div></div>

<p>If this weren’t the case, then we would be in trouble when trying to construct examples like the Haskell one from earlier.  But there is an implication here that is quite profound: <code class="language-plaintext highlighter-rouge">IO</code> cannot eagerly evaluate its effects, and similarly cannot memoize its results!  If <code class="language-plaintext highlighter-rouge">IO</code> were to eagerly evaluate or to memoize, then we could no longer replace references to the expression with the expression itself, since that would result in a <em>different</em> <code class="language-plaintext highlighter-rouge">IO</code> instance to be evaluated separately.</p>

<p>This is precisely why <code class="language-plaintext highlighter-rouge">scala.concurrent.Future</code> is <em>not</em> a suitable type for encapsulating effects in this way: constructing a <code class="language-plaintext highlighter-rouge">Future</code> that will eventually side-effect is itself a side-effect!  <code class="language-plaintext highlighter-rouge">Future</code> evaluates eagerly (sort of, see below) and memoizes its results, meaning that a <code class="language-plaintext highlighter-rouge">println</code> inside of a given <code class="language-plaintext highlighter-rouge">Future</code> will only evaluate <em>once</em>, even if the <code class="language-plaintext highlighter-rouge">Future</code> is sequenced multiple times.  This in turn means that <code class="language-plaintext highlighter-rouge">val x = Future(...); f(x, x)</code> is not the same program as <code class="language-plaintext highlighter-rouge">f(Future(...), Future(...))</code>, which is the very definition of a violation of referential transparency.</p>

<p>Coming back to <code class="language-plaintext highlighter-rouge">IO</code>…  If <code class="language-plaintext highlighter-rouge">program</code> does not evaluate eagerly, then clearly there must be some mechanism for asking it to evaluate.  After all, Scala is not like Haskell: we don’t return a value of type <code class="language-plaintext highlighter-rouge">IO[Unit]</code> from our <code class="language-plaintext highlighter-rouge">main</code> function.  <code class="language-plaintext highlighter-rouge">IO</code> provides an FFI of sorts for wrapping side-effecting code into pure <code class="language-plaintext highlighter-rouge">IO</code> values, so it must also provide an FFI for going in the opposite direction: taking a pure <code class="language-plaintext highlighter-rouge">IO</code> value and evaluating its constituent actions as side-effects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">program</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>    <span class="c1">// uh oh!
</span></code></pre></div></div>

<p>This function is called <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code>.  Given an <code class="language-plaintext highlighter-rouge">IO[A]</code>, the <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> function will give you a value of type <code class="language-plaintext highlighter-rouge">A</code>.  You should only call this function <em>once</em>, ideally at the very end of your program!  (i.e. in your <code class="language-plaintext highlighter-rouge">main</code> function)  Just as with <code class="language-plaintext highlighter-rouge">IO.apply</code>, any expression involving <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> is not referentially transparent.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">program</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="nv">program</span><span class="o">.</span><span class="py">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>The above will run <code class="language-plaintext highlighter-rouge">program</code> <em>twice</em>.  So clearly, referential transparency is out the window whenever we do this, and we cannot expect the normal laws and abstractions to remain sound in the presence of this function.</p>

<h3 id="a-sidebar-on-futures-eager-evaluation">A sidebar on <code class="language-plaintext highlighter-rouge">Future</code>’s eager evaluation</h3>

<p>As Viktor Klang is fond of pointing out, <code class="language-plaintext highlighter-rouge">Future</code> doesn’t <em>need</em> to evaluate eagerly.  It is possible to define an <code class="language-plaintext highlighter-rouge">ExecutionContext</code> in which <code class="language-plaintext highlighter-rouge">Future</code> defers its evaluation until some indefinitely later point.  However, this is not the default mode of operation for 99% of all <code class="language-plaintext highlighter-rouge">Future</code>s ever constructed; most people just use <code class="language-plaintext highlighter-rouge">ExecutionContext.global</code> and leave it at that.  Additionally, if someone hands me an arbitrary <code class="language-plaintext highlighter-rouge">Future</code>, perhaps as a return value from a function, I really have no idea whether or not that <code class="language-plaintext highlighter-rouge">Future</code> is secretly running without my consent.  In other words, the referential transparency (or lack thereof) of functions that I write using <code class="language-plaintext highlighter-rouge">Future</code> is dependent on the runtime configuration of some other function which is hidden from me.  That’s not referential transparency anymore.  Because we cannot be <em>certain</em> that <code class="language-plaintext highlighter-rouge">Future</code> is deferring its evaluation, we must defensively assume that it is not.</p>

<p>This, in a nutshell, is precisely why <code class="language-plaintext highlighter-rouge">Future</code> is not appropriate for functional programming.  <code class="language-plaintext highlighter-rouge">IO</code> provides a pair of functions (<code class="language-plaintext highlighter-rouge">fromFuture</code> and <code class="language-plaintext highlighter-rouge">unsafeToFuture</code>) for interacting with <code class="language-plaintext highlighter-rouge">Future</code>-using APIs, but in general, you should try to stick with <code class="language-plaintext highlighter-rouge">IO</code> as much as possible when manipulating effects.</p>

<h2 id="asynchrony-and-the-jvm">Asynchrony and the JVM</h2>

<p>Scala runs on three platforms: the JVM, JavaScript and LLVM.  For the moment, we’ll just focus on the first two.  The JVM has support for multiple threads, but those threads are <em>native</em> (i.e. kernel) threads, meaning that they are relatively expensive to create and maintain in the runtime.  They are a very limited resource, sort of like file handles or heap space, and you can’t just write programs which require an unbounded number of them.  The exact upper bound on the JVM varies from platform to platform, and varies considerably depending on your GC configuration, but a general rule of thumb is “a few thousand”, where “few” is a small number.  In practice, you’re going to want <em>far</em> less threads than that if you want to avoid thrashing your GC, and most applications will divide themselves into a bounded “main” thread pool (usually bounded to exactly the number of CPUs) on which all CPU-bound tasks are performed and most of the program runs, as well as a set of unbounded “blocking” thread pools on which blocking IO actions (such as anything in <code class="language-plaintext highlighter-rouge">java.io</code>) are run.  When you add NIO worker pools into the mix, the final number of threads in a practical production service is usually around 30-40 on an 8 CPU machine, growing roughly linearly as you add CPUs.  Clearly, this is not a very large number.</p>

<p>On JavaScript runtimes (such as <code class="language-plaintext highlighter-rouge">node</code> or in the browser), the situation is even worse: you have exactly one thread!  JavaScript simply doesn’t have multi-threading in any (real) form, and so it’s like the JVM situation, but 30-40x more constraining.</p>

<p>For this reason, we need to be very careful when writing Scala to treat threads as an extremely scarce resource.  <em>Blocking</em> threads (using mechanisms such as <code class="language-plaintext highlighter-rouge">wait</code>, <code class="language-plaintext highlighter-rouge">join</code> or <code class="language-plaintext highlighter-rouge">CountDownLatch</code>) should be considered absolutely anathema, since it selfishly wastes a very finite and very critical resource, leading to thread starvation and deadlocks.</p>

<p>This is very different from how things are in Haskell though!  The Haskell runtime is implemented around the concept of <em>green threads</em>, which is to say, <em>emulated</em> concurrency by means of a runtime dispatch lock.  Haskell basically creates a global bounded thread pool in the runtime with the same number of threads as your machine has CPUs.  On top of that pool, it runs dispatch trampolines that schedule and evict expression evaluation, effectively emulating an arbitrarily large number of “fake” threads atop a small fixed set of “real” threads.  So when you write code in Haskell, you generally just assume that threads are extremely cheap and you can have as many of them as you want.  Under these circumstances, blocking a thread is not really a big deal (as long as you don’t do it in FFI native code), so there’s no reason to go out of your way to avoid it in abstractions like <code class="language-plaintext highlighter-rouge">IO</code>.</p>

<p>This presents a bit of a dilemma for cats-effect: we want to provide a <em>practical</em> pure abstraction for encapsulating effects, but we need to run on the JVM and on JavaScript which means we need to provide a way to avoid thread blocking.  So, the <code class="language-plaintext highlighter-rouge">IO</code> implementation in cats-effect is going to <em>necessarily</em> end up looking very, very different from the one in Haskell, providing a very different set of operations.</p>

<p>Specifically, <code class="language-plaintext highlighter-rouge">cats.effect.IO</code> provides an additional constructor, <code class="language-plaintext highlighter-rouge">async</code>, which allows the construction of <code class="language-plaintext highlighter-rouge">IO</code> instances from callback-driven APIs.  This is generally referred to as “asynchronous” control flow, as opposed to “synchronous” control flow (represented by the <code class="language-plaintext highlighter-rouge">apply</code> constructor).  To see how this works, we’re going to need a bit of setup.</p>

<p>Consider the following somewhat-realistic NIO API (translated to Scala):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
<span class="c1">// defined trait Response
</span>
<span class="k">trait</span> <span class="nc">Channel</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">sendBytes</span><span class="o">(</span><span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">handler</span><span class="k">:</span> <span class="kt">Response</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="nf">receiveBytes</span><span class="o">(</span><span class="n">handler</span><span class="k">:</span> <span class="kt">Response</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
<span class="c1">// defined trait Channel
</span></code></pre></div></div>

<p>This is an asynchronous API.  Neither of the functions <code class="language-plaintext highlighter-rouge">sendBytes</code> or <code class="language-plaintext highlighter-rouge">receiveBytes</code> attempt to block on completion.  Instead, they <em>schedule</em> their operations via some underlying mechanism.  This interface could be implemented on top of <code class="language-plaintext highlighter-rouge">java.io</code> (which is a synchronous API) through the use of an internal thread pool, but most NIO implementations are actually going to delegate their scheduling all the way down to the kernel layer, avoiding the consumption of a precious thread while waiting for the underlying IO – which, in the case of network sockets, may be a very long wait indeed!</p>

<p>Wrapping this sort of API in a referentially transparent and uniform fashion is a very important feature of <code class="language-plaintext highlighter-rouge">IO</code>, <em>precisely</em> because of Scala’s underlying platform constraints.  Clearly, <code class="language-plaintext highlighter-rouge">sendBytes</code> and <code class="language-plaintext highlighter-rouge">receiveBytes</code> both represent side-effects, but they’re different than <code class="language-plaintext highlighter-rouge">println</code> and <code class="language-plaintext highlighter-rouge">readLine</code> in that they don’t produce their results in a sequentially returned value.  Instead, they take a callback, <code class="language-plaintext highlighter-rouge">Response</code>, which will eventually be notified (likely on some other thread!) when the result is available.  The <code class="language-plaintext highlighter-rouge">IO.async</code> constructor is designed for precisely these situations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">send</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span><span class="o">,</span> <span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">IO</span> <span class="n">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="nv">c</span><span class="o">.</span><span class="py">sendBytes</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">t</span><span class="o">))</span>
      <span class="k">def</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(()))</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// send: (c: Channel, chunk: Array[Byte])cats.effect.IO[Unit]
</span>
<span class="k">def</span> <span class="nf">receive</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">IO</span> <span class="n">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="nv">c</span><span class="o">.</span><span class="py">receiveBytes</span><span class="o">(</span><span class="k">new</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">t</span><span class="o">))</span>
      <span class="k">def</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span> <span class="k">=</span> <span class="nf">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">chunk</span><span class="o">))</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// receive: (c: Channel)cats.effect.IO[Array[Byte]]
</span></code></pre></div></div>

<p>Obviously, this is a little more daunting than the <code class="language-plaintext highlighter-rouge">println</code> examples from earlier, but that’s mostly the fault of the anonymous inner class syntactic ceremony.  The <code class="language-plaintext highlighter-rouge">IO</code> interaction is actually quite simple!</p>

<p>The <code class="language-plaintext highlighter-rouge">async</code> constructor takes a function which is handed a <em>callback</em> (represented above by <code class="language-plaintext highlighter-rouge">cb</code> in both cases).  This callback is <em>itself</em> a function of type <code class="language-plaintext highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>, where <code class="language-plaintext highlighter-rouge">A</code> is the type produced by the <code class="language-plaintext highlighter-rouge">IO</code>.  So when our <code class="language-plaintext highlighter-rouge">Response</code> comes back as <code class="language-plaintext highlighter-rouge">onSuccess</code> in the <code class="language-plaintext highlighter-rouge">send</code> example, we invoke the callback with a <code class="language-plaintext highlighter-rouge">Right(())</code> since we’re trying to produce an <code class="language-plaintext highlighter-rouge">IO[Unit]</code>.  When the <code class="language-plaintext highlighter-rouge">Response</code> comes back as <code class="language-plaintext highlighter-rouge">onSuccess</code> in the <code class="language-plaintext highlighter-rouge">receive</code> example, we invoke the callback with <code class="language-plaintext highlighter-rouge">Right(chunk)</code>, since the <code class="language-plaintext highlighter-rouge">IO</code> produces an <code class="language-plaintext highlighter-rouge">Array[Byte]</code>.</p>

<p>Now remember, <code class="language-plaintext highlighter-rouge">IO</code> is still a monad, and <code class="language-plaintext highlighter-rouge">IO</code> values constructed with <code class="language-plaintext highlighter-rouge">async</code> are perfectly capable of all of the things that “normal”, synchronous <code class="language-plaintext highlighter-rouge">IO</code> values are, which means that you can use these values inside <code class="language-plaintext highlighter-rouge">for</code>-comprehensions and other conventional composition!  This is incredibly, unbelievably nice in practice, because it takes your complex, nested, callback-driven code and flattens it into simple, easy-to-read sequential composition.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">c</span><span class="k">:</span> <span class="kt">Channel</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// pretend this is an actual channel
</span>
<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">send</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">"SYN"</span><span class="o">.</span><span class="py">getBytes</span><span class="o">)</span>
  <span class="n">response</span> <span class="k">&lt;-</span> <span class="nf">receive</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="n">response</span> <span class="o">==</span> <span class="s">"ACK"</span><span class="o">.</span><span class="py">getBytes</span><span class="o">)</span>   <span class="c1">// pretend == works on Array[Byte]
</span>    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"found the guy!"</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"no idea what happened, but it wasn't good"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>This is kind of amazing.  There’s no thread blocking at all in the above (other than the <code class="language-plaintext highlighter-rouge">println</code> blocking on standard output).  The <code class="language-plaintext highlighter-rouge">receive</code> could take quite a long time to come back to us, and our thread is free to do other things in the interim.  Everything is driven by callbacks under the surface, and asynchronous actions can be manipulated just as easily as synchronous ones.</p>

<p>Of course, this is an even bigger win on JavaScript, where nearly everything is callback-based, and gigantic, deeply nested chunks of code are not unusual.  <code class="language-plaintext highlighter-rouge">IO</code> allows you to flatten those deeply nested chunks of code into a nice, clean, linear and sequential formulation.</p>

<h2 id="thread-shifting">Thread Shifting</h2>

<p>Now there is a caveat here.  When our <code class="language-plaintext highlighter-rouge">Response</code> handler is invoked by <code class="language-plaintext highlighter-rouge">Channel</code>, it is very likely that the callback will be run on a thread which is part of a different thread pool than our main program.  Remember from earlier where I described how <em>most</em> well-designed Java services are organized:</p>

<ul>
  <li>A bounded thread pool set to <em>num CPUs</em> in size for any non-IO actions</li>
  <li>A set of unbounded thread pools for blocking IO</li>
  <li>Some bounded internal thread worker pools for NIO polling</li>
</ul>

<p>We definitely want to run nearly everything on that first pool (which is probably <code class="language-plaintext highlighter-rouge">ExecutionContext.global</code>), but we’re probably going to receive the <code class="language-plaintext highlighter-rouge">Response</code> callback on one of the third pools.  So how can we force the rest of our program (including those <code class="language-plaintext highlighter-rouge">println</code>s) back onto the main pool?</p>

<p>The answer is the <code class="language-plaintext highlighter-rouge">shift</code> function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent._</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">ec</span> <span class="k">=</span> <span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">send</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">"SYN"</span><span class="o">.</span><span class="py">getBytes</span><span class="o">)</span>
  <span class="n">response</span> <span class="k">&lt;-</span> <span class="nf">receive</span><span class="o">(</span><span class="n">c</span><span class="o">).</span><span class="py">shift</span>    <span class="c1">// there's no place like home!
</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="n">response</span> <span class="o">==</span> <span class="s">"ACK"</span><span class="o">.</span><span class="py">getBytes</span><span class="o">)</span>   <span class="c1">// pretend == works on Array[Byte]
</span>    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"found the guy!"</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"no idea what happened, but it wasn't good"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">shift</code>’s functionality is a little complicated, but generally speaking, you should think of it as a “force this <code class="language-plaintext highlighter-rouge">IO</code> onto this <em>other</em> thread pool” function.  Of course, when <code class="language-plaintext highlighter-rouge">receive</code> executes, most of its work isn’t done on any thread at all (since it is simply registering a hook with the kernel), and so that work isn’t thread shifted to any pool, main or otherwise.  But when <code class="language-plaintext highlighter-rouge">receive</code> gets back to us with the network response, the callback will be handled and then <em>immediately</em> thread-shifted back onto the main pool, which is passed implicitly as a parameter to <code class="language-plaintext highlighter-rouge">shift</code> (you can also pass this explicitly if you like).  This thread-shifting means that all of the subsequent actions within the <code class="language-plaintext highlighter-rouge">for</code>-comprehension – which is to say, the <em>continuation</em> of <code class="language-plaintext highlighter-rouge">receive(c)</code> – will be run on the <code class="language-plaintext highlighter-rouge">ec</code> thread pool, rather than whatever worker pool is used internally by <code class="language-plaintext highlighter-rouge">Channel</code>.  This is an <em>extremely</em> common use-case in practice, and <code class="language-plaintext highlighter-rouge">IO</code> attempts to make it as straightforward as possible.</p>

<p>Another possible application of thread shifting is ensuring that a blocking <code class="language-plaintext highlighter-rouge">IO</code> action is relocated from the main, CPU-bound thread pool onto one of the pools designated for blocking IO.  An example of this would be any interaction with <code class="language-plaintext highlighter-rouge">java.io</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io.</span><span class="o">{</span><span class="nc">BufferedReader</span><span class="o">,</span> <span class="nc">FileReader</span><span class="o">}</span>
<span class="c1">// import java.io.{BufferedReader, FileReader}
</span>
<span class="k">def</span> <span class="nf">readLines</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">reader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
  <span class="k">var</span> <span class="n">back</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Vector</span><span class="o">.</span><span class="py">empty</span>

  <span class="k">try</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">do</span> <span class="o">{</span>
      <span class="n">line</span> <span class="k">=</span> <span class="nv">reader</span><span class="o">.</span><span class="py">readLine</span><span class="o">()</span>
      <span class="n">back</span> <span class="o">:+</span> <span class="n">line</span>
    <span class="o">}</span> <span class="nf">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="nv">reader</span><span class="o">.</span><span class="py">close</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="n">back</span>
<span class="o">}</span>
<span class="c1">// readLines: (name: String)cats.effect.IO[Vector[String]]
</span></code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Name, pls."</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nv">Console</span><span class="o">.</span><span class="py">readLine</span> <span class="o">}</span>
  <span class="n">lines</span> <span class="k">&lt;-</span> <span class="nf">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">lines</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"You're on the list, boss."</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Get outa here!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Clearly, <code class="language-plaintext highlighter-rouge">readLines</code> is blocking the underlying thread while it waits for the disk to return the file contents to us, and for a large file, we might be blocking the thread for quite a long time!  Now if we’re treating our thread pools with respect (as described above), then we probably have a pair of <code class="language-plaintext highlighter-rouge">ExecutionContext</code>(s) sitting around in our code somewhere:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.Executors</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">Main</span> <span class="k">=</span> <span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span>
<span class="k">val</span> <span class="nv">BlockingFileIO</span> <span class="k">=</span> <span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">fromExecutor</span><span class="o">(</span><span class="nv">Executors</span><span class="o">.</span><span class="py">newCachedThreadPool</span><span class="o">())</span>
</code></pre></div></div>

<p>We want to ensure that <code class="language-plaintext highlighter-rouge">readLines</code> runs on the <code class="language-plaintext highlighter-rouge">BlockingFileIO</code> pool, while everything else in the <code class="language-plaintext highlighter-rouge">for</code>-comprehension runs on <code class="language-plaintext highlighter-rouge">Main</code>.  How can we achieve this?</p>

<p>With <code class="language-plaintext highlighter-rouge">shift</code>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Name, pls."</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nv">Console</span><span class="o">.</span><span class="py">readLine</span> <span class="o">}</span>
  <span class="n">lines</span> <span class="k">&lt;-</span> <span class="nf">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="py">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">).</span><span class="py">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">if</span> <span class="o">(</span><span class="nv">lines</span><span class="o">.</span><span class="py">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"You're on the list, boss."</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Get outa here!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Now we’re definitely in bizarro land.  <em>Two</em> calls to <code class="language-plaintext highlighter-rouge">shift</code>, one after the other?  Let’s break this apart:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="py">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">)</span>
</code></pre></div></div>

<p>One of the functions of <code class="language-plaintext highlighter-rouge">shift</code> is to take the <code class="language-plaintext highlighter-rouge">IO</code> action it is given and relocate that action onto the given thread pool.  In the case of <code class="language-plaintext highlighter-rouge">receive</code>, this component of <code class="language-plaintext highlighter-rouge">shift</code> was meaningless since <code class="language-plaintext highlighter-rouge">receive</code> didn’t use a thread under the surface (it was asynchronous!).  However, <code class="language-plaintext highlighter-rouge">readLines</code> <em>does</em> use a thread under the surface (hint: it was constructed with <code class="language-plaintext highlighter-rouge">IO.apply</code> rather than <code class="language-plaintext highlighter-rouge">IO.async</code>), and so that work will be relocated onto the <code class="language-plaintext highlighter-rouge">BlockingFileIO</code> pool by the above expression.</p>

<p><em>Additionally</em>, the continuation of this work will also be relocated onto the <code class="language-plaintext highlighter-rouge">BlockingFileIO</code> pool, and that’s definitely not what we want.  The evaluation of the <code class="language-plaintext highlighter-rouge">contains</code> function is definitely CPU-bound, and should be run on the <code class="language-plaintext highlighter-rouge">Main</code> pool.  So we need to <code class="language-plaintext highlighter-rouge">shift</code> a second time, but only the <em>continuation</em> of the <code class="language-plaintext highlighter-rouge">readLines</code> action, not <code class="language-plaintext highlighter-rouge">readLines</code> itself.  As it turns out, we can achieve this just by adding the second <code class="language-plaintext highlighter-rouge">shift</code> call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="py">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">).</span><span class="py">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, <code class="language-plaintext highlighter-rouge">readLines</code> will be run on the <code class="language-plaintext highlighter-rouge">BlockingFileIO</code> pool, but the <em>continuation</em> of <code class="language-plaintext highlighter-rouge">readLines</code> (namely, everything that follows it in the <code class="language-plaintext highlighter-rouge">for</code>-comprehension) will be run on <code class="language-plaintext highlighter-rouge">Main</code>.  This works because <code class="language-plaintext highlighter-rouge">shift</code> creates an asynchronous <code class="language-plaintext highlighter-rouge">IO</code> that schedules the target action on the given thread pool and invokes its continuation <em>from a callback</em>.  The <a href="http://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html#execute(runnable:Runnable):Unit">ExecutionContext#execute</a> function should give you an idea of how this works.  This means that the result of the first <code class="language-plaintext highlighter-rouge">shift</code> is an <code class="language-plaintext highlighter-rouge">IO</code> constructed with <code class="language-plaintext highlighter-rouge">async</code>, and cannot <em>itself</em> be thread-shifted (unlike an <code class="language-plaintext highlighter-rouge">IO</code> constructed with <code class="language-plaintext highlighter-rouge">apply</code>), but its continuation <em>can</em> be thread-shifted, which is exactly what happens.</p>

<p>This sort of double-<code class="language-plaintext highlighter-rouge">shift</code> idiom is very common in production service code that makes use of legacy blocking IO libraries such as <code class="language-plaintext highlighter-rouge">java.io</code>.</p>

<h3 id="synchronous-vs-asynchronous-execution">Synchronous vs Asynchronous Execution</h3>

<p>Speaking of asynchrony, readers who have been looking ahead in the class syllabus probably realized that the type signature of <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> is more than a little suspicious.  Specifically, it promises to give us an <code class="language-plaintext highlighter-rouge">A</code> <em>immediately</em> given an <code class="language-plaintext highlighter-rouge">IO[A]</code>; but if that <code class="language-plaintext highlighter-rouge">IO[A]</code> is an asynchronous action invoked with a callback, how can it achieve this promise?</p>

<p>The answer is that it blocks a thread.  (<em>gasp!!!</em>)  Under the surface, a <code class="language-plaintext highlighter-rouge">CountDownLatch</code> is used to block the calling thread whenever an <code class="language-plaintext highlighter-rouge">IO</code> is encountered that was constructed with <code class="language-plaintext highlighter-rouge">IO.async</code>.  Functionally, this is very similar to the <code class="language-plaintext highlighter-rouge">Await.result</code> function in <code class="language-plaintext highlighter-rouge">scala.concurrent</code>, and it is just as dangerous.  Additionally, it clearly cannot possibly work on JavaScript, since you only have one thread to block!  If you try to call <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> on JavaScript with an underlying <code class="language-plaintext highlighter-rouge">IO.async</code>, it will just throw an exception rather than deadlock your application.</p>

<p>This is not such a great state of affairs.  I mean, it <em>works</em> if <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> is being run in test code, or as the last line of your <code class="language-plaintext highlighter-rouge">main</code> function, but sometimes we need to interact with legacy code or with Java APIs that weren’t designed for purity.  Sometimes, we just <em>have</em> to evaluate our <code class="language-plaintext highlighter-rouge">IO</code> actions before “the end of the world”, and when we do that, we don’t want to block any of our precious threads.</p>

<p>So <code class="language-plaintext highlighter-rouge">IO</code> provides an additional function: <code class="language-plaintext highlighter-rouge">unsafeRunAsync</code>.  This function takes a callback (of type <code class="language-plaintext highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>) which it will run when (and if) the <code class="language-plaintext highlighter-rouge">IO[A]</code> completes its execution.  As the name implies, this function is <em>also</em> not referentially transparent, but unlike <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code>, it will not block a thread.</p>

<p>As a sidebar that will be important in a few paragraphs, <code class="language-plaintext highlighter-rouge">IO</code> also defines a <em>safe</em> function called <code class="language-plaintext highlighter-rouge">runAsync</code> which has a very similar signature to <code class="language-plaintext highlighter-rouge">unsafeRunAsync</code>, except it returns an <code class="language-plaintext highlighter-rouge">IO[Unit]</code>.  The <code class="language-plaintext highlighter-rouge">IO[Unit]</code> which is returned from this function <em>will not block</em> if you call <code class="language-plaintext highlighter-rouge">unsafeRunAsync()</code>.  In other words, it is always safe to call <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code> on the results of <code class="language-plaintext highlighter-rouge">runAsync</code>, even on JavaScript.</p>

<p>Another way to look at this is in terms of <code class="language-plaintext highlighter-rouge">unsafeRunAsync</code>.  You can define <code class="language-plaintext highlighter-rouge">unsafeRunAsync</code> in terms of <code class="language-plaintext highlighter-rouge">runAsync</code> and <code class="language-plaintext highlighter-rouge">unsafeRunSync()</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">unsafeRunAsync</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ioa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="nv">ioa</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nf">cb</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">}).</span><span class="py">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// unsafeRunAsync: [A](ioa: cats.effect.IO[A])(cb: Either[Throwable,A] =&gt; Unit)Unit
</span></code></pre></div></div>

<p>This isn’t the actual definition, but it would be a valid one, and it would run correctly on every platform.</p>

<h2 id="abstraction-and-lawfulness">Abstraction and Lawfulness</h2>

<p>As mentioned earlier (about 10000 words ago…), the cats-effect project not only provides a concrete <code class="language-plaintext highlighter-rouge">IO</code> type with a lot of nice features, it also provides a set of abstractions characterized by typeclasses and associated laws.  These abstractions collectively define what it means to be a type which encapsulates side-effects in a pure fashion, and they are implemented by <code class="language-plaintext highlighter-rouge">IO</code> as well as several other types (including <code class="language-plaintext highlighter-rouge">fs2.Task</code> and <code class="language-plaintext highlighter-rouge">monix.eval.Task</code>).  The hierarchy looks like this:</p>

<p><img src="/img/media/cats-effect-diagram.png" alt="cats-effect typeclasses" /></p>

<p><code class="language-plaintext highlighter-rouge">Monad</code> and <code class="language-plaintext highlighter-rouge">MonadError</code> are of course a part of cats-core, while everything else is in cats-effect.  <code class="language-plaintext highlighter-rouge">MonadError</code> is functionally equivalent to the familiar <code class="language-plaintext highlighter-rouge">scalaz.Catchable</code> typeclass, which was commonly used in conjunction with <code class="language-plaintext highlighter-rouge">scalaz.concurrent.Task</code>.  It literally means “a monad with error-handling capabilities”.  <code class="language-plaintext highlighter-rouge">IO</code> certainly fits that description, as any exceptions thrown within its <code class="language-plaintext highlighter-rouge">apply</code> method (or within <code class="language-plaintext highlighter-rouge">async</code>) will be caught and may be handled in pure code by means of the <code class="language-plaintext highlighter-rouge">attempt</code> function.  <code class="language-plaintext highlighter-rouge">Sync</code>, <code class="language-plaintext highlighter-rouge">Async</code>, <code class="language-plaintext highlighter-rouge">LiftIO</code> and <code class="language-plaintext highlighter-rouge">Effect</code> are the new typeclasses.</p>

<p><code class="language-plaintext highlighter-rouge">Sync</code> simply describes the <code class="language-plaintext highlighter-rouge">IO.apply</code> function (in the typeclasses, this function is called <code class="language-plaintext highlighter-rouge">delay</code>).  Which is to say, any type constructor <code class="language-plaintext highlighter-rouge">F[_]</code> which has a <code class="language-plaintext highlighter-rouge">Sync[F]</code> has the capability to suspend <em>synchronous</em> side-effecting code.  <code class="language-plaintext highlighter-rouge">Async</code> is very similar to this in that it describes the <code class="language-plaintext highlighter-rouge">async</code> function.  So any type constructor <code class="language-plaintext highlighter-rouge">F[_]</code> which has an <code class="language-plaintext highlighter-rouge">Async[F]</code> can suspend <em>asynchronous</em> side-effecting code.  <code class="language-plaintext highlighter-rouge">LiftIO</code> should be familiar to Haskell veterans, and is broadly useful for defining parametric signatures and composing monad transformer stacks.</p>

<p><code class="language-plaintext highlighter-rouge">Effect</code> is where everything is brought together.  In addition to being able to suspend synchronous and asynchronous side-effecting code, anything that has an <code class="language-plaintext highlighter-rouge">Effect</code> instance may also be <em>asynchronously interpreted</em> into an <code class="language-plaintext highlighter-rouge">IO</code>.  The way this is specified is using the <code class="language-plaintext highlighter-rouge">runAsync</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">Async</span><span class="o">,</span> <span class="nc">LiftIO</span><span class="o">,</span> <span class="nc">Sync</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Async</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">LiftIO</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">runAsync</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<!--    please don't remove; my editor is glitchy :-(
```
-->

<p>What this is saying is that any <code class="language-plaintext highlighter-rouge">Effect</code> must define the ability to evaluate as a side-effect, but of course, we don’t want to have side-effects in our pure and reasonable code.  So how are side-effects <em>purely</em> represented?  With <code class="language-plaintext highlighter-rouge">IO</code>!</p>

<p>From a parametric reasoning standpoint, <code class="language-plaintext highlighter-rouge">IO</code> means “here be effects”, and so any type signature which involves <code class="language-plaintext highlighter-rouge">IO</code> thus also involves side-effects (well, <em>effects</em> anyway), and any type signature which requires side-effects must also involve <code class="language-plaintext highlighter-rouge">IO</code>.  This bit of trickery allows us to reason about <code class="language-plaintext highlighter-rouge">Effect</code> in a way that would have been much harder if we had defined <code class="language-plaintext highlighter-rouge">unsafeRunAsync</code> as a member, and it ensures that downstream projects which write code abstracting over <code class="language-plaintext highlighter-rouge">Effect</code> types can do so without using any <code class="language-plaintext highlighter-rouge">unsafe</code> functions if they so choose (especially when taken together with the <code class="language-plaintext highlighter-rouge">liftIO</code> function).</p>

<h2 id="conclusion">Conclusion</h2>

<p>The lack of a production-ready <code class="language-plaintext highlighter-rouge">Task</code>-like type fully integrated into the cats ecosystem has been a sticking point for a lot of people considering adopting cats.  With the introduction of <a href="https://github.com/typelevel/cats-effect">cats-effect</a>, this should no longer be a problem!  As of right now, the only releases are snapshots with hash-based versions, the latest of which can be found in the maven badge at the top of the readme.  These snapshots are stable versions (in the repeatable-build sense), but they should not be considered stable, production-ready, future-proof software.  We are quickly moving towards a final 0.1 release, which will depend on cats-core and will represent the stable, finalized API.</p>

<p>Once cats releases a final 1.0 version, cats-effect will also release version 1.0 which will depend on the corresponding version of cats-core.  Changes to cats-effect are expected to be extremely rare, and thus the dependency should be considered quite stable for the purposes of upstream compatibility.  Nevertheless, the release and versioning cycle is decoupled from cats-core to account for the possibility that breaking changes may need to be made independent of the cats-core release cycle.</p>

<p>Check out the sources!  Check out the documentation.  Play around with the snapshots, and let us know what you think!  Now is the time to make your opinion heard.  If <code class="language-plaintext highlighter-rouge">IO</code> in its current form doesn’t meet your needs, we want to hear about it!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/05/02/io-monad-for-cats.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/05/02/io-monad-for-cats.html</guid>
      </item>
    
      <item>
        <title>Equivalence versus Equality</title>
        
          <dc:creator>TomasMikula</dc:creator>
                
        <description><![CDATA[<p><em>This is a guest post by Tomas Mikula. It was initially published as a <a href="https://github.com/TomasMikula/hasheq/blob/017f289caac398723501b194cd2b36c4584df638/Equivalence-Equality.md">document</a> in the <a href="https://github.com/TomasMikula/hasheq">hasheq</a>. It has been slightly edited and is being republished here with the permission of the original author.</em></p>

<p>This article describes what we mean when we say that the data structures in this library are <em>equivalence-aware</em> in a <em>type-safe</em> fashion.</p>

<h2 id="equivalence">Equivalence</h2>

<p><em>Set</em> is a data structure that doesn’t contain <em>duplicate</em> elements. An implementation of <em>Set</em> must therefore have a way to compare elements for <em>“sameness”</em>.
A useful notion of sameness is <em>equivalence</em>, i.e. a binary relation that is <em>reflexive</em>, <em>symmetric</em> and <em>transitive</em>.
Any reasonable implementation of <em>Set</em> is equipped with <em>some</em> equivalence relation on its element type.</p>

<p>Here’s the catch: For any type with more than one inhabitant there are <em>multiple</em> valid equivalence relations.
We cannot (in general) pick one that is suitable in all contexts.
For example, are these two binary trees <em>same</em>?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  +            +
 / \          / \
1   +        +   3
   / \      / \
  2   3    1   2
</code></pre></div></div>

<p>It depends on the context. They clearly have different structure, but they are both binary search trees containing the same elements.
For a balancing algorithm, they are different trees, but as an implementation of <em>Set</em>, they represent the same set of integers.</p>

<h2 id="equality">Equality</h2>

<p>Despite the non-uniqueness, there is one equivalence relation that stands out: <em>equality</em>.
Two objects are considered <em>equal</em> when they are <em>indistinguishable</em> to an observer.
Formally, equality is required to have the <em>substitution property:</em></p>

<p>\[ \forall a,b \in A, \forall f \in (A \to B): a=_A b \implies f(a)=_B f(b) \]</p>

<p>(Here, $=_A$ denotes equality on $A$, $=_B$ denotes equality on $B$.)</p>

<p>Equality is the finest equivalence: whenever two elements are <em>equal</em>, they are necessarily <em>equivalent</em> with respect to every equivalence.</p>

<h2 id="choices-in-libraries">Choices in libraries</h2>

<p>Popular Scala libraries take one of these two approaches when dealing with comparing elements for <em>“sameness”</em>.</p>

<p>The current approach of <a href="https://github.com/typelevel/cats/">cats</a> is <em>equality</em>.
Instances of the <code class="language-plaintext highlighter-rouge">cats.Eq[A]</code> typeclass are required to have all the properties of equality, including the substitution property above.
The problem with this approach is that for some types, such as <code class="language-plaintext highlighter-rouge">Set[Int]</code>, equality is too strict to be useful:
Are values <code class="language-plaintext highlighter-rouge">Set(1, 2)</code> and <code class="language-plaintext highlighter-rouge">Set(2, 1)</code> <em>equal</em>?
For that to be true, they have to be indistinguishable by any function.
Let’s try <code class="language-plaintext highlighter-rouge">(_.toList)</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="py">toList</span> <span class="o">==</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="py">toList</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre></div></div>

<p>So, <code class="language-plaintext highlighter-rouge">Set(1, 2)</code> and <code class="language-plaintext highlighter-rouge">Set(2, 1)</code> are clearly <em>not</em> equal.
As a result, we cannot use <code class="language-plaintext highlighter-rouge">Set[Int]</code> in a context where equality is required (without cheating).</p>

<p>On the other hand, <a href="https://github.com/scalaz/scalaz/">scalaz</a> uses unspecified <em>equivalence</em>.
Although the name <code class="language-plaintext highlighter-rouge">scalaz.Equal[A]</code> might suggest <em>equality</em>, instances of this typeclass are only tested for properties of <em>equivalence</em>.
As mentioned above, there are multiple <em>valid</em> equivalence relations for virtually any type.
When there are also multiple <em>useful</em> equivalences for a type, we are at risk of mixing them up (and the fact that they are usually resolved as implicit arguments only makes things worse).</p>

<h2 id="equivalence-aware-sets-aka-setoids">Equivalence-aware sets (a.k.a. setoids)</h2>

<p>Let’s look at how <em>we</em> deal with this issue. We define typeclass <code class="language-plaintext highlighter-rouge">Equiv</code> with an extra type parameter that serves as a <em>“tag”</em> identifying the meaning of the equivalence.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Equiv</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Eq</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">equiv</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
<span class="c1">// defined trait Equiv
</span></code></pre></div></div>

<p>For the compiler, the “tag” is an opaque type. It only has specific meaning for humans. The only meaning it has for the compiler is that different tags represent (intensionally) different equivalence relations.</p>

<p>An <em>equivalence-aware</em> data structure then carries in its <em>type</em> the tag of the equivalence it uses.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">hasheq._</span>
<span class="c1">// import hasheq._
</span>
<span class="k">import</span> <span class="nn">hasheq.immutable._</span>
<span class="c1">// import hasheq.immutable._
</span>
<span class="k">import</span> <span class="nn">hasheq.std.int._</span>
<span class="c1">// import hasheq.std.int._
</span></code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>What on earth is <code class="language-plaintext highlighter-rouge">HashSetoid</code>?
A <a href="https://en.wikipedia.org/wiki/Setoid"><em>setoid</em></a> is an <em>equivalence-aware set</em>.
<code class="language-plaintext highlighter-rouge">HashSetoid</code> is then just a setoid implementated using hash-table.
Let’s look at the definition of <code class="language-plaintext highlighter-rouge">HashSet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">HashSet</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Equality.</span><span class="k">type</span><span class="o">]</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">HashSet</code> is just a <code class="language-plaintext highlighter-rouge">HashSetoid</code> whose equivalence is <em>equality</em>.
To create an instance of <code class="language-plaintext highlighter-rouge">HashSet[Int]</code> above, we needed to have an implicit instance of <code class="language-plaintext highlighter-rouge">Equiv[Int, Equality.type]</code> in scope.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implicitly</span><span class="o">[</span><span class="kt">Equiv</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Equality.</span><span class="k">type</span><span class="o">]]</span>
</code></pre></div></div>

<p>For the compiler, <code class="language-plaintext highlighter-rouge">Equality</code> is just a rather arbitrary singleton object.
It only has the meaning of mathematical <em>equality</em> for us, humans.</p>

<p>There is a convenient type alias provided for <em>equality</em> relation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Equiv</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Equality.</span><span class="k">type</span><span class="o">]</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
</code></pre></div></div>

<p>So how do we deal with the problem of set equality mentioned above, i.e. that <code class="language-plaintext highlighter-rouge">HashSet(1, 2)</code> and <code class="language-plaintext highlighter-rouge">HashSet(2, 1)</code> are not truly <em>equal</em>?
We just don’t provide a definition of equality for <code class="language-plaintext highlighter-rouge">HashSet[Int]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">22</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span> <span class="kt">e:</span> <span class="kt">hasheq.Equal</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
       <span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
                 <span class="o">^</span>
</code></pre></div></div>

<p>But that means we cannot have a <code class="language-plaintext highlighter-rouge">HashSet[HashSet[Int]]</code>!
(Remember, for a <code class="language-plaintext highlighter-rouge">HashSet[A]</code>, we need an instance of <code class="language-plaintext highlighter-rouge">Equal[A]</code>, and we just showed we don’t have an instance of <code class="language-plaintext highlighter-rouge">Equal[HashSet[Int]]</code>.)</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">22</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span> <span class="kt">A:</span> <span class="kt">hasheq.Hash</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
       <span class="nc">HashSet</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
              <span class="o">^</span>
</code></pre></div></div>

<p>But we can have a <code class="language-plaintext highlighter-rouge">HashSetoid[HashSet[Int], E]</code>, where <code class="language-plaintext highlighter-rouge">E</code> is <em>some</em> equivalence on <code class="language-plaintext highlighter-rouge">HashSet[Int]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">hasheq.immutable.Setoid.ContentEquiv</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">HashSet.of(elems)</code> is like <code class="language-plaintext highlighter-rouge">HashSet(elems)</code>, except it tries to infer the equivalence on the element type, instead of requiring it to be equality.</p>

<p>Notice the <em>equivalence tag</em>: <code class="language-plaintext highlighter-rouge">Setoid.ContentEquiv[Int, Equality.type]</code>.
Its meaning is (again, for humans only) that two setoids are equivalent when they contain the same elements (here, of type <code class="language-plaintext highlighter-rouge">Int</code>), as compared by the given equivalence of elements (here, <code class="language-plaintext highlighter-rouge">Equality</code>).</p>

<p>The remaining question is: How does this work in the presence of <em>multiple useful equivalences?</em></p>

<p>Let’s define another equivalence on <code class="language-plaintext highlighter-rouge">Int</code> (in addition to the provided equality).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Our "tag" for equivalence modulo 10.
// This trait will never be instantiated.
</span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Mod10</span>

<span class="c1">// Provide equivalence tagged by Mod10.
</span><span class="k">implicit</span> <span class="k">object</span> <span class="nc">EqMod10</span> <span class="k">extends</span> <span class="nc">Equiv</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">mod10</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">r</span> <span class="k">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">else</span> <span class="n">r</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="nf">equiv</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nf">mod10</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">==</span> <span class="nf">mod10</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Provide hash function compatible with equivalence modulo 10.
// Note that the HashEq typeclass is also tagged by Mod10.
</span><span class="k">implicit</span> <span class="k">object</span> <span class="nc">HashMod10</span> <span class="k">extends</span> <span class="nc">HashEq</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">hash</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">EqMod10</span><span class="o">.</span><span class="py">mod10</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let’s create a “setoid of sets of integers”, as before.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">hasheq.immutable.Setoid.ContentEquiv</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
</code></pre></div></div>

<p>This still works, because <code class="language-plaintext highlighter-rouge">HashSet</code> requires an <em>equality</em> on <code class="language-plaintext highlighter-rouge">Int</code>, and there is only one in the implicit scope (the newly defined equivalence <code class="language-plaintext highlighter-rouge">EqMod10</code> is <em>not</em> equality).
Let’s try to create a “setoid of setoids of integers”:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">24</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">ambiguous</span> <span class="kt">implicit</span> <span class="kt">values:</span>
 <span class="kt">both</span> <span class="kt">method</span> <span class="kt">hashInstance</span> <span class="kt">in</span> <span class="kt">object</span> <span class="kt">int</span> <span class="kt">of</span> <span class="k">type</span> <span class="o">=&gt;</span> <span class="nv">hasheq</span><span class="o">.</span><span class="py">Hash</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
 <span class="n">and</span> <span class="k">object</span> <span class="nc">HashMod10</span> <span class="n">of</span> <span class="k">type</span> <span class="kt">HashMod10.type</span>
 <span class="k">match</span> <span class="n">expected</span> <span class="k">type</span> <span class="kt">hasheq.HashEq</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Eq</span><span class="o">]</span>
       <span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
                            <span class="o">^</span>
</code></pre></div></div>

<p>This fails, because there are now more equivalences on <code class="language-plaintext highlighter-rouge">Int</code> in scope.
(There are now also multiple hash functions, which is what the error message actually says.)
We need to be more specific:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span>,<span class="kt">hasheq.immutable.Setoid.ContentEquiv</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
</code></pre></div></div>

<p>Finally, does it <strong>prevent mixing up equivalences</strong>? Let’s see:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">s1</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>         <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">13</span>    <span class="o">)</span>
<span class="n">s1</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">11</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">s2</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span>    <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>  <span class="mi">4</span><span class="o">,</span>  <span class="mi">5</span><span class="o">,</span>         <span class="mi">13</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>
<span class="n">s2</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">t1</span> <span class="k">=</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>         <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">13</span>    <span class="o">)</span>
<span class="n">t1</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">t2</span> <span class="k">=</span> <span class="nv">HashSet</span><span class="o">.</span><span class="py">of</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">](</span>    <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>  <span class="mi">4</span><span class="o">,</span>  <span class="mi">5</span><span class="o">,</span>         <span class="mi">13</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>
<span class="n">t2</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Combining compatible setoids:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="n">union</span> <span class="n">s2</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t1</span> <span class="n">union</span> <span class="n">t2</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Combining incompatible setoids:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="n">union</span> <span class="n">t2</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">26</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]</span>
       <span class="n">s1</span> <span class="n">union</span> <span class="n">t2</span>
                <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t1</span> <span class="n">union</span> <span class="n">s2</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">26</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="o">(</span><span class="n">which</span> <span class="n">expands</span> <span class="n">to</span><span class="o">)</span>  <span class="nv">hasheq</span><span class="o">.</span><span class="py">immutable</span><span class="o">.</span><span class="py">HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span>
       <span class="n">t1</span> <span class="n">union</span> <span class="n">s2</span>
                <span class="o">^</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>We went one step further in the direction of type-safe equivalence in Scala compared to what is typically seen out in the wild today.
There is nothing very sophisticated about this encoding.
I think the major win is that we can design APIs so that the extra type parameter (the “equivalence tag”) stays unnoticed by the user of the API as long as they only deal with <em>equalities</em>.
As soon as the equivalence tag starts requesting our attention (via an ambiguous implicit or a type error), it is likely that the attention is justified.</p>

<p><em>This article was tested with Scala 2.11.8 and hasheq version 0.3.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 02 Apr 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/04/02/equivalence-vs-equality.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/04/02/equivalence-vs-equality.html</guid>
      </item>
    
      <item>
        <title>Four ways to escape a cake</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>The mixin style of importing in which classes and traits are defined
within traits, as seen in <code class="language-plaintext highlighter-rouge">scala.reflect.Universe</code>, ScalaTest, and
other Scala styles, seems to be infectious. By that, I mean once you
define something in a trait to be mixed in, to produce another
reusable module that calls that thing, you must define <em>another</em>
trait, and so must anyone using <em>your</em> module, and so on and so forth.
You effectively become “trapped in the cake”.</p>

<p>However, we can use type parameters that represent <strong>singleton types</strong>
to write functions that are polymorphic over these “cakes”, without
being defined as part of them or mixed in themselves. For example, you
can use this to write functions that operate on elements of a
reflection universe, without necessarily passing that universe around
all over the place.</p>

<p>Well, for the most part. Let’s see how far this goes.</p>

<h2 id="our-little-universe">Our little universe</h2>

<p>Let’s set aside the heavyweight real-world examples I mentioned above
in favor of a small example. Then, we should be able to explore the
possibilities in this simpler space.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LittleUniverse</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">haystack</span><span class="k">:</span> <span class="kt">Haystack</span> <span class="o">=</span> <span class="nc">Haystack</span><span class="o">()</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Haystack</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">init</span><span class="k">:</span> <span class="kt">Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
    <span class="k">def</span> <span class="nf">iter</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">Needle</span> <span class="o">=</span> <span class="n">n</span>
  <span class="o">}</span>
  
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Needle</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>For brevity, I’ve defined member <code class="language-plaintext highlighter-rouge">class</code>es, but this article equally
applies if you are using abstract <code class="language-plaintext highlighter-rouge">type</code>s instead, as any Functional
programmer of pure, virtuous heart ought to!</em></p>

<p>Suppose we have a universe.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">lu</span><span class="k">:</span> <span class="kt">LittleUniverse</span> <span class="o">=</span> <span class="nc">LittleUniverse</span><span class="o">()</span>
<span class="n">lu</span><span class="k">:</span> <span class="kt">LittleUniverse</span> <span class="o">=</span> <span class="nc">LittleUniverse</span><span class="o">()</span>
</code></pre></div></div>

<p>The thing that Scala does for us is not let <code class="language-plaintext highlighter-rouge">Haystack</code>s and <code class="language-plaintext highlighter-rouge">Needle</code> s
from one universe be confused with those from another.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">anotherU</span> <span class="k">=</span> <span class="nc">LittleUniverse</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">anotherU</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">anotherU.Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">lu.Needle</span>
       <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">anotherU</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
                                          <span class="o">^</span>
</code></pre></div></div>

<p>The meaning of this error is “you can’t use one universe’s <code class="language-plaintext highlighter-rouge">Haystack</code>
to <code class="language-plaintext highlighter-rouge">iter</code> a <code class="language-plaintext highlighter-rouge">Needle</code> from another universe”.</p>

<p>This doesn’t look very important given the above code, but it’s a
<em>real</em> boon to more complex scenarios. You can set up a lot of
interdependent abstract invariants, verify them all, and have the
whole set represented with the “index” formed by the singleton type,
here <code class="language-plaintext highlighter-rouge">lu.type</code> or <code class="language-plaintext highlighter-rouge">anotherU.type</code>.</p>

<h2 id="working-with-a-universe-on-hand">Working with a universe on hand</h2>

<p>Refactoring in macro-writing style seems to be based upon passing the
universe around everywhere. We can do that.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">twoInits</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">u.Needle</span><span class="o">,</span> <span class="kt">u.Needle</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">,</span> <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
  
<span class="k">def</span> <span class="nf">stepTwice</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">u.Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">u.Needle</span> <span class="o">=</span>
  <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
</code></pre></div></div>

<p>The most important feature we’re reaching for with these fancy
dependent method types, and the one that we have to <em>keep</em> reaching
for if we want to write sane functions outside the cake, is
<strong>preserving the singleton type index</strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">twoInits</span><span class="o">(</span><span class="n">lu</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">lu.Needle</span><span class="o">,</span> <span class="kt">lu.Needle</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Needle</span><span class="o">(),</span><span class="nc">Needle</span><span class="o">())</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">stepTwice</span><span class="o">(</span><span class="n">anotherU</span><span class="o">)(</span><span class="nv">anotherU</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">anotherU.Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
</code></pre></div></div>

<p>These values are ready for continued <code class="language-plaintext highlighter-rouge">iter</code>ing, or whatever else
you’ve come up with, in the confines of their respective
universes. That’s because they’ve “remembered” where they came from.</p>

<p>By contrast, consider a simple replacement of the path-dependencies
with a type projection.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">brokenTwoInits</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)</span>
    <span class="k">:</span> <span class="o">(</span><span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">,</span> <span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">,</span> <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">bti</span> <span class="k">=</span> <span class="nf">brokenTwoInits</span><span class="o">(</span><span class="n">lu</span><span class="o">)</span>
<span class="n">bti</span><span class="k">:</span> <span class="o">(</span><span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">,</span> <span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Needle</span><span class="o">(),</span><span class="nc">Needle</span><span class="o">())</span>
</code></pre></div></div>

<p>That seems to be okay, until it’s time to actually use the result.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">bti</span><span class="o">.</span><span class="py">_1</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">lu.Needle</span>
       <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">bti</span><span class="o">.</span><span class="py">_1</span><span class="o">)</span>
                            <span class="o">^</span>
</code></pre></div></div>

<p>The return type of <code class="language-plaintext highlighter-rouge">brokenTwoInits</code> “forgot” the index, <code class="language-plaintext highlighter-rouge">lu.type</code>.</p>

<h2 id="getting-two-needles-without-a-universe">Getting two needles without a universe</h2>

<p>When we pass a <code class="language-plaintext highlighter-rouge">LittleUniverse</code> to the above functions, we’re also
kind of passing in a constraint on the singleton type created by the
argument variable. That’s how we know that the returned <code class="language-plaintext highlighter-rouge">u.Needle</code> is
a perfectly acceptable <code class="language-plaintext highlighter-rouge">lu.Needle</code> in the caller scope, when we pass
<code class="language-plaintext highlighter-rouge">lu</code> as the universe.</p>

<p>However, as the contents of a universe become more complex, there are
many more interactions that need not involve a universe at all, at
least not directly.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">twoInitsFromAHaystack</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">,</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="nv">h</span><span class="o">.</span><span class="py">init</span><span class="o">,</span> <span class="nv">h</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
  
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">tifah</span> <span class="k">=</span> <span class="n">twoInitsFromAHaystack</span><span class="o">[</span><span class="kt">lu.</span><span class="k">type</span><span class="o">](</span><span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">)</span>
<span class="n">tifah</span><span class="k">:</span> <span class="o">(</span><span class="kt">lu.Needle</span><span class="o">,</span> <span class="kt">lu.Needle</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Needle</span><span class="o">(),</span><span class="nc">Needle</span><span class="o">())</span>
</code></pre></div></div>

<p>Since we didn’t pass in <code class="language-plaintext highlighter-rouge">lu</code>, how did it know that the returned
<code class="language-plaintext highlighter-rouge">Needle</code>s were <code class="language-plaintext highlighter-rouge">lu.Needle</code>s?</p>

<ol>
  <li>The type of <code class="language-plaintext highlighter-rouge">lu.haystack</code> is <code class="language-plaintext highlighter-rouge">lu.Haystack</code>.</li>
  <li>That type is shorthand for <code class="language-plaintext highlighter-rouge">lu.type#Haystack</code>.</li>
  <li>We passed in <code class="language-plaintext highlighter-rouge">U = lu.type</code>, and our argument meets the resulting
requirement for a <code class="language-plaintext highlighter-rouge">lu.type#Haystack</code> (after expanding <code class="language-plaintext highlighter-rouge">U</code>).</li>
  <li>The type of the expression <code class="language-plaintext highlighter-rouge">h.init</code> is
<code class="language-plaintext highlighter-rouge">u.Needle forSome {val u: U}</code>. We use an existential because the
relevant variable (and its singleton type) is not in scope.</li>
  <li>This type <em>widens</em> to <code class="language-plaintext highlighter-rouge">U#Needle</code>, satisfying the expected return
type.</li>
</ol>

<p>This seems like a more complicated way of doing things, but it’s very
freeing: by not being forced to <em>necessarily</em> pass the universe around
everywhere, you’ve managed to escape the cake’s clutches much more
thoroughly. You can also write syntax enrichments on various members
of the universe that don’t need to talk about the universe’s value,
just its singleton type.</p>

<p>Unless, you know, the index appears in contravariant position.</p>

<h2 id="syntactic-steptwice">Syntactic <code class="language-plaintext highlighter-rouge">stepTwice</code></h2>

<p>One test of how well we’ve managed to escape the cake is to be able to
write enrichments that deal with the universe. This is a little
tricky, but quite doable if you have the universe’s value.</p>

<p>With the advent of <code class="language-plaintext highlighter-rouge">implicit class</code>, this became a little easier to do
wrongly, but it’s a good start.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">NonWorkingStepTwice</span><span class="o">(</span><span class="k">val</span> <span class="nv">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">stepTwiceOops</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">u.Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">u.Needle</span> <span class="o">=</span>
    <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That compiles okay, but seemingly can’t actually be used!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">lu</span> <span class="n">stepTwiceOops</span> <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">lu.Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.u.Needle</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">NonWorkingStepTwice</span>
       <span class="n">lu</span> <span class="n">stepTwiceOops</span> <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span>
                                    <span class="o">^</span>
</code></pre></div></div>

<p>There’s a hint in that we had to write <code class="language-plaintext highlighter-rouge">val u</code>, not <code class="language-plaintext highlighter-rouge">u</code>, nor <code class="language-plaintext highlighter-rouge">private
val u</code>, in order for the <code class="language-plaintext highlighter-rouge">implicit class</code> itself to compile. This
signature tells us that there’s an <em>argument</em> of type
<code class="language-plaintext highlighter-rouge">LittleUniverse</code>, and a <em>member</em> <code class="language-plaintext highlighter-rouge">u: LittleUniverse</code>. However, whereas
with the function examples above, we [and the compiler] could trust
that they’re one and the same, we have no such guarantee here. So we
don’t know that an <code class="language-plaintext highlighter-rouge">lu.Needle</code> is a <code class="language-plaintext highlighter-rouge">u.Needle</code>. We didn’t get far
enough, but we don’t know that a <code class="language-plaintext highlighter-rouge">u.Needle</code> is an <code class="language-plaintext highlighter-rouge">lu.Needle</code>, either.</p>

<h2 id="relatable-variables">Relatable variables</h2>

<p>Instead, we have to expand a little bit, and take advantage of a very
interesting, if obscure, element of the type equivalence rules in the
Scala language.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">WorkingStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="k">val</span> <span class="nv">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">stepTwice</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">u.Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">u.Needle</span> <span class="o">=</span>
    <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">WorkingStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">WorkingStepTwice</span><span class="o">[</span><span class="kt">u.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">WorkingStepTwice</span><span class="o">(</span><span class="n">u</span><span class="o">)</span>
</code></pre></div></div>

<p><em>Unfortunately, the ritual of expanding the <code class="language-plaintext highlighter-rouge">implicit class</code> shorthand
is absolutely necessary; the <code class="language-plaintext highlighter-rouge">implicit class</code> won’t generate the
dependent-method-typed implicit conversion we need.</em></p>

<p>Now we can get the proof we need.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">lu</span> <span class="n">stepTwice</span> <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span>
<span class="n">res7</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.u.Needle</span> <span class="k">forSome</span> <span class="o">{</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">WorkingStepTwice</span><span class="o">[</span><span class="kt">lu.</span><span class="k">type</span><span class="o">]</span> <span class="o">}</span> <span class="k">=</span> <span class="nc">Needle</span><span class="o">()</span>

<span class="c1">// that's a little weird, but reduces to what we need
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res7</span><span class="k">:</span> <span class="kt">lu.Needle</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">lu.Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
</code></pre></div></div>

<p>How does this work?</p>

<ol>
  <li>Implicitly convert <code class="language-plaintext highlighter-rouge">lu</code>, giving us a <code class="language-plaintext highlighter-rouge">conv:
WorkingStepTwice[lu.type]</code>.</li>
  <li>This means that <code class="language-plaintext highlighter-rouge">conv.u: lu.type</code>, by expansion of <code class="language-plaintext highlighter-rouge">U</code>.</li>
  <li>This in turn means that <code class="language-plaintext highlighter-rouge">conv.u.type &lt;: lu.type</code>.</li>
</ol>

<p>The next part is worth taking in two parts. It may be worth
having
<a href="http://www.scala-lang.org/files/archive/spec/2.12/03-types.html#conformance">§3.5.2 “Conformance”</a> of
the language spec open for reference. First, let’s consider the return
type (a covariant position), which is simpler.</p>

<ol>
  <li>The return type expands to <code class="language-plaintext highlighter-rouge">conv.u.type#Needle</code>.</li>
  <li>The ninth conformance bullet point tells us that the left side of a
<code class="language-plaintext highlighter-rouge">#</code> projection is covariant, so because <code class="language-plaintext highlighter-rouge">conv.u.type &lt;: lu.type</code>
(see above), the return type <em>widens</em> to <code class="language-plaintext highlighter-rouge">lu.type#Needle</code>.</li>
  <li>For this, <code class="language-plaintext highlighter-rouge">lu.Needle</code> is a shorthand.</li>
</ol>

<p>It was far longer until I realized how the argument type works. You’ll
want to scroll up on the SLS a bit, to the “Equivalence” section. Keep
in mind that we are trying to widen <code class="language-plaintext highlighter-rouge">lu.Needle</code> to <code class="language-plaintext highlighter-rouge">conv.u.Needle</code>,
which is the reverse of what we did for the return type.</p>

<ol>
  <li>Our argument’s type expands to <code class="language-plaintext highlighter-rouge">lu.type#Needle</code>.</li>
  <li>The second bullet point under “Equivalence” says that “If a path
<em>p</em> has a singleton type <em>q</em><code class="language-plaintext highlighter-rouge">.type</code>, then <em>p</em><code class="language-plaintext highlighter-rouge">.type</code> ≡ <em>q</em><code class="language-plaintext highlighter-rouge">.type</code>.”
From this, we can derive that <code class="language-plaintext highlighter-rouge">conv.u.type = lu.type</code>. This is a
stronger conclusion than we reached above!</li>
  <li>We substitute the left side of the <code class="language-plaintext highlighter-rouge">#</code> using the equivalence,
giving us <code class="language-plaintext highlighter-rouge">conv.u.type#Needle</code>.</li>
</ol>

<p>I cannot characterize this feature of the type system as anything
other than “really freaky” when you first encounter it. It seems like
an odd corner case. Normally, when you write <code class="language-plaintext highlighter-rouge">val x: T</code>, then <code class="language-plaintext highlighter-rouge">x.type</code>
is a <em>strict</em> subtype of <code class="language-plaintext highlighter-rouge">T</code>, and you can count on that, but this
carves out an exception to that rule. It is sound, though, and an
absolutely essential feature!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">sameLu</span><span class="k">:</span> <span class="kt">lu.</span><span class="k">type</span> <span class="o">=</span> <span class="n">lu</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">sameLu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">sameLu.Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
</code></pre></div></div>

<p>Without this rule, even though we have given it the most specific type
possible, <code class="language-plaintext highlighter-rouge">sameLu</code> couldn’t be a <em>true</em> substitute for <code class="language-plaintext highlighter-rouge">lu</code> in all
scenarios. That means that in order to make use of singleton type
indices, we would be forever beholden to the <em>variable</em> we initially
stored the value in. I think this would be <em>extremely inconvenient</em>,
structurally, in almost all useful programs.</p>

<p>With the rule in place, we can fully relate the <code class="language-plaintext highlighter-rouge">lu</code> and <code class="language-plaintext highlighter-rouge">conv.u</code>
variables, to let us reorganize how we talk about universes and values
indexed by their singleton types in many ways.</p>

<h2 id="a-pointless-argument">A pointless argument</h2>

<p>Let’s try to hide the universe. We don’t need it, after all. We can’t
refer to <code class="language-plaintext highlighter-rouge">u</code> in the method signature anymore, so let’s try the same
conversion we used with <code class="language-plaintext highlighter-rouge">twoInitsFromAHaystack</code>. We already have the
<code class="language-plaintext highlighter-rouge">U</code> type parameter, after all.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CleanerStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="k">private</span> <span class="k">val</span> <span class="nv">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">stepTwiceLively</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
    <span class="o">???</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">CleanerStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">CleanerStepTwice</span><span class="o">[</span><span class="kt">u.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">CleanerStepTwice</span><span class="o">(</span><span class="n">u</span><span class="o">)</span>
</code></pre></div></div>

<p>This has the proper signature, and it’s cleaner, since we don’t expose
the unused-at-runtime <code class="language-plaintext highlighter-rouge">u</code> variable anymore. We could refine a little
further, and replace it with a <code class="language-plaintext highlighter-rouge">U#Haystack</code>, just as with
<code class="language-plaintext highlighter-rouge">twoInitsFromAHaystack</code>.</p>

<p>This gives us the same interface, with all the index preservation we
need. Even better, it infers a nicer return type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">trial</span> <span class="k">=</span> <span class="n">lu</span> <span class="n">stepTwiceLively</span> <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span>
<span class="n">trial</span><span class="k">:</span> <span class="kt">lu.Needle</span>
</code></pre></div></div>

<p>Now, let’s turn to implementation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OnceMoreStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">stepTwiceFinally</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
    <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">OnceMoreStepTwice.this.u.Needle</span>
           <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                                           <span class="o">^</span>
</code></pre></div></div>

<p>This is the last part of the escape! If this worked, we could <em>fully
erase</em> the <code class="language-plaintext highlighter-rouge">LittleUniverse</code> from most code, relying on the pure
type-level index to prove enough of its existence! So it’s a little
frustrating that it doesn’t quite work.</p>

<p>Let’s break it down. First, the return type is fine.</p>

<ol>
  <li>Since <code class="language-plaintext highlighter-rouge">u: U</code>, <code class="language-plaintext highlighter-rouge">u.type &lt;: U</code>. (This is true, and useful, in the
scope of <code class="language-plaintext highlighter-rouge">u</code>, which is now invisible to the caller.)</li>
  <li><code class="language-plaintext highlighter-rouge">iter</code> returns a <code class="language-plaintext highlighter-rouge">u.type#Needle</code>.
    <ul>
      <li>Note: since <code class="language-plaintext highlighter-rouge">u</code> is not in scope for the caller, if we returned
this as is, it would effectively widen to the existentially
bound <code class="language-plaintext highlighter-rouge">u.type#Needle forSome {val u: U}</code>. But the same logic in
the next step would apply to that type.</li>
    </ul>
  </li>
  <li>By the <code class="language-plaintext highlighter-rouge">#</code> left side covariance, <code class="language-plaintext highlighter-rouge">u.type#Needle</code> widens to
<code class="language-plaintext highlighter-rouge">U#Needle</code>.</li>
</ol>

<p>Pretty simple, by the standards of what we’ve seen so far.</p>

<h2 id="contravariance-is-the-root-of-all">Contravariance is the root of all…</h2>

<p>But things break down when we try to call <code class="language-plaintext highlighter-rouge">iter(n)</code>. Keep in mind that
<code class="language-plaintext highlighter-rouge">n: U#Needle</code> and the expected type is <code class="language-plaintext highlighter-rouge">u.Needle</code>. Specifically: since
we don’t know in the implementation that <code class="language-plaintext highlighter-rouge">U</code> is a singleton type, we
can’t use the “singleton type equivalence” rule on it! But suppose
that we <em>could</em>; that is, <strong>suppose that we could constrain <code class="language-plaintext highlighter-rouge">U</code> to be
a singleton type</strong>.</p>

<ol>
  <li>The argument type is <code class="language-plaintext highlighter-rouge">U#Needle</code>.</li>
  <li>By singleton equivalence, since <code class="language-plaintext highlighter-rouge">u: U</code> and <code class="language-plaintext highlighter-rouge">u</code> is stable, so
<code class="language-plaintext highlighter-rouge">u.type = U</code>.</li>
  <li>By substituting the left-hand side of the <code class="language-plaintext highlighter-rouge">#</code>, we get
<code class="language-plaintext highlighter-rouge">u.type#Needle</code>.</li>
  <li>This shortens to <code class="language-plaintext highlighter-rouge">u.Needle</code>.</li>
</ol>

<p>If we are unable to constrain <code class="language-plaintext highlighter-rouge">U</code> in this way, though, we are
restricted to places where <code class="language-plaintext highlighter-rouge">U</code> occurs in covariant position when using
cake-extracted APIs.  We can invoke functions like <code class="language-plaintext highlighter-rouge">init</code>, because
they only have the singleton index occurring in covariant position.</p>

<p>Invoking functions like <code class="language-plaintext highlighter-rouge">iter</code>, where the index occurs in
contravariant or invariant position, requires being able to add this
constraint, so that we can use singleton equivalence directly on the
type variable <code class="language-plaintext highlighter-rouge">U</code>.  This is quite a bit trickier.</p>

<h2 id="extracting-more-types">Extracting more types</h2>

<p>We have the same problem with the function version.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stepTwiceHaystack</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
  <span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.Needle</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">U</span>
         <span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                       <span class="o">^</span>
</code></pre></div></div>

<p>Let’s walk through it one more time.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">n: U#Needle</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">h.iter</code> expects a <code class="language-plaintext highlighter-rouge">u.type#Needle</code> for all <code class="language-plaintext highlighter-rouge">val u: U</code>.</li>
  <li><strong>Suppose that we constrain <code class="language-plaintext highlighter-rouge">U</code> to be a singleton type</strong>:
    <ol>
      <li>[The existential] <code class="language-plaintext highlighter-rouge">u.type = U</code>, by singleton equivalence.</li>
      <li>By <code class="language-plaintext highlighter-rouge">#</code> left side equivalence, <code class="language-plaintext highlighter-rouge">h.iter</code> expects a <code class="language-plaintext highlighter-rouge">U#Needle</code>.</li>
    </ol>
  </li>
</ol>

<p>The existential variable complicates things, but the rule is sound.</p>

<p>As a workaround, it is commonly suggested to extract the member types
in question into separate type variables. This works in some cases,
but let’s see how it goes in this one.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stepTwiceExUnim</span><span class="o">[</span><span class="kt">N</span>, <span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">{</span><span class="k">type</span> <span class="kt">Needle</span> <span class="kt">=</span> <span class="kt">N</span><span class="o">}](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">N</span><span class="o">)</span><span class="k">:</span> <span class="kt">N</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>This looks a lot weirder, but should be able to return the right type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">trial2</span> <span class="k">=</span> <span class="n">stepTwiceExUnim</span><span class="o">[</span><span class="kt">lu.Needle</span>, <span class="kt">lu.</span><span class="k">type</span><span class="o">](</span><span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">,</span> <span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
<span class="n">trial2</span><span class="k">:</span> <span class="kt">lu.Needle</span>
</code></pre></div></div>

<p>But this situation is complex enough for the technique to not work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stepTwiceEx</span><span class="o">[</span><span class="kt">N</span>, <span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">{</span><span class="k">type</span> <span class="kt">Needle</span> <span class="kt">=</span> <span class="kt">N</span><span class="o">}](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">N</span><span class="o">)</span><span class="k">:</span> <span class="kt">N</span> <span class="o">=</span>
  <span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">N</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.Needle</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">U</span>
         <span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                       <span class="o">^</span>
</code></pre></div></div>

<p>Instead, we need to index <code class="language-plaintext highlighter-rouge">Haystack</code> <em>directly</em> with the <code class="language-plaintext highlighter-rouge">Needle</code>
type, that is, add a type parameter to <code class="language-plaintext highlighter-rouge">Haystack</code> so that its <code class="language-plaintext highlighter-rouge">Needle</code>
arguments can be talked about completely independently of the
<code class="language-plaintext highlighter-rouge">LittleUniverse</code>, and then to write <code class="language-plaintext highlighter-rouge">h: U#Haystack[N]</code>
above. Essentially, this means that any time a type talks about
another type in a <code class="language-plaintext highlighter-rouge">Universe</code>, you need another type parameter to
redeclare a little bit of the relationships between types in the
universe.</p>

<p>The problem with this is that we already declared those relationships
by declaring the universe! All of the non-redundant information is
represented in the singleton type index. So even where the above
type-refinement technique works (and it does in many cases), it’s
<em>still</em> redeclaring things that ought to be derivable from the “mere”
fact that <code class="language-plaintext highlighter-rouge">U</code> is a singleton type.</p>

<h2 id="the-fact-that-its-a-singleton-type">The fact that it’s a singleton type</h2>

<p><em>(The following is based on enlightening commentary by Daniel Urban on
an earlier draft.)</em></p>

<p>Let’s examine the underlying error in <code class="language-plaintext highlighter-rouge">stepTwiceEx</code> more directly.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">fetchIter</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="k">#</span><span class="nc">Needle</span> <span class="k">=</span> <span class="nv">h</span><span class="o">.</span><span class="py">iter</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">method</span> <span class="kt">fetchIter</span><span class="o">)</span><span class="k">#</span><span class="kt">Needle</span>
             <span class="n">where</span> <span class="k">type</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">method</span> <span class="kt">fetchIter</span><span class="o">)</span> <span class="k">&lt;:</span> <span class="kt">U</span> <span class="kt">with</span> <span class="kt">Singleton</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">$anonfun</span><span class="o">)</span><span class="k">#</span><span class="kt">Needle</span>
             <span class="n">where</span> <span class="k">type</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">$anonfun</span><span class="o">)</span> <span class="k">&lt;:</span> <span class="kt">U</span> <span class="kt">with</span> <span class="kt">Singleton</span>
           <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="k">#</span><span class="nc">Needle</span> <span class="k">=</span> <span class="nv">h</span><span class="o">.</span><span class="py">iter</span>
                                                    <span class="o">^</span>
</code></pre></div></div>

<p>It’s a good thing that this doesn’t compile. If it did, we could do</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fetchIter</span><span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">](</span><span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">)(</span><span class="nv">anotherU</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">init</span><span class="o">)</span>
</code></pre></div></div>

<p>Which is unsound.</p>

<p><a href="http://www.scala-lang.org/files/archive/spec/2.12/03-types.html#singleton-types">§3.2.1 “Singleton Types”</a> of
the specification mentions this <code class="language-plaintext highlighter-rouge">Singleton</code>, which is in a way related
to singleton types.</p>

<blockquote>
  <p>A <em>stable type</em> is either a singleton type or a type which is
declared to be a subtype of trait <code class="language-plaintext highlighter-rouge">scala.Singleton</code>.</p>
</blockquote>

<p>Adding <code class="language-plaintext highlighter-rouge">with Singleton</code> to the upper bound on <code class="language-plaintext highlighter-rouge">U</code> causes <code class="language-plaintext highlighter-rouge">fetchIter</code>
to compile! This is sound, because we are protected from the above
problem with the original <code class="language-plaintext highlighter-rouge">fetchIter</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetchIter</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="k">#</span><span class="nc">Needle</span> <span class="k">=</span> <span class="nv">h</span><span class="o">.</span><span class="py">iter</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fetchIter</span><span class="o">[</span><span class="kt">lu.</span><span class="k">type</span><span class="o">](</span><span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">lu.Needle</span> <span class="o">=&gt;</span> <span class="nv">lu</span><span class="o">.</span><span class="py">Needle</span> <span class="k">=</span> <span class="nc">$$Lambda$1397</span><span class="o">/</span><span class="mi">1159581520</span><span class="k">@</span><span class="mi">683</span><span class="n">e7892</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fetchIter</span><span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">](</span><span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
                     <span class="n">to</span> <span class="n">method</span> <span class="n">fetchIter</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span>
                     <span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">]</span>
       <span class="n">fetchIter</span><span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">](</span><span class="nv">lu</span><span class="o">.</span><span class="py">haystack</span><span class="o">)</span>
                <span class="o">^</span>
</code></pre></div></div>

<p>Let’s walk through the logic for <code class="language-plaintext highlighter-rouge">fetchIter</code>. The expression <code class="language-plaintext highlighter-rouge">h.iter</code>
has type <code class="language-plaintext highlighter-rouge">u.Needle =&gt; u.Needle</code> for some <code class="language-plaintext highlighter-rouge">val u: U</code>, and our goal type
is <code class="language-plaintext highlighter-rouge">U#Needle =&gt; U#Needle</code>. So we have two subgoals: prove
<code class="language-plaintext highlighter-rouge">u.Needle &lt;: U#Needle</code> for the covariant position (after <code class="language-plaintext highlighter-rouge">=&gt;</code>), and
<code class="language-plaintext highlighter-rouge">U#Needle &lt;: u.Needle</code> for the contravariant position (before <code class="language-plaintext highlighter-rouge">=&gt;</code>).</p>

<p>First, covariant:</p>

<ol>
  <li>Since <code class="language-plaintext highlighter-rouge">u: U</code>, <code class="language-plaintext highlighter-rouge">u.type &lt;: U</code>.</li>
  <li>Since the left side of <code class="language-plaintext highlighter-rouge">#</code> is covariant, #1 implies
<code class="language-plaintext highlighter-rouge">u.type#Needle &lt;: U#Needle</code>.</li>
  <li>This re-sugars to <code class="language-plaintext highlighter-rouge">u.Needle &lt;: U#Needle</code>, which is the goal.</li>
</ol>

<p>Secondly, contravariant. We’re going to have to make a best guess
here, because it’s not entirely clear to me what’s going on.</p>

<ol>
  <li>Since [existential] path <code class="language-plaintext highlighter-rouge">u</code> has a singleton type <code class="language-plaintext highlighter-rouge">U</code> (if we define
“has a singleton type” as “having a type <em>X</em> such that
<em>X</em><code class="language-plaintext highlighter-rouge"> &lt;: Singleton</code>”), so <code class="language-plaintext highlighter-rouge">u.type = U</code> by the singleton equivalence.</li>
  <li>Since equivalence implies conformance, according to the first
bullet under “Conformance”, #1 implies <code class="language-plaintext highlighter-rouge">U &lt;: u.type</code>.</li>
  <li>Since the left side of <code class="language-plaintext highlighter-rouge">#</code> is covariant, #2 implies that
<code class="language-plaintext highlighter-rouge">U#Needle &lt;: u.type#Needle</code>.</li>
  <li>This resugars to <code class="language-plaintext highlighter-rouge">U#Needle &lt;: u.Needle</code>, which is the goal.</li>
</ol>

<p>I don’t quite understand this, because <code class="language-plaintext highlighter-rouge">U</code> doesn’t <em>seem</em> to meet the
requirements for “singleton type”, according to the definition of
singleton types. However, I’m <em>fairly</em> sure it’s sound, since type
stability seems to be the property that lets us avoid the
universe-mixing unsoundness. Unfortunately, it only seems to work with
<em>existential</em> <code class="language-plaintext highlighter-rouge">val</code>s; we seem to be out of luck with <code class="language-plaintext highlighter-rouge">val</code>s that the
compiler can still see.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// works fine!
</span><span class="k">def</span> <span class="nf">stepTwiceSingly</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">h</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// but alas, this form doesn't
</span><span class="k">class</span> <span class="nc">StepTwiceSingly</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">stepTwiceSingly</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
    <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">StepTwiceSingly.this.u.Needle</span>
           <span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">haystack</span><span class="o">.</span><span class="py">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                                            <span class="o">^</span>
</code></pre></div></div>

<p>We can work around this by having the second form invoke the first
with the <code class="language-plaintext highlighter-rouge">Haystack</code>, thus “existentializing” the universe. I imagine
that <em>most</em>, albeit not all, cakes can successfully follow this
strategy.</p>

<p>So, finally, we’re almost out of the cake.</p>

<ol>
  <li>Escape covariant positions with universe variable: complete.</li>
  <li>Escape contravariant/invariant positions with universe variable:
complete.</li>
  <li>Escape covariant positions with universe <em>singleton type</em>:
complete!</li>
  <li>Escape contravariant/invariant positions with universe singleton
type: 90% there!</li>
</ol>

<p><em>This article was tested with Scala 2.12.1.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 01 Mar 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/03/01/four-ways-to-escape-a-cake.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/03/01/four-ways-to-escape-a-cake.html</guid>
      </item>
    
      <item>
        <title>There are more types than classes</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>As programmers, we are very incautious with our use of the word
“type”. The concept of “type” is sufficiently abstract and specific
that we are tempted to understand it by analogy, so much that we begin
to confuse analogy with sameness.</p>

<p>The colloquial “runtime type”, a fair approximation of “class”, makes
it tempting to equate <em>types</em> with “classes, interfaces, traits, that
sort of thing”, which I will name <em>classes</em> for the rest of this
article. But they aren’t the same. The type system is much richer and
more interesting than the class system, even in Java.</p>

<p>To appreciate this richness, we must stop thinking of types as classes
and stop drawing conclusions from that weak analogy. Luckily, the
compiler will readily reveal how unlike classes types are, if we ask
it some simple questions.</p>

<h2 id="one-value-with-class-many-variables-with-type">One value with class, many variables with type</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">greeting</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"hi there!"</span>
</code></pre></div></div>

<p>Here I have constructed a <code class="language-plaintext highlighter-rouge">String</code> and assigned it to a variable. (I
have also constructed the <code class="language-plaintext highlighter-rouge">char</code> array in the <code class="language-plaintext highlighter-rouge">String</code> and various
other details, but immediately handed those off to the <code class="language-plaintext highlighter-rouge">String</code> and
forgotten about them.) This value has class <code class="language-plaintext highlighter-rouge">String</code>. It has several
classes, really.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">String</code></li>
  <li><code class="language-plaintext highlighter-rouge">java.io.Serializable</code></li>
  <li><code class="language-plaintext highlighter-rouge">CharSequence</code></li>
  <li><code class="language-plaintext highlighter-rouge">Comparable[String]</code></li>
  <li><code class="language-plaintext highlighter-rouge">Object</code>/<code class="language-plaintext highlighter-rouge">AnyRef</code></li>
</ol>

<p>That seems like a lot of classes for one value. And they are genuine
classes of <code class="language-plaintext highlighter-rouge">greeting</code>, though 2-5 are all implied by #1.</p>

<p><code class="language-plaintext highlighter-rouge">greeting</code> also has all five of these <em>types</em>. We can ask the compiler
to verify that this <em>type</em> truth holds, entirely separately from the
class truth.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">greeting</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">greeting</span><span class="k">:</span> <span class="kt">java.io.Serializable</span><span class="o">,</span>
        <span class="n">greeting</span><span class="k">:</span> <span class="kt">CharSequence</span><span class="o">,</span> <span class="n">greeting</span><span class="k">:</span> <span class="kt">Comparable</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
        <span class="n">greeting</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">java.io.Serializable</span><span class="o">,</span> <span class="nc">CharSequence</span><span class="o">,</span>
       <span class="nc">Comparable</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="nc">AnyRef</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!)</span>
</code></pre></div></div>

<p>So we have exhausted the classes, but aren’t quite done with types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">greeting</span><span class="k">:</span> <span class="kt">greeting.type</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">greeting.</span><span class="k">type</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">greeting.type</code> is not like the other five types we just tested. It is
a strict subtype of <code class="language-plaintext highlighter-rouge">String</code>, and has no class with the same name.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// If and only if call compiles, A is a subtype of B.
</span><span class="k">def</span> <span class="nf">conformance</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span>, <span class="kt">String</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">String</span>,<span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Fine, we can accept that object identity is represented at the type
level without our universe imploding, by inventing the theory that
this is about object identity; hold on, though:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">salutation</span> <span class="k">=</span> <span class="n">greeting</span>
<span class="n">salutation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p>Fine, <code class="language-plaintext highlighter-rouge">salutation</code> is just another name for <code class="language-plaintext highlighter-rouge">greeting</code>, right?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">salutation.</span><span class="k">type</span>, <span class="kt">String</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span> <span class="kt">=:=</span> <span class="kt">salutation.</span><span class="k">type</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">greeting.</span><span class="k">type</span> <span class="o">=:=</span> <span class="nv">salutation</span><span class="o">.</span><span class="py">type</span><span class="o">.</span>
</code></pre></div></div>

<p>Now we have seven. I’ll spare you spelling out the induction: each new
variable defined like <code class="language-plaintext highlighter-rouge">salutation</code> will yield a new alias with a
distinct type. This is not about <em>objects</em>; this is about <em>variables</em>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// find a type for the literal "hi there!"
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">literalHiThere</span> <span class="k">=</span> <span class="nv">shapeless</span><span class="o">.</span><span class="py">Witness</span><span class="o">(</span><span class="s">"hi there!"</span><span class="o">)</span>
<span class="n">literalHiThere</span><span class="k">:</span> <span class="kt">shapeless.Witness.Aux</span><span class="o">[</span><span class="kt">String</span><span class="o">(</span><span class="err">"</span><span class="kt">hi</span> <span class="kt">there!</span><span class="err">"</span><span class="o">)]</span> <span class="k">=</span> <span class="nv">shapeless</span><span class="o">.</span><span class="py">Witness$$anon$1</span><span class="k">@</span><span class="mf">1d</span><span class="mi">1537</span><span class="n">bb</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span>, <span class="kt">literalHiThere.T</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span>,<span class="kt">literalHiThere.T</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">literalHiThere.T</span>, <span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">literalHiThere.T</span>,<span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>As local variables are a strictly compile-time abstraction, and we
have anyway seen that the numbers don’t match up, that should be the
end of the “types are classes” confusion for you. But maybe this is
just some Scala oddity! And anyhow I haven’t even begun to demonstrate
the overwhelming richness of the type model as it blindingly outshines
the paucity of the class model. Let’s go further.</p>

<h2 id="no-values-infinite-types-method-type-parameters">No values, infinite types: method type parameters</h2>

<p>To our small program of a greeting, we can add a small method.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pickGreeting</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">grt</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">pickGreeting</span><span class="o">(</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p>It seems like <code class="language-plaintext highlighter-rouge">G</code> must be <code class="language-plaintext highlighter-rouge">String</code>, because the argument passed to
<code class="language-plaintext highlighter-rouge">pickGreeting</code> is a string, and in that case so must its return value
be, according to the implementation. And from the perspective of this
call, <a href="/blog/2016/01/28/existential-inside.html">outside</a>
<code class="language-plaintext highlighter-rouge">pickGreeting</code>’s implementation, it is <code class="language-plaintext highlighter-rouge">String</code> indeed.</p>

<p>But that implementation’s perspective matters, too; it is also part of
our program. And it sees things quite differently. We can ask its
thoughts on the matter by adding to its body</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pickGreeting</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">String</span><span class="o">]</span>
  <span class="n">grt</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">G</span> <span class="o">=:=</span> <span class="nc">String</span><span class="o">.</span>
         <span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">String</span><span class="o">]</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>In fact, <code class="language-plaintext highlighter-rouge">G</code> bears no direct relationship to <code class="language-plaintext highlighter-rouge">String</code> at all.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// replace implicitly with
</span><span class="n">conformance</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">String</span><span class="o">]</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">G</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
         <span class="n">conformance</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">String</span><span class="o">]</span>
                    <span class="o">^</span>

<span class="c1">// or with
</span><span class="n">conformance</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">G</span><span class="o">]</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">String</span>,<span class="kt">G</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
         <span class="n">conformance</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">G</span><span class="o">]</span>
                    <span class="o">^</span>
</code></pre></div></div>

<p>Let’s apply the pigeonhole principle. Imagine that you had a list of
every class that ever was or ever will be. Imagine that, somehow, all
of these classes, from <code class="language-plaintext highlighter-rouge">String</code> to
<code class="language-plaintext highlighter-rouge">AbstractFactoryMethodProxyBuilder</code>, were on your classpath, available
to your program.</p>

<p>Next, imagine that you had the time and inclination to try the <code class="language-plaintext highlighter-rouge">=:=</code>
test with every last one of these classes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">javax.swing.JFrame</span><span class="o">]</span>
<span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">AbstractFactoryMethodProxyBuilder</span><span class="o">]</span>
<span class="c1">// ad [in]finitum
</span></code></pre></div></div>

<p>Your search will be futile; every class on your list-of-every-class
will give the same compiler error we got with <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p>So, since <code class="language-plaintext highlighter-rouge">G</code> is not equal to anything on this list, it must be
something else that doesn’t appear on the list. Because this list
contains all classes, <code class="language-plaintext highlighter-rouge">G</code> must be something other than a class.</p>

<h3 id="it-must-not-necessarily-be-anything">It must not necessarily be anything</h3>

<p>It seems like it might be convenient to say “well, in this program <code class="language-plaintext highlighter-rouge">G</code>
is only ever <code class="language-plaintext highlighter-rouge">String</code> by substitution, so therefore it is, even if the
compiler doesn’t see that.” However, thinking like this misses out on
the second key advantage of type parameterization, the one not based
on multiplicity of substitution, or the type-safety of callers:
blindness.</p>

<p>The implementation of type-parameterized classes and methods are
required to treat each type parameter uniquely, uniformly, and without
prejudice. The compiler enforces this by making the implementation
blind to what that parameter, like <code class="language-plaintext highlighter-rouge">G</code>, could be. It can only use what
the caller, the “outside”, has told it about <code class="language-plaintext highlighter-rouge">G</code>—arguments whose
types contain <code class="language-plaintext highlighter-rouge">G</code>, like <code class="language-plaintext highlighter-rouge">List[G]</code>, <code class="language-plaintext highlighter-rouge">(G, G) =&gt; G</code>, or <code class="language-plaintext highlighter-rouge">G</code> itself, like
the argument to <code class="language-plaintext highlighter-rouge">pickGreeting</code>. This
is
<a href="/blog/2016/03/13/information-hiding.html">information-hiding at the type level</a>;
if you find information-hiding a useful tool for implementing correct
programs, you will find the same of the fresh, unique, and mysterious
types induced by each introduction of a type parameter.</p>

<div class="side-note">
  Each operation a language permits by default, not via an argument,
  on values of a type parameter is a leak in this abstraction. This
  includes testing the value’s class, converting to string, and
  comparing to other values of supposedly utter mystery for
  equality. The ability to create a “default” value is also a leak. A
  function is always permitted to ask only that of these that it needs
  from the caller; make them default, and this design choice is taken
  away. That is why <code>Object#equals</code> is little better for
  type-safety than reflection-based calls, and why total type erasure
  is a desirable feature rather than a design flaw—plugging these
  leaks gives the programmer as much freedom to abstract by
  information-hiding as she wishes.
</div>

<h3 id="how-many-calls-are-there">How many calls are there?</h3>

<p>Put another way, when implementing the code in the scope of a type
parameter, your implementation must be equally valid <em>for all</em>
possible <code class="language-plaintext highlighter-rouge">G</code> substitutions, including the ones that haven’t been
invented yet. This is why we call it <em>universal</em> quantification.</p>

<p>But it is not merely each declaration of a type parameter that yields
a distinct type—each call does! Consider two consecutive calls to
<code class="language-plaintext highlighter-rouge">pickGreeting</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">pickGreeting</span><span class="o">(</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="nf">pickGreeting</span><span class="o">(</span><span class="mi">33</span><span class="o">,</span> <span class="mi">84</span><span class="o">)</span>
</code></pre></div></div>

<p>Externally, there are two <code class="language-plaintext highlighter-rouge">G</code> types. However, the possibility of
writing this demands another level of uniqueness treatment when
typechecking <code class="language-plaintext highlighter-rouge">pickGreeting</code>’s definition: whatever <code class="language-plaintext highlighter-rouge">G</code> is now, like
<code class="language-plaintext highlighter-rouge">String</code>, it might be something else in the next call, like <code class="language-plaintext highlighter-rouge">Int</code> in
the above example. With recursion, it might even be two different
things at the same time. There’s nothing to hold this at two, either:
there may be an unbounded number of substitutions for a given type
parameter within a single program, at a single point in time.</p>

<p>While <code class="language-plaintext highlighter-rouge">G</code> <em>may</em> be the same between two invocations of <code class="language-plaintext highlighter-rouge">pickGreeting</code>,
it might not. So we have no choice but to treat the <code class="language-plaintext highlighter-rouge">G</code> types of <em>each
call</em> as separate types. There may be infinitely many calls, so there
are so many types.</p>

<p>Incidentally, the same happens for singleton types. Each time <code class="language-plaintext highlighter-rouge">val
greeting</code> comes into scope, it induces a separate singleton type. It
is easy enough to arrange for an unbounded number of scope entries in
a particular program. This isn’t so practical as the type parameter
phenomenon, though.</p>

<h2 id="more-types-from-variable-copies">More types from variable copies</h2>

<p>Suppose we’d like to wait a while to compute our greeting. We can
define a type-and-class to represent that conveniently.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// like Coyoneda Id, if that helps
</span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Later</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">I</span>
  <span class="k">val</span> <span class="nv">i</span><span class="k">:</span> <span class="kt">I</span>
  <span class="k">val</span> <span class="nv">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">later</span><span class="o">[</span><span class="kt">In</span>, <span class="kt">A</span><span class="o">](</span><span class="n">now</span><span class="k">:</span> <span class="kt">In</span><span class="o">)(</span><span class="n">later</span><span class="k">:</span> <span class="kt">In</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span>
  <span class="k">:</span> <span class="kt">Later</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Later</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="nc">In</span>
    <span class="k">val</span> <span class="nv">i</span> <span class="k">=</span> <span class="n">now</span>
    <span class="k">val</span> <span class="nv">f</span> <span class="k">=</span> <span class="n">later</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">greeting3</span> <span class="k">=</span> <span class="nf">later</span><span class="o">(</span><span class="mi">3</span><span class="o">){</span>
  <span class="n">n</span> <span class="k">=&gt;</span> <span class="nv">List</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="n">n</span><span class="o">)(</span><span class="s">"hi"</span><span class="o">).</span><span class="py">mkString</span><span class="o">(</span><span class="s">" "</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>How many <em>classes</em> are involved here, in the type of <code class="language-plaintext highlighter-rouge">greeting3</code>?</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Later</code>, obviously;</li>
  <li><code class="language-plaintext highlighter-rouge">Function1</code>, the <code class="language-plaintext highlighter-rouge">greeting3.f</code> overall class;</li>
  <li><code class="language-plaintext highlighter-rouge">String</code>, the output type of <code class="language-plaintext highlighter-rouge">greeting3.f</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">Int</code>, the <code class="language-plaintext highlighter-rouge">I</code> type.</li>
</ol>

<p>How many types?</p>

<p>The first difference is that <code class="language-plaintext highlighter-rouge">greeting3.I</code> is not <code class="language-plaintext highlighter-rouge">Int</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting3.I</span> <span class="kt">=:=</span> <span class="kt">Int</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">greeting3.I</span> <span class="o">=:=</span> <span class="nc">Int</span><span class="o">.</span>
       <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting3.I</span> <span class="kt">=:=</span> <span class="kt">Int</span><span class="o">]</span>
                 <span class="o">^</span>
</code></pre></div></div>

<p>They are unrelated for much the same reason as <code class="language-plaintext highlighter-rouge">G</code> was unrelated to
<code class="language-plaintext highlighter-rouge">String</code> in the previous example: the only things code following
<code class="language-plaintext highlighter-rouge">val greeting3</code> may know are those embodied in the <code class="language-plaintext highlighter-rouge">greeting3.i</code> and
<code class="language-plaintext highlighter-rouge">greeting3.f</code> members. You can almost think of them as “arguments”.</p>

<p>But that’s not all.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">salut3</span> <span class="k">=</span> <span class="n">greeting3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">greeting3</span><span class="o">.</span><span class="py">f</span><span class="o">(</span><span class="nv">greeting3</span><span class="o">.</span><span class="py">i</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">hi</span> <span class="n">hi</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">salut3</span><span class="o">.</span><span class="py">f</span><span class="o">(</span><span class="nv">salut3</span><span class="o">.</span><span class="py">i</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">hi</span> <span class="n">hi</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">greeting3</span><span class="o">.</span><span class="py">f</span><span class="o">(</span><span class="nv">salut3</span><span class="o">.</span><span class="py">i</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">salut3.i.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">salut3.I</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">greeting3.I</span>
       <span class="nv">greeting3</span><span class="o">.</span><span class="py">f</span><span class="o">(</span><span class="nv">salut3</span><span class="o">.</span><span class="py">i</span><span class="o">)</span>
                          <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting3.I</span> <span class="kt">=:=</span> <span class="kt">salut3.I</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">greeting3.I</span> <span class="o">=:=</span> <span class="nv">salut3</span><span class="o">.</span><span class="py">I</span><span class="o">.</span>
</code></pre></div></div>

<p>Just like every call to <code class="language-plaintext highlighter-rouge">pickGreeting</code> induces a new <code class="language-plaintext highlighter-rouge">G</code> type, each
simple <code class="language-plaintext highlighter-rouge">val</code> copy of <code class="language-plaintext highlighter-rouge">greeting3</code> will induce a new, unique <code class="language-plaintext highlighter-rouge">I</code>
type. It doesn’t matter that they’re all the same value; this is a
matter of variables, not values, just as with singleton types.</p>

<p>But that’s <em>still</em> not all.</p>

<h2 id="one-value-with-class-many-variable-references-with-types">One value with class, many variable <em>references</em> with types</h2>

<p>The preceding is more delicate than it seems.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">allo</span> <span class="k">=</span> <span class="n">greeting3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">allo</span><span class="o">.</span><span class="py">f</span><span class="o">(</span><span class="nv">allo</span><span class="o">.</span><span class="py">i</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Later</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">#</span><span class="n">I</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.I</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">Later</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
       <span class="nv">allo</span><span class="o">.</span><span class="py">f</span><span class="o">(</span><span class="nv">allo</span><span class="o">.</span><span class="py">i</span><span class="o">)</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>All we have done differently is use a mutable <code class="language-plaintext highlighter-rouge">var</code> instead of an
immutable <code class="language-plaintext highlighter-rouge">val</code>. Why is this enough to throw a wrench in the works?</p>

<p>Suppose you had another <em>value</em> of the <code class="language-plaintext highlighter-rouge">Later[String]</code> type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">bhello</span> <span class="k">=</span> <span class="nf">later</span><span class="o">(</span><span class="s">"olleh"</span><span class="o">)(</span><span class="nv">_</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">I</code> substitution here is <code class="language-plaintext highlighter-rouge">String</code>. So the <code class="language-plaintext highlighter-rouge">f</code> takes a <code class="language-plaintext highlighter-rouge">String</code>
argument, and the <code class="language-plaintext highlighter-rouge">I</code> is a <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p><code class="language-plaintext highlighter-rouge">bhello</code> is of a compatible type with the <code class="language-plaintext highlighter-rouge">allo</code> var. So this
assignment will work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allo</span> <span class="k">=</span> <span class="n">bhello</span>
</code></pre></div></div>

<p>In a sense, when this mutation occurs, the <code class="language-plaintext highlighter-rouge">I</code> type <em>also</em> mutates,
from <code class="language-plaintext highlighter-rouge">Int</code> to <code class="language-plaintext highlighter-rouge">String</code>. But that isn’t quite right; types cannot
mutate.</p>

<p>Suppose that this assignment happened in the middle of that line of
code that could not compile. We could imagine the sequence of events,
were it permitted.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">allo.f</code> (which is <code class="language-plaintext highlighter-rouge">greeting3.f</code>) evaluates. It is the function
<code class="language-plaintext highlighter-rouge">(n: Int) =&gt; List.fill(n)("hi").mkString(" ")</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">allo = bhello</code> assignment occurs.</li>
  <li><code class="language-plaintext highlighter-rouge">allo.i</code> (which is <code class="language-plaintext highlighter-rouge">bhello.i</code>) evaluates. It is the string
<code class="language-plaintext highlighter-rouge">"olleh"</code>.</li>
  <li>We attempt to pass <code class="language-plaintext highlighter-rouge">"olleh"</code> as the <code class="language-plaintext highlighter-rouge">(n: Int)</code> argument to complete
the evaluation, and get stuck.</li>
</ol>

<p>Just as it makes no difference what concrete substitutions you make
for <code class="language-plaintext highlighter-rouge">G</code>, it makes no difference whether such an assignment could ever
happen in your specific program; the compiler takes it as a
possibility because you declared a <code class="language-plaintext highlighter-rouge">var</code>. (<code class="language-plaintext highlighter-rouge">def allo = greeting3</code> gets
the same treatment, lest you think non-functional programs get to have
all the fun here.) Each <em>reference</em> to <code class="language-plaintext highlighter-rouge">allo</code> gets a new <code class="language-plaintext highlighter-rouge">I</code> type
member. That failing line of code had two <code class="language-plaintext highlighter-rouge">allo</code> references, so was
working with two incompatible <code class="language-plaintext highlighter-rouge">I</code> types.</p>

<p>Since the number of references to a variable in a program is also
unbounded…you get the picture.</p>

<div class="side-note">
  This also occurs with existential type parameters, which are equally
  expressive to type members. Accordingly, Java <em>also</em>
  generates new types from occurrences of expressions of existential
  type.
</div>

<h2 id="how-do-we-tell-the-two-apart">How do we tell the two apart?</h2>

<p>All of this is simply to say that we must be working with two separate
concepts here.</p>

<ol>
  <li>The <em>runtime</em> shape and properties of the <em>values</em> that end up
flying around when a program actually <em>runs</em>. <strong>This we call
class.</strong></li>
  <li>The <em>compile-time</em>, statically-discoverable shape and properties of
the <em>expressions</em> that fly around when a program is
<em>written</em>. <strong>This we call type.</strong></li>
</ol>

<p>The case with <code class="language-plaintext highlighter-rouge">var</code> is revealing. Maybe the <code class="language-plaintext highlighter-rouge">I</code> type will always be
the same for a given mutable variable. But demonstrating that this
holds true for <em>one</em> run of the program (#1, class) isn’t nearly good
enough to <em>prove</em> that it will be true for <em>all</em> runs of the program
(#2, type).</p>

<p>We refuse to apply the term “type” to the #1, ‘class’ concept because
it does not live up to the name. The statement “these two types are
the same” is another level of power entirely; “these two values have
the same class” is extraordinarily weak by comparison.</p>

<p>It is tempting to use the term “runtime type” to refer to
classes. However, in the case of Scala, as with all type systems
featuring parametric polymorphism, classes are so dissimilar to types
that the similar-sounding term leads to false intuition, not helpful
analogy. It is a detriment to learning, not an aid.</p>

<p>Types are compile-time, and classes are runtime.</p>

<h3 id="when-are-types-real">When are types real?</h3>

<p>The phase separation—compile-time versus runtime—is the key to
the strength of types in Scala and similar type systems. The static
nature of types means that the truths they represent must be
universally quantified—true in all possible cases, not just some
test cases.</p>

<p>We need this strength because the phase separation forbids us from
taking into account anything that cannot be known about the program
without running it. We need to think in terms of “could happen”, not
“pretty sure it doesn’t”.</p>

<h2 id="how-do-classes-give-rise-to-types">How do classes give rise to types?</h2>

<p>There appears to be some overlap between the classes of <code class="language-plaintext highlighter-rouge">greeting</code> and
its types. While <code class="language-plaintext highlighter-rouge">greeting</code> has the <em>class</em> <code class="language-plaintext highlighter-rouge">String</code>, it also has the
<em>type</em> <code class="language-plaintext highlighter-rouge">String</code>.</p>

<p>We want types to represent static truths about the expressions in a
program. That’s why it makes sense to include a “model of the classes”
in the type system. When we define a class, we also define an
associated type or family of types.</p>

<p>When we use a class to construct a value, as in <code class="language-plaintext highlighter-rouge">new Blob</code>, we would
like to assign as much specific meaning to that expression as we can
at compile time. So, because we know right now that this expression
will make a value of class <code class="language-plaintext highlighter-rouge">Blob</code>, we assign it the type <code class="language-plaintext highlighter-rouge">Blob</code> too.</p>

<h3 id="how-do-the-types-disappear">How do the types disappear?</h3>

<p>There’s a common way to throw away type information in Scala,
especially popular in object-oriented style.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">absGreeting</span><span class="k">:</span> <span class="kt">CharSequence</span> <span class="o">=</span> <span class="n">greeting</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">absGreeting</code> has the same value as <code class="language-plaintext highlighter-rouge">greeting</code>, so it has the same
five classes. However, it only has two of those five types, because we
threw away the other three statically. It has lost some other types,
too, namely <code class="language-plaintext highlighter-rouge">greeting.type</code>, and acquired some new ones, namely
<code class="language-plaintext highlighter-rouge">absGreeting.type</code>.</p>

<p>Once a value is constructed, the expression will naturally cast off
the types specifying its precise identity, as it moves into more
abstract contexts. Ironically, the best way to preserve that
information as it passes through abstract contexts is to take
advantage of purely abstract types—type parameters and type
members.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">pickGreeting</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span><span class="o">](</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">greeting.</span><span class="k">type</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p>While the implementation must treat its argument as being of the
abstract type <code class="language-plaintext highlighter-rouge">G</code>, the caller knows that the more specific
<code class="language-plaintext highlighter-rouge">greeting.type</code> must come out of that process.</p>

<h3 id="how-do-the-types-come-back">How do the types come back?</h3>

<p>There is a feature in Scala that lets you use class to get back <em>some</em>
type information via a dynamic, runtime test.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">absGreeting</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">hiAgain</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
    <span class="n">conformance</span><span class="o">[</span><span class="kt">hiAgain.</span><span class="k">type</span>, <span class="kt">String</span><span class="o">]</span> <span class="c1">// will compile
</span><span class="o">}</span>
</code></pre></div></div>

<p>The name “type test” for this feature is poorly chosen. The
<em>conclusion</em> affects the type level—<code class="language-plaintext highlighter-rouge">hiAgain</code> is, indeed, proven
statically to be of type <code class="language-plaintext highlighter-rouge">String</code>—but the <em>test</em> occurs only at
the class level.</p>

<p>The compiler will tell you about this limitation sometimes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pickGreeting2</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span>
  <span class="o">(</span><span class="s">"magic"</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ok</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=&gt;</span> <span class="n">ok</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span> <span class="n">error</span> <span class="s">"failed!"</span>
  <span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">abstract</span> <span class="k">type</span> <span class="kt">pattern</span> <span class="kt">G</span> <span class="kt">is</span> <span class="kt">unchecked</span>
              <span class="n">since</span> <span class="n">it</span> <span class="n">is</span> <span class="n">eliminated</span> <span class="n">by</span> <span class="n">erasure</span>
           <span class="k">case</span> <span class="n">ok</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=&gt;</span> <span class="n">ok</span>
                    <span class="o">^</span>
</code></pre></div></div>

<p>But reflecting the runtime classes back to compile-time types is a
subtle art, and the compiler often can’t explain exactly what you got
wrong.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pickGreeting3</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span>
  <span class="n">grt</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
      <span class="s">"Surely type G is String, right?"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">grt</span>
  <span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span><span class="o">(</span><span class="err">"</span><span class="kt">Surely</span> <span class="k">type</span> <span class="kt">G</span> <span class="kt">is</span> <span class="kt">String</span><span class="o">,</span> <span class="kt">right?</span><span class="err">"</span><span class="o">)</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">G</span>
             <span class="s">"Surely type G is String, right?"</span>
             <span class="o">^</span>
</code></pre></div></div>

<p>I’ve touched upon this
mistake
<a href="/blog/2014/07/06/singleton_instance_trick_unsafe.html#types-are-erased">in previous articles</a>,
but it’s worth taking at least one more look. Let’s examine how
tempting this mistake is.</p>

<p><code class="language-plaintext highlighter-rouge">String</code> is a <code class="language-plaintext highlighter-rouge">final class</code>. So it is true that <code class="language-plaintext highlighter-rouge">G</code> can contain no
more specific class than <code class="language-plaintext highlighter-rouge">String</code>, if the first <code class="language-plaintext highlighter-rouge">case</code> matches. For
example, given <code class="language-plaintext highlighter-rouge">trait MyAwesomeMixin</code>, <code class="language-plaintext highlighter-rouge">G</code> cannot be
<code class="language-plaintext highlighter-rouge">String with MyAwesomeMixin</code> if this <code class="language-plaintext highlighter-rouge">case</code> succeeds, because that
can’t be instantiated; you would need to create a subclass of <code class="language-plaintext highlighter-rouge">String</code>
that implemented <code class="language-plaintext highlighter-rouge">MyAwesomeMixin</code>.</p>

<p>This pattern match isn’t enough evidence to say that <code class="language-plaintext highlighter-rouge">G</code> is exactly
<code class="language-plaintext highlighter-rouge">String</code>. There are still other class-based types it could be, like
<code class="language-plaintext highlighter-rouge">Serializable</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pickGreeting3</span><span class="o">[</span><span class="kt">java.io.Serializable</span><span class="o">](</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">4055</span><span class="o">)</span>
</code></pre></div></div>

<p>Instead, it feels like this pattern match confirms <code class="language-plaintext highlighter-rouge">Serializable</code> as a
possibility, instead of denying it.</p>

<p>But we don’t need <code class="language-plaintext highlighter-rouge">G = String</code> for this code to compile; we only need
<code class="language-plaintext highlighter-rouge">G &gt;: String</code>. If that was true, then <code class="language-plaintext highlighter-rouge">"Surely type G is String,
right?"</code>, a <code class="language-plaintext highlighter-rouge">String</code>, could simply upcast to <code class="language-plaintext highlighter-rouge">G</code>.</p>

<p>However, even <code class="language-plaintext highlighter-rouge">G &gt;: String</code> is unproven. There are no subclasses of
<code class="language-plaintext highlighter-rouge">String</code>, but there are infinitely many <em>subtypes</em> of
<code class="language-plaintext highlighter-rouge">String</code>. Including the <code class="language-plaintext highlighter-rouge">G</code> created by each entry into
<code class="language-plaintext highlighter-rouge">pickGreeting3</code>, every abstract and existential type bounded by
<code class="language-plaintext highlighter-rouge">String</code>, and every singleton type of <code class="language-plaintext highlighter-rouge">String</code> variable definitions.</p>

<p>This mistake is, once again, confusing a demonstration of one case
with a proof. Pattern matching tells us a great deal about one value,
the <code class="language-plaintext highlighter-rouge">grt</code> argument, but very little about the type <code class="language-plaintext highlighter-rouge">G</code>. All we know
for sure is that “<code class="language-plaintext highlighter-rouge">grt</code> is of type <code class="language-plaintext highlighter-rouge">G</code>, and also of type <code class="language-plaintext highlighter-rouge">String</code>, so
these types overlap by at least one value.” In the type system, if you
don’t know something for sure, you don’t know it at all.</p>

<h2 id="classes-are-a-concrete-source-of-values">Classes are a concrete source of values</h2>

<p>In the parlance of functional Scala, concrete classes are often called
“data constructors”.</p>

<p>When you are creating a value, you must ultimately be concrete about
its class, at the bottom of all the abstractions and indirections used
to hide this potentially messy detail.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="nf">pickGreeting4</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">G</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="k">type</span> <span class="kt">required</span> <span class="kt">but</span> <span class="kt">G</span> <span class="kt">found</span>
       <span class="k">def</span> <span class="nf">pickGreeting4</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">G</span>
                                     <span class="o">^</span>
</code></pre></div></div>

<p>You’ll have to do something else here, like take an argument
<code class="language-plaintext highlighter-rouge">() =&gt; G</code>, to let <code class="language-plaintext highlighter-rouge">pickGreeting4</code> construct <code class="language-plaintext highlighter-rouge">G</code>s.</p>

<p>The truly essential role that classes play is that they encapsulate
instructions for constructing concrete values of various types. In a
safe program, this is the only feature of classes you’ll use.</p>

<p>In Scala, classes leave fingerprints on the values that they
construct, without fail. This is merely an auxiliary part of their
primary function as value factories, like a “Made in <code class="language-plaintext highlighter-rouge">class Blah</code>”
sticker on the back. Pattern matching’s “type tests” work by checking
this fingerprint of construction.</p>

<h2 id="most-runtime-type-test-mechanisms-do-not-work-for-types">Most runtime “type test” mechanisms do not work for types</h2>

<p>These fingerprints only come from classes, not types. So “type tests”
only work for “classy” types, like <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">MyAwesomeMixin</code>. They
also work for specific singleton types because construction also
leaves an “object identity” fingerprint that the test can use.</p>

<p>The
<a href="http://www.scala-lang.org/api/2.12.1/scala/reflect/ClassTag.html"><code class="language-plaintext highlighter-rouge">ClassTag</code> typeclass</a> does
not change this restriction. When you add a <code class="language-plaintext highlighter-rouge">ClassTag</code> or <code class="language-plaintext highlighter-rouge">TypeTag</code>
context bound, you also prevent that type parameter from working with
most types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">reflect.ClassTag</span><span class="o">[</span><span class="kt">greeting3.I</span><span class="o">]]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">ClassTag</span> <span class="kt">available</span> <span class="kt">for</span> <span class="kt">greeting3.I</span>
       <span class="n">implicitly</span><span class="o">[</span><span class="kt">reflect.ClassTag</span><span class="o">[</span><span class="kt">greeting3.I</span><span class="o">]]</span>
                 <span class="o">^</span>
</code></pre></div></div>

<p>As such, judicious use of <code class="language-plaintext highlighter-rouge">ClassTag</code> is not a great solution to
excessive use of type tests in abstract contexts. There are so many
more types than classes that this is to confine the expressivity of
your types to a very small, class-reflective box. Set them free!</p>

<h2 id="but-doesnt-pythonjavascriptc-have-both-types-and-classes-at-runtime">“But doesn’t Python/JavaScript/&amp;c have both types and classes at runtime?”</h2>

<p>In JavaScript, there’s a very general runtime classification of values
called “type”, meant to classify built-in categories like <code class="language-plaintext highlighter-rouge">string</code>,
<code class="language-plaintext highlighter-rouge">number</code>, and the like.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="dl">"</span><span class="s2">hi</span><span class="dl">"</span>
<span class="dl">"</span><span class="s2">string</span><span class="dl">"</span>
<span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="mi">42</span>
<span class="dl">"</span><span class="s2">number</span><span class="dl">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">typeof</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">]</span>
<span class="dl">"</span><span class="s2">object</span><span class="dl">"</span>
</code></pre></div></div>

<p>Defining a class with the new <code class="language-plaintext highlighter-rouge">class</code> keyword doesn’t extend this
partition with new “types”; instead, it further subdivides <em>one</em> of
those with a separate classification.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="kd">class</span> <span class="nx">Foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="o">&gt;&gt;</span> <span class="kd">class</span> <span class="nx">Bar</span><span class="p">()</span> <span class="p">{}</span>
<span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Foo</span><span class="p">)</span>
<span class="dl">"</span><span class="s2">object</span><span class="dl">"</span>
<span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Bar</span><span class="p">)</span>
<span class="dl">"</span><span class="s2">object</span><span class="dl">"</span>
<span class="o">&gt;&gt;</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">().</span><span class="kd">constructor</span>
<span class="kd">function</span> <span class="nx">Foo</span><span class="p">()</span>
<span class="o">&gt;&gt;</span> <span class="k">new</span> <span class="nx">Bar</span><span class="p">().</span><span class="kd">constructor</span>
<span class="kd">function</span> <span class="nx">Bar</span><span class="p">()</span>
</code></pre></div></div>

<p>So, if you treat JavaScript’s definition of the word “type” as
analogous to the usage in this article, then yes, JavaScript has
“runtime types”.</p>

<p>But JavaScript can only conveniently get away with this because its
static types are uninteresting. It has one type—the type of all
values—and no opportunities to do interesting type-level modeling,
at least not as part of the standard language.</p>

<p>Hence, JavaScript is free to repurpose the word “type” for a flavor of
its classes, because our “types” aren’t a tool you make much use of in
JavaScript. But when you come back to Scala, Haskell, the ML family,
et al, you need a word for the static concept once again.</p>

<h2 id="thinking-about-types-as-just-classes-leads-to-incorrect-conclusions">Thinking about types as <em>just</em> classes leads to incorrect conclusions</h2>

<p>Setting aside the goal of principled definition of terms, this
separation is the one that makes the most sense for a practitioner of
Scala. Consider the practicalities:</p>

<p>Types and classes have different behavior, are equal and unequal
according to different rules, and there are a lot more types than
classes. So we need different words to distinguish them.</p>

<p>Saying “compile-time type” or “runtime type” is not a practical
solution—no one wants to speak such an unwieldy qualifier every
time they refer to such a commonly-used concept.</p>

<p>While I’ve given a sampling of the richness of the type system in this
article, it’s not necessary to know that full richness to appreciate
or remember the difference between the two: types are static and
compile-time; classes are dynamic and runtime.</p>

<p><em>This article was tested with Scala 2.12.1, Shapeless 2.3.2, and
Firefox 53.0a2.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2017/02/13/more-types-than-classes.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/02/13/more-types-than-classes.html</guid>
      </item>
    
      <item>
        <title>Endorsing the new Scala Code of Conduct</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>A couple of days ago, the new <a href="https://contributors.scala-lang.org/t/please-read-scala-code-of-conduct/28">Scala Code of Conduct</a> was published.
It applies to all official Scala channels, including mailing lists, Gitter channels and GitHub repositories.
We would like to take this opportunity to endorse this new Code of Conduct.
From our perspective, it does a good job of listing encouraged behaviour, instead of just banning harassment: It reflects the goal of <em>actively</em> creating a welcoming community.
Also, we consider it to be a decent substitute of our own <a href="/conduct.html">Code of Conduct</a>.
That means that Typelevel project maintainers are free to switch to the Scala Code of Conduct if they wish.</p>

<p>For some more background, please see the <a href="https://github.com/typelevel/general/issues/51">discussion on GitHub</a>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 17 Dec 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/12/17/scala-coc.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/12/17/scala-coc.html</guid>
      </item>
    
      <item>
        <title>API Design for Heaps (aka Priority Queues)</title>
        
          <dc:creator>chrisokasaki</dc:creator>
                
        <description><![CDATA[<p><em>This is a guest post by Chris Okasaki. It was initially published as the <a href="https://github.com/chrisokasaki/scads/blob/e78233ac6a787b7c66b44cd6139392418b214eb9/design/heaps.md">design document</a> behind <a href="https://github.com/chrisokasaki/scads">scads</a>. It is being republished here with the permission of the original author.</em></p>

<p>A heap (or priority queue) is a collection of elements ordered by some <code class="language-plaintext highlighter-rouge">Ordering</code>, optimized for retrieving the first element according to that ordering.
Duplicate elements are allowed.
Applications vary in whether they need the first element to be the smallest or the biggest element according to the ordering, so both variations should be easy to use.
(However, any given heap is expected to offer easy access to either the smallest element only or the biggest element only, not both at the same time.)
I will consider immutable heaps in this document, but the core issues discussed below apply to both immutable heaps and mutable heaps.</p>

<p>Even if an element type has a natural ordering, that ordering may not be the one we want to use, so we must allow the user to specify the ordering.</p>

<h2 id="problem-1-dont-mix-two-different-orderings-in-the-same-heap">Problem 1: Don’t mix two different orderings in the same heap</h2>

<p>Here is a strawman design for a very simple heap API:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>  <span class="c1">// WARNING: THIS IS BROKEN!!!
</span>  <span class="k">def</span> <span class="nf">isEmpty</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">first</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="nf">rest</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// factory method, probably in some companion object
</span><span class="k">def</span> <span class="nf">empty</span><span class="o">[</span><span class="kt">Elem</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>You may think it strange that all of these methods are taking an <code class="language-plaintext highlighter-rouge">ord</code> parameter.
From a Scala point of view, that doesn’t make much sense.
But you can find variations of this design in many implementations of heaps on GitHub, including in the well-respected Scalaz library.
Why? As far as I can tell, the answer is <em>because Haskell does it that way</em>.
Here’s the equivalent design in Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Heap</span> <span class="n">a</span>
<span class="n">empty</span>   <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span>
<span class="n">isEmpty</span> <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">add</span>     <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Heap</span> <span class="n">a</span>
<span class="n">first</span>   <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">rest</span>    <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Heap</span> <span class="n">a</span>
</code></pre></div></div>

<p>In Haskell, this makes perfect sense.
Behind the scenes, each method takes an <code class="language-plaintext highlighter-rouge">Ord</code> dictionary as a hidden parameter.
But there’s one critical difference between Haskell and Scala: in Haskell, there can only be a <em>single</em> ordering for an element type, but in Scala, there can be <em>many</em> orderings for the same element type.</p>

<p>For example, consider this Scala code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ord1</span> <span class="k">=</span> <span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span>
<span class="k">val</span> <span class="nv">ord2</span> <span class="k">=</span> <span class="nv">ord1</span><span class="o">.</span><span class="py">reverse</span>
<span class="k">val</span> <span class="nv">heap1</span> <span class="k">=</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">ord1</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="n">ord1</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)(</span><span class="n">ord1</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">heap2</span> <span class="k">=</span> <span class="nv">heap1</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)(</span><span class="n">ord2</span><span class="o">)</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">heap2</span><span class="o">.</span><span class="py">first</span><span class="o">)</span>
</code></pre></div></div>

<p>What should this print?
Of course, that depends on the details of the implementation, but you would expect it to print either 4 (the smallest element) or 7 (the biggest element).
However, because one ordering was used for two of the <code class="language-plaintext highlighter-rouge">add</code>s and the opposite ordering was used for the third <code class="language-plaintext highlighter-rouge">add</code>, there’s an excellent chance that the actual result will be 5, which is the wrong answer for both orderings.</p>

<p>The magic of implicit parameters is that you usually don’t need to pass them explicitly.
But (A) there’s nothing to stop you from doing so, and (B) there’s nothing to prevent you from calling methods in different scopes with different orderings.
No, if you’re anything like me, the possibility that this could happen by accident is making your skin crawl.
Surely, the API should prevent this from happening!</p>

<p>Fortunately, this problem is very easy to fix.
<em>Only the <code class="language-plaintext highlighter-rouge">empty</code> method should take an ordering.</em>
Once that initial heap has been created, all future heaps derived from that heap via any sequence of <code class="language-plaintext highlighter-rouge">add</code>s or <code class="language-plaintext highlighter-rouge">rest</code>s should use the same ordering.
With this change, the API becomes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">first</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="nf">rest</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// factory method, probably in some companion object
</span><span class="k">def</span> <span class="nf">empty</span><span class="o">[</span><span class="kt">Elem</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Yay! That is both simpler and safer.</p>

<h2 id="problem-2-merge">Problem 2: <code class="language-plaintext highlighter-rouge">merge</code></h2>

<p>Another operation supported by many kinds of heaps is <code class="language-plaintext highlighter-rouge">merge</code>, which combines two heaps into a single heap.
Examples of heaps supporting merge include leftist heaps, skew heaps, binomial heaps (aka binomial queues), Fibonacci heaps, etc.</p>

<p>We can easily add <code class="language-plaintext highlighter-rouge">merge</code> to the existing <code class="language-plaintext highlighter-rouge">Heap[Elem]</code> trait.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>However, there are at last two problems with this.
First, traits allow for subclassing, so we might have several different implementations, such as leftist heaps and binomial heaps.
But we only want to merge leftist heaps with leftist heaps and binomial heaps with binomial heaps—we do <em>not</em> want to merge leftist heaps with binomial heaps.</p>

<p>There are several ways to address this problem.
For example, leftist heaps and binomial heaps could just use completely separate trait hierarchies, and each could use a <code class="language-plaintext highlighter-rouge">sealed trait</code> to prevent this unwanted mixing of types.</p>

<p>But the code duplication this would entail is unsatisfying.
It would also make it more difficult to share code (such as a testing harness) between different implementations.</p>

<p>Alternatively, we can control the types more precisely by adding a second type parameter for the specific representation being used, as in:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Heap</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// MHeap is "Mergeable Heap"
</span>  <span class="c1">// Heap is the specific Heap representation being used
</span>  <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="k">def</span> <span class="nf">first</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="nf">rest</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span>
<span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LeftistHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">LeftistHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]]</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">BinomialHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">BinomialHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]]</span>
</code></pre></div></div>

<p>Because of the extra type parameter, a leftist heap and binomial heap are incompatible and cannot be merged.</p>

<h2 id="problem-3-merge-continued">Problem 3: <code class="language-plaintext highlighter-rouge">merge</code> (continued)</h2>

<p>There’s a second problem with <code class="language-plaintext highlighter-rouge">merge</code>.  A particular implementation, such as leftist heaps, would provide a factory method for creating a new heap.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">LeftistHeap</span> <span class="o">{</span> <span class="c1">// companion object
</span>  <span class="k">def</span> <span class="nf">empty</span><span class="o">[</span><span class="kt">Elem</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeftistHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Because of the <code class="language-plaintext highlighter-rouge">MHeap</code> definition, we can’t <code class="language-plaintext highlighter-rouge">merge</code> a leftist heap with a binomial heap.
But now we’ve re-introduced the problem of incompatible orderings!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ord1</span> <span class="k">=</span> <span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span>
<span class="k">val</span> <span class="nv">ord2</span> <span class="k">=</span> <span class="nv">ord1</span><span class="o">.</span><span class="py">reverse</span>
<span class="k">val</span> <span class="nv">heap1</span> <span class="k">=</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">ord1</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">heap2</span> <span class="k">=</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">ord2</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="k">var</span> <span class="n">heap3</span> <span class="k">=</span> <span class="nv">heap1</span><span class="o">.</span><span class="py">merge</span><span class="o">(</span><span class="n">heap2</span><span class="o">)</span>
<span class="nf">while</span> <span class="o">(!</span><span class="nv">heap3</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="nv">heap3</span><span class="o">.</span><span class="py">first</span><span class="o">)</span>
  <span class="n">heap3</span> <span class="k">=</span> <span class="nv">heap3</span><span class="o">.</span><span class="py">rest</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Notice that <code class="language-plaintext highlighter-rouge">heap1</code> and <code class="language-plaintext highlighter-rouge">heap2</code> were created with opposite orderings.
What happens if we merge them? Nothing good!
The exact results depend on details of the implementation, but a likely result is that loop will print the elements in the order 5,6,4,7—or maybe 5,7,6,4—when it <em>should</em> print them in sorted order!</p>

<p>We would really like to make this sort of situation impossible!
Maybe we could test the orderings for object equality at runtime, and throw an exception if they’re different?
That could actually work for simple types like integers with a built-in ordering object.
But for more complicated types, such as tuples, the orderings are generated on demand from the orderings of their constituent parts.
And this generation is not memoized, so if we demand an ordering for, say, <code class="language-plaintext highlighter-rouge">(Int,String)</code> twice, we’ll get two separate ordering objects, which will cause a false negative for our hypothetical dynamic equality check.</p>

<p>No, we would really like to make merging two heaps with different orderings a type error.
We can achieve this by making the notion of a factory explicit.
The idea is that heaps can only be merged with other heaps from the same factory.
Attempting to merge heaps from different factories will cause a type error.</p>

<p>In code, we might express this as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">HeapFactory</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Elem</span>
  <span class="k">type</span> <span class="kt">Heap</span> <span class="k">&lt;:</span> <span class="kt">MHeap</span><span class="o">[</span><span class="kt">Elem</span>,<span class="kt">Heap</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="c1">// plus other factory methods
</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">LeftistHeap</span> <span class="o">{</span> <span class="c1">// companion object
</span>  <span class="k">def</span> <span class="nf">factory</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">HeapFactory</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="kt">E</span> <span class="o">}</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can say:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">minHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">maxHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">heap1</span> <span class="k">=</span> <span class="nv">minHeaps</span><span class="o">.</span><span class="py">empty</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">heap2</span> <span class="k">=</span> <span class="nv">minHeaps</span><span class="o">.</span><span class="py">empty</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">heap3</span> <span class="k">=</span> <span class="nv">heap1</span><span class="o">.</span><span class="py">merge</span><span class="o">(</span><span class="n">heap2</span><span class="o">)</span> <span class="c1">// this typechecks
</span>
<span class="k">val</span> <span class="nv">heap4</span> <span class="k">=</span> <span class="nv">maxHeaps</span><span class="o">.</span><span class="py">empty</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="py">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">heap5</span> <span class="k">=</span> <span class="nv">heap1</span><span class="o">.</span><span class="py">merge</span><span class="o">(</span><span class="n">heap4</span><span class="o">)</span> <span class="c1">// !!!type error!!!
</span></code></pre></div></div>

<p>Notice that <code class="language-plaintext highlighter-rouge">heap1</code>, <code class="language-plaintext highlighter-rouge">heap2</code>, and <code class="language-plaintext highlighter-rouge">heap3</code> have type <code class="language-plaintext highlighter-rouge">minHeaps.Heap</code> but <code class="language-plaintext highlighter-rouge">heap4</code> has type <code class="language-plaintext highlighter-rouge">maxHeaps.Heap</code>.
According to Scala’s notion of <em>path-dependent types</em>, these types are incompatible so attempting to merge <code class="language-plaintext highlighter-rouge">heap1</code> and <code class="language-plaintext highlighter-rouge">heap4</code> causes a type error, as desired.</p>

<h2 id="a-question">A question</h2>

<p>Clearly, if I create two factories with incompatible element types, then a heap from one factory should not be mergeable with a heap from the other factory.
Similarly, if I create two factories with the same element type but incompatible orderings, then again a heap from one factory should not be mergeable with a heap from the other factory.</p>

<p>But what if I create two separate factories with the same element type and the same ordering?
Should a heap created from one of these factories be mergeable with a heap created from the other factory?
It’s not clear.
If this duplication of factories was deliberate, then the answer is probably “no”.
This often happens with units of measure.
For example, maybe one of the factories is using integers to represent inches and the other is using integers to represent grams.
Even if the factories are using the same ordering, we probably don’t want to merge a heap of inches with a heap of grams!</p>

<p>On the other hand, the duplication of factories could be accidental, perhaps the result of two chunks of code being written separately and then brought together later.
In that case, we might very well want to be able to merge a heap from one factory with a heap from another accidentally-separate-but-equivalent factory.</p>

<p>Regardless of where you come down on what <em>should</em> happen, what <em>will</em> happen in the above design is that attempting to merge heaps from distinct factories will cause a type error, even if the factories were made for the same element type and ordering.</p>

<h2 id="problem-4-usability-in-the-simple-case">Problem 4: Usability in the simple case</h2>

<p>Most applications of priority queues do not need the <code class="language-plaintext highlighter-rouge">merge</code> method.
Trying to make <code class="language-plaintext highlighter-rouge">merge</code> typesafe has made the API more complicated and harder to use because of the need to instantiate a factory before creating actual heaps.
Can we hide these complications from a user until and unless they actually need to use <code class="language-plaintext highlighter-rouge">merge</code>? Yes.</p>

<p>I’ll re-introduce the interface without <code class="language-plaintext highlighter-rouge">merge</code>, but now called <code class="language-plaintext highlighter-rouge">SHeap</code> for “Simple Heap”:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">first</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="nf">rest</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then <code class="language-plaintext highlighter-rouge">MHeap</code> should be a subtype of <code class="language-plaintext highlighter-rouge">SHeap</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Heap</span> <span class="k">&lt;:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// inherits isEmpty and first from SHeap[Elem]
</span>  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span> <span class="c1">// more specific return type
</span>  <span class="k">def</span> <span class="nf">rest</span><span class="k">:</span> <span class="kt">Heap</span> <span class="c1">// more specific return type
</span>  <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">HeapFactory</code> definition is unchanged:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">HeapFactory</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Elem</span>
  <span class="k">type</span> <span class="kt">Heap</span> <span class="k">&lt;:</span> <span class="kt">MHeap</span><span class="o">[</span><span class="kt">Elem</span>,<span class="kt">Heap</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="c1">// plus other factory methods
</span><span class="o">}</span>
</code></pre></div></div>

<p>The last part is that the companion object should supply simple factory methods in terms of <code class="language-plaintext highlighter-rouge">SHeap</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">LeftistHeap</span> <span class="o">{</span> <span class="c1">// companion object
</span>  <span class="k">def</span> <span class="nf">empty</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// plus other ordinary factory methods, similar to other Scala collections
</span>
  <span class="c1">// the big bad
</span>  <span class="k">def</span> <span class="nf">factory</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">HeapFactory</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="kt">E</span> <span class="o">}</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now the user can proceed in blissful ignorance of <code class="language-plaintext highlighter-rouge">factory</code> or <code class="language-plaintext highlighter-rouge">MHeap</code>, treating this essentially just like any other Scala collection, until they need <code class="language-plaintext highlighter-rouge">merge</code>.
Of course, <code class="language-plaintext highlighter-rouge">empty</code> will probably be defined as</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">empty</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="n">factory</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">ord</span><span class="o">).</span><span class="py">empty</span>
</code></pre></div></div>

<p>(and similarly for the other ordinary factory methods), but the user doesn’t need to know that.</p>

<h2 id="problem-5-min-vs-max">Problem 5: <code class="language-plaintext highlighter-rouge">min</code> vs <code class="language-plaintext highlighter-rouge">max</code></h2>

<p>Should a heap favor smaller elements or bigger elements?
There’s no obvious answer—applications abound for both.
Therefore, an interface should easily support both flavors.
Right now, the ordering parameter allows us to say</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">minHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">maxHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span>
</code></pre></div></div>

<p>But how did I know that <code class="language-plaintext highlighter-rouge">Ordering.Int</code> was the right ordering for min-heaps and <code class="language-plaintext highlighter-rouge">Ordering.Int.reverse</code> was the right ordering for max-heaps?
The opposite could just as easily have been true.
Sure, this detail would probably be documented in the API, but it was fundamentally a flip-a-coin arbitrary decision.
And arbitrary decisions with no logic favoring one choice over the other are the hardest to remember.</p>

<p>In an easier-to-use interface, the user might write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">minHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">minFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">maxHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">maxFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">Ordering</span><span class="o">.</span><span class="py">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, the user doesn’t need to worry whether to use <code class="language-plaintext highlighter-rouge">Ordering.Int</code> or <code class="language-plaintext highlighter-rouge">Ordering.Int.reverse</code>.
Instead, if they want min-oriented heaps, they call <code class="language-plaintext highlighter-rouge">minFactory(Ordering.Int)</code> and if they want max-oriented heaps, they call <code class="language-plaintext highlighter-rouge">maxFactory(Ordering.Int)</code>.
In fact, it’s even better than that.
The whole point of implicit parameters is that you usually don’t need to write them down explicitly.
In reality, the user would probably only write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">minHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">minFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">val</span> <span class="nv">maxHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">maxFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>Actually, in the current version of scads, this is now</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">minHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">Min</span><span class="o">.</span><span class="py">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">val</span> <span class="nv">maxHeaps</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">Max</span><span class="o">.</span><span class="py">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">LeftistHeap.Min</code> and <code class="language-plaintext highlighter-rouge">LeftistHeap.Max</code> both support other simpler methods for creating <code class="language-plaintext highlighter-rouge">SHeap</code>s for users who don’t need <code class="language-plaintext highlighter-rouge">merge</code>.
For example, a user could write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">h1</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">Min</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="c1">// an empty min-heap of integers
</span><span class="k">val</span> <span class="nv">h2</span> <span class="k">=</span> <span class="nv">LeftistHeap</span><span class="o">.</span><span class="py">Max</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="c1">// a max-heap containing 1, 2, and 3
</span></code></pre></div></div>

<p>Of course, there’s lots more needed to flesh the whole design out into an industrial-strength API, and even more to integrate it with the current Scala collections.
I’ll continue to work on this, and I welcome discussion on these issues.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 17 Nov 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/11/17/heaps.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/11/17/heaps.html</guid>
      </item>
    
      <item>
        <title>EDSLs as functions</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p><em>This is the second of a series of articles on “Monadic EDSLs in Scala.”</em></p>

<p>Perhaps the most direct way to start writing an EDSL is to start writing
functions. Let’s say we want a language for talking about sets of integers.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SetLang</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This works… to the extent that we want only to work with
<code class="language-plaintext highlighter-rouge">scala.collection.Set</code>s. As it stands we cannot talk about
other sets such as bloom filters or sets controlled by other threads.
Our language isn’t <em>abstract</em> enough, so let’s remove
all traces of <code class="language-plaintext highlighter-rouge">Set</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>

  <span class="c1">// Given unknown F we no longer know how to create an empty set
</span>  <span class="c1">// so we add the capability to our language
</span>  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We’ve parameterized our language with a <a href="/blog/2016/08/21/hkts-moving-forward.html" title="Higher-kinded types: the difference between giving up, and moving forward">higher-kinded type</a> which
represents the context of our set. A similar parameterization could be
done with a *-kinded type (e.g. <code class="language-plaintext highlighter-rouge">SetLang[A]</code>) but since this series
focuses on <strong>monadic</strong> EDSLs, the choice is made for us.</p>

<p>Now we can write mini-programs which talk about some abstract set
yet to be determined.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">lang</span><span class="k">:</span> <span class="kt">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">lang._</span>
  <span class="nf">exists</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nf">remove</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">))))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Interpretation of our program is done by implementing <code class="language-plaintext highlighter-rouge">SetLang</code> and
passing an instance into <code class="language-plaintext highlighter-rouge">program</code>.</p>

<p>However, our language is still not abstract enough. Replacing <code class="language-plaintext highlighter-rouge">Set</code>
with <code class="language-plaintext highlighter-rouge">F</code> allows us to swap in implementations of sets, but doesn’t
allow us to talk about the context. Consider the behavior of <code class="language-plaintext highlighter-rouge">exists</code> if <code class="language-plaintext highlighter-rouge">F</code>
represents some remote set. Since <code class="language-plaintext highlighter-rouge">exists</code> returns a <code class="language-plaintext highlighter-rouge">Boolean</code>,
checking membership must be a synchronous operation despite the set living
on another node.</p>

<p>It’s also tedious to thread the set through each method manually.</p>

<p>We can solve both problems by generalizing the use of <code class="language-plaintext highlighter-rouge">F</code> to some
context that is able to read and write to some set
(think <code class="language-plaintext highlighter-rouge">Set[Int] =&gt; (Set[Int], A)</code>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>

  <span class="c1">// No longer need `empty` since the "context" has it already
</span><span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SetLang</code> can now talk about the <strong>effects</strong> around interpretation, such as
asynchronity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">type</span> <span class="kt">AsyncSet</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">A</span><span class="o">)]</span>

<span class="k">object</span> <span class="nc">AsyncSet</span> <span class="k">extends</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">AsyncSet</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This new encoding introduces a new but important problem: how do we
combine the results of multiple calls to <code class="language-plaintext highlighter-rouge">SetLang</code> methods? In the previous
encoding we could add and remove by threading the set from one call to
the next. With this change to represent a context, it’s not clear how to do
that.</p>

<p>Fortunately we are now in a position to leverage a powerful tool:
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf" title="Monads for functional programming">monads</a>. By extending our set language to be monadic
we recover composition in an elegant way. The <a href="https://github.com/typelevel/cats" title="Typelevel Cats">Cats</a> library is used
for demonstration purposes, but the discussion applies equally to
<a href="https://github.com/scalaz/scalaz/tree/series/7.3.x" title="Scalaz 7">Scalaz</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">trait</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// See: https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html
</span>  <span class="c1">// for why the `Monad` instance is defined as a member as opposed to inherited
</span>  <span class="k">def</span> <span class="nf">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">lang</span><span class="k">:</span> <span class="kt">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">lang._</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">monadInstance</span> <span class="k">=</span> <span class="n">monad</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">add</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">add</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">remove</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nf">exists</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Defining an interpreter starts by identifying a target context. Since the context
computes values while updating state, this suggests the state monad.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.State</span>

<span class="k">object</span> <span class="nc">ScalaSet</span> <span class="k">extends</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">monad</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span>

  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">State</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">State</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">State</span><span class="o">.</span><span class="py">inspect</span><span class="o">(</span><span class="nf">_</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">state</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]](</span><span class="nc">ScalaSet</span><span class="o">)</span>
<span class="c1">// state: cats.data.StateT[cats.Eval,scala.collection.immutable.Set[Int],Boolean] = cats.data.StateT@ce9f626
</span>
<span class="nv">state</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">).</span><span class="py">value</span>
<span class="c1">// res5: (scala.collection.immutable.Set[Int], Boolean) = (Set(10),true)
</span></code></pre></div></div>

<p>Note that calling <code class="language-plaintext highlighter-rouge">program</code> did not require any context-specific knowledge -
we could define another interpreter, perhaps one that talks to a set
concurrently.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.StateT</span>
<span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">ExecutionContext</span><span class="o">,</span> <span class="nc">Future</span><span class="o">}</span>

<span class="c1">// Asynchronous state
</span><span class="k">def</span> <span class="nf">AsyncSet</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">SetLang</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">monad</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">StateT</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">StateT</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">StateT</span><span class="o">.</span><span class="py">inspect</span><span class="o">(</span><span class="nf">_</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// No changes to `program` required
</span><span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="nf">program</span><span class="o">(</span><span class="nc">AsyncSet</span><span class="o">(</span><span class="nv">ExecutionContext</span><span class="o">.</span><span class="py">global</span><span class="o">))</span>
<span class="c1">// result: cats.data.StateT[scala.concurrent.Future,scala.collection.immutable.Set[Int],Boolean] = cats.data.StateT@1c029382
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SetLang</code> captures the <em>structure</em> of a computation, but leaves open
its <em>interpretation</em>.</p>

<h1 id="monad-transformers-and-classes">Monad transformers and classes</h1>

<p>As it turns out, <code class="language-plaintext highlighter-rouge">SetLang</code> is an example of an encoding often referred to as
<a href="https://hackage.haskell.org/package/mtl" title="Monad classes">MTL-style</a>.</p>

<h2 id="monads-in-monads">Monads in monads</h2>

<p>Among the motivations for monad classes is to remove the need to specify
monad transformer stacks. The following example is adapted from
<a href="http://web.cecs.pdx.edu/~mpj/pubs/springschool.html" title="Functional Programming with Overloading and Higher-Order Polymorphism">Functional Programming with Overloading and Higher-Order Polymorphism</a>
by Professor Mark P. Jones.</p>

<p>Consider a program that is open to failure and computes with some state. This
suggests a combinator of <code class="language-plaintext highlighter-rouge">Either</code> and <code class="language-plaintext highlighter-rouge">State</code>, both of which have
monad transformers. All that is left is to decide which transformer to use.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">App1</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Error</span>, <span class="kt">A</span><span class="o">]</span>
            <span class="c1">// State[S, Either[Error, A]]
</span>            <span class="c1">// S =&gt; (S, Either[Error, A])
</span>
<span class="k">type</span> <span class="kt">App2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Error</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span>
            <span class="c1">// S =&gt; Either[Error, (S, A)]
</span></code></pre></div></div>

<p>While <code class="language-plaintext highlighter-rouge">App1</code> and <code class="language-plaintext highlighter-rouge">App2</code> are both valid compositions, the
semantics of the compositions differ. <code class="language-plaintext highlighter-rouge">App1</code> describes a program where
the computation of a <em>value</em> at each transition may fail - but any changes
are preserved - whereas <code class="language-plaintext highlighter-rouge">App2</code> describes a program where the <em>entire</em>
transition may fail.</p>

<p>We can abstract away the difference by creating a type class which provides
the relevant operations we need.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">get</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Similar type classes exist for the <code class="language-plaintext highlighter-rouge">Reader</code> and <code class="language-plaintext highlighter-rouge">Writer</code> data types.
These type classes are provided in both <a href="https://github.com/typelevel/cats" title="Typelevel Cats">Cats</a> and <a href="https://github.com/scalaz/scalaz/tree/series/7.3.x" title="Scalaz 7">Scalaz</a>,
<a href="/blog/2016/09/30/subtype-typeclasses.html" title="Subtype type classes don't work">with some caveats</a>.</p>

<p>With these type classes in place we can write functions against these as
opposed to specific transformer stacks. Furthermore our functions can specify
exactly what operations they need which helps correctness and
<a href="https://www.mpi-sws.org/~dreyer/tor/papers/wadler.pdf" title="Theorems for free!">parametricity</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span><span class="nc">MonadError</span><span class="o">,</span> <span class="nc">MonadState</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.data.</span><span class="o">{</span><span class="nc">EitherT</span><span class="o">,</span> <span class="nc">State</span><span class="o">,</span> <span class="nc">StateT</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F0</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
                           <span class="n">F1</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">F0</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="nv">F1</span><span class="o">.</span><span class="py">get</span><span class="o">)</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
    <span class="nv">F0</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"fail"</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Our program can then be instantiated with either transformer stack.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="c1">// At the time of this writing Cats does not have these instances
// so they are defined here.
//
// Additionally, both Cats and Scalaz 7 have encoding issues
// with these MTL type classes which requires us to redefine Monad when
// defining MonadState instances, despite there already being one.
</span><span class="k">implicit</span> <span class="k">def</span> <span class="nf">eitherTMonadState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span>, <span class="kt">S</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">get</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>

    <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">set</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>

    <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span>
                     <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">fa</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">EitherT</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">tailRecM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">EitherT</span><span class="o">.</span><span class="py">catsDataMonadErrorForEitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">].</span><span class="py">tailRecM</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">stateTMonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span>, <span class="kt">S</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="nv">state</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span> <span class="nv">fa</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
        <span class="nv">F</span><span class="o">.</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="n">state</span><span class="o">)(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="py">run</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="nf">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">StateT</span><span class="o">.</span><span class="py">lift</span><span class="o">(</span><span class="nv">F</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>

    <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">fa</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">StateT</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">tailRecM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">StateT</span><span class="o">.</span><span class="py">catsDataMonadStateForStateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span><span class="o">].</span><span class="py">tailRecM</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">type</span> <span class="kt">App1</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">String</span>, <span class="kt">A</span><span class="o">]</span>

<span class="k">type</span> <span class="kt">App2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Int</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">app1</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">App1</span><span class="o">]</span>
<span class="c1">// app1: App1[Int] = EitherT(cats.data.StateT@5fdc056d)
</span>
<span class="k">val</span> <span class="nv">app2</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">App2</span><span class="o">]</span>
<span class="c1">// app2: App2[Int] = cats.data.StateT@72493a33
</span></code></pre></div></div>

<h1 id="composing-languages">Composing languages</h1>

<p>From one angle we can view our set language, or more generally any EDSL
in MTL-style, as an effect like <code class="language-plaintext highlighter-rouge">MonadError</code> and <code class="language-plaintext highlighter-rouge">MonadState</code>. From another
angle we can view <code class="language-plaintext highlighter-rouge">MonadError</code> and <code class="language-plaintext highlighter-rouge">MonadState</code> as EDSLs that talk about errors
and stateful computations. We can eliminate the distinctions by renaming
<code class="language-plaintext highlighter-rouge">SetLang</code> to <code class="language-plaintext highlighter-rouge">MonadSet</code> and treating it as a type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">trait</span> <span class="nc">MonadSet</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Composing multiple languages then becomes adding constraints to functions, and
interpretation becomes instantiating type parameters that satisfy the
constraints.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadCalc</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">lit</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">setProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadSet</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">MonadSet</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">exists</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">calcProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadCalc</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">calc</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">MonadCalc</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="nv">calc</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="nv">calc</span><span class="o">.</span><span class="py">lit</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nv">calc</span><span class="o">.</span><span class="py">lit</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">composedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadCalc:</span> <span class="kt">MonadSet</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">MonadCalc</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">monad</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">calcProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="nf">setProgram</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="o">}</span>

<span class="c1">// Instance
</span>
<span class="c1">// Instances are defined together but nothing is stopping us from defining
// these separately, perhaps one in the MonadSet object and another in the
// SetState object.
</span><span class="k">implicit</span> <span class="k">val</span> <span class="nv">stateInstance</span><span class="k">:</span> <span class="kt">MonadSet</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">with</span> <span class="nc">MonadCalc</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadSet</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">with</span> <span class="nc">MonadCalc</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">monad</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">State</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">State</span><span class="o">.</span><span class="py">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="nf">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="nv">State</span><span class="o">.</span><span class="py">inspect</span><span class="o">(</span><span class="nf">_</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

    <span class="k">def</span> <span class="nf">lit</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">State</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
      <span class="o">(</span><span class="n">l</span> <span class="o">|@|</span> <span class="n">r</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">result</span> <span class="k">=</span> <span class="n">composedProgram</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]].</span><span class="py">run</span><span class="o">(</span><span class="nv">Set</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]).</span><span class="py">value</span>
<span class="c1">// result: (scala.collection.immutable.Set[Int], Boolean) = (Set(),false)
</span></code></pre></div></div>

<p>As before, <code class="language-plaintext highlighter-rouge">composedProgram</code>, <code class="language-plaintext highlighter-rouge">calcProgram</code>, and <code class="language-plaintext highlighter-rouge">setProgram</code> are defined
independent of interpretation, so alternative interpretations simply require
defining appropriate instances.</p>

<h1 id="a-note-about-laws">A note about laws</h1>

<p>Type classes should come with laws - this lets us give meaning to their use.
The <code class="language-plaintext highlighter-rouge">Monoid</code> type class requires data types to have an <strong>associative</strong> binary
operation and a corresponding identity element. These laws allow us to
parallelize batch operations, such as partitioning a <code class="language-plaintext highlighter-rouge">List[A]</code> into
multiple chunks to be scattered across threads or machines and gathered
back.</p>

<p>Since our EDSLs are type classes, we should think about what laws we expect
to hold. Below are some possible candidates for laws:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// MonadSet
set *&gt; add(i)    *&gt; remove(i) = set
set *&gt; remove(i) *&gt; exists(i) = false
set *&gt; add(i)    *&gt; exists(i) = true

// MonadCalc - these are just the Monoid laws
plus(lit(0), x) = plus(x, lit(0)) = x
plus(x, plus(y, z)) = plus(plus(x, y), z)
</code></pre></div></div>

<p>Next up we’ll take a look at some pitfalls of this approach, and a modified
encoding that solves some of them.</p>

<p><em>This article was tested with Scala 2.11.8, Cats 0.7.2, kind-projector 0.9.0,
and si2712fix-plugin 1.2.0 using <a href="https://github.com/tpolecat/tut" title="tut: doc/tutorial generator for scala">tut</a>.</em></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 26 Oct 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/10/26/edsls-part-2.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/10/26/edsls-part-2.html</guid>
      </item>
    
      <item>
        <title>Typelevel representative at the Scala Center Advisory Board</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>It is our pleasure to announce that the Scala Center Advisory Board has invited us to nominate a member of the Typelevel community to serve as a community representative, alongside Bill Venners.
To figure out whether or not we should accept this offer and who we pick we have held <a href="https://github.com/typelevel/general/issues/42">an open discussion on GitHub</a>, resulting in my nomination, which I happily accept.
Thanks everyone for their trust!
The corresponding Scala Center announcement can be found <a href="http://scala-lang.org/blog/2016/10/24/lars-hupel-joins-sc-board.html">here</a>.</p>

<p><em>On a more personal note:
Some years ago, when I initially registered the <code class="language-plaintext highlighter-rouge">typelevel.org</code> domain, I could have never anticipated the large community which has gathered around typeful functional programming in Scala.
The offer from the Scala Center to nominate a representative is an acknowledgement, and also a positive signal for community outreach.
So, naturally, I’m very excited about what lies ahead.
Keep rocking!</em></p>

<p>What follows is a summary of the process.</p>

<h2 id="scala-center-advisory-board">Scala Center Advisory Board</h2>

<p>To quote <a href="http://www.scala-lang.org/blog/2016/05/30/scala-center-advisory-board.html">Jon Pretty</a>:</p>

<blockquote>
  <p>The Advisory Board is a separate body from the Scala Center, much as many governments have separate legislative and executive branches: the Advisory Board makes recommendations to the Scala Center on the work we should do, but it’s the Scala Center’s job to execute those recommendations.</p>

  <p>It currently has seven voting members: representatives from each of our six sponsors, plus Bill Venners, the community representative. Additionally the Executive Director of the Scala Center, Heather Miller, sits on the board to report on the Scala Center’s activities, and provide advice on the feasibility of the proposals under consideration, and Martin Odersky is the technical advisor to the board.</p>
</blockquote>

<p>More details, including minutes and bylaws, can be found on <a href="https://scala.epfl.ch/">their website</a>.</p>

<h2 id="process">Process</h2>

<p>To make the nomination as transparently as possible, I <a href="https://github.com/typelevel/general/issues/42">opened an issue</a> shortly after Jon mailed me about the opening.
The discussion period ended on October 12th.
All nominees endorsed me, so no vote was necessary.</p>

<h2 id="provisions">Provisions</h2>

<p>As indicated in the discussion about the nomination, we have established that the term length will be one year and after that, we will have another vote.
I hope this measure will improve community participation.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 18 Oct 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/10/18/scala-center.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/10/18/scala-center.html</guid>
      </item>
    
      <item>
        <title>Let's build ourselves a small ScalaCheck</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p><em><a href="http://scalacheck.org/">ScalaCheck</a> is a well-known property-based testing library, based on ideas from Haskell’s <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>.
It is also a <a href="/projects">Typelevel project</a>.
In this post, I’d like to show some of the underlying mechanisms, stripped down to the bare minimum.</em></p>

<p>Testing with properties is well-understood in academia and widely used in parts of the industry – namely the parts which embrace functional programming.
However, the design space of property-testing libraries is rather large.
I think it is high time to talk about various tradeoffs done in libraries.
Here, I’d like to contribute by implementing a ScalaCheck clone from scratch using a very similar design and explaining the design choices along the way.</p>

<p>This is not an introduction to property testing.
However, it can be read as a guide to implementation ideas.
QuickCheck, ScalaCheck and the like are nice examples of functional library design, but their internals are often obscured by technicalities.
I hope that by clearing up some of the concepts it will become easier to read their code and perhaps designing your own property-testing library.</p>

<h2 id="the-first-design-decision">The first design decision</h2>

<p>The basic point of a property testing library is providing an interface looking roughly like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">check</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">forAll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, you can use that in your test code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Prop</span><span class="o">.</span><span class="py">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This expresses that you have a property which is parameterized on a single integer number.
Hence, the library must somehow provide these integer numbers.
The original Haskell QuickCheck, ScalaCheck and many other libraries use a <em>random generator</em> for this.
This comes with a number of advantages:</p>

<ul>
  <li>It is relatively simple and efficient to implement.</li>
  <li>Random number generators compose exceedingly well.</li>
  <li>The confidence in the tests can be increased by just generating more inputs.</li>
  <li>Depending on the random distributions of the generators used, you have chances that both “exotic” and “common” inputs are covered.</li>
  <li>In practice, it turns out that random generators are decent at finding edge cases.</li>
</ul>

<p>But it is also not without problems:</p>

<ul>
  <li>For more complex inputs, the default generators are basically useless, because they will produce invalid input most of the time.</li>
  <li>Filtering random values before feeding them into the property can dramatically slow down the whole process.</li>
  <li>By default, it is non-deterministic (but there are remedies available).</li>
  <li>Generation of <em>random functions</em> to be used as inputs for higher-order properties is quite round-about.</li>
</ul>

<p>Of course, there are other possible design choices:</p>

<ul>
  <li><a href="https://hackage.haskell.org/package/smallcheck">SmallCheck</a> instead enumerates <em>all</em> values up to a certain size.
For example, you can specify that you want to test some function over integer lists with all lists up to size 5, containing all integers between -5 and +5.
In some situations, namely when your input is finite, you can even <em>exhaustively</em> check all inputs, which is equivalent to a <em>proof</em> that your program is correct.
The disadvantage is that even for small sizes, the input space may explode exponentially or worse (e.g. when generating lists of lists).</li>
  <li><a href="https://isabelle.in.tum.de">Isabelle</a> Quickcheck supports multiple modes, including <em>narrowing</em>, which is a form of symbolically exploring the search space.
This is based on Haskell’s <a href="https://hackage.haskell.org/package/lazysmallcheck">Lazy SmallCheck</a> (see also the <a href="https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf">paper by Runciman et.al.</a>).
The basic idea is that we can try to evaluate properties with <em>partially-defined inputs</em> and refine them on demand.</li>
</ul>

<p><strong>For this post, we’re assuming that random generation is a given.</strong></p>

<h2 id="the-second-design-decision">The second design decision</h2>

<blockquote>
  <p>Do we want to do this purely or poorly?</p>
</blockquote>

<p>Of course, this motto is tongue-in-cheek.
Just because something isn’t <em>pure</em> doesn’t mean that it is <em>poor.</em></p>

<p>To understand the design space here, let’s focus on the smallest building block: A primitive random generator.
There are two possible ways to model this.
The <em>mutable</em> way is what Java, Scala and many other languages offer in their libraries:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Random</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">nextInt</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="nf">nextFloat</span><span class="o">()</span><span class="k">:</span> <span class="kt">Float</span>
  <span class="k">def</span> <span class="nf">nextItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">pool</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>By looking at the types alone, we can already see that two subsequent calls of <code class="language-plaintext highlighter-rouge">nextInt</code> will produce different results; the interface is thus <em>impure.</em></p>

<p>The <em>pure</em> way is to make the internal state (also known as “seed” in the context of random generators) explicit:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Seed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">nextInt</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">nextFloat</span><span class="k">:</span> <span class="o">(</span><span class="kt">Float</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">nextItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">pool</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Seed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">init</span><span class="o">()</span><span class="k">:</span> <span class="kt">Seed</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Because this is difficult to actually use (don’t mix up the <code class="language-plaintext highlighter-rouge">Seed</code> instances and use them twice!), one would wrap this into a state monad:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">private</span> <span class="k">val</span> <span class="nv">op</span><span class="k">:</span> <span class="kt">Seed</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="nc">Seed</span><span class="o">))</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="nf">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nf">op</span><span class="o">(</span><span class="nv">Seed</span><span class="o">.</span><span class="py">init</span><span class="o">()).</span><span class="py">_1</span>

  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]({</span> <span class="n">seed0</span> <span class="k">=&gt;</span>
      <span class="nf">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">seed1</span><span class="o">)</span> <span class="k">=</span> <span class="nv">self</span><span class="o">.</span><span class="py">op</span><span class="o">(</span><span class="n">seed0</span><span class="o">)</span>
      <span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">seed1</span><span class="o">)</span>
    <span class="o">})</span>

  <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]({</span> <span class="n">seed0</span> <span class="k">=&gt;</span>
      <span class="nf">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">seed1</span><span class="o">)</span> <span class="k">=</span> <span class="nv">self</span><span class="o">.</span><span class="py">op</span><span class="o">(</span><span class="n">seed0</span><span class="o">)</span>
      <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="py">op</span><span class="o">(</span><span class="n">seed1</span><span class="o">)</span>
    <span class="o">})</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;random&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Random</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">int</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">))</span>
  <span class="k">val</span> <span class="nv">float</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">nextFloat</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can use Scala’s <code class="language-plaintext highlighter-rouge">for</code> comprehensions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">x</span> <span class="k">&lt;-</span> <span class="nv">Random</span><span class="o">.</span><span class="py">int</span><span class="o">(-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
  <span class="n">y</span> <span class="k">&lt;-</span> <span class="nv">Random</span><span class="o">.</span><span class="py">int</span><span class="o">(-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">// res2: Random[(Int, Int)] = &lt;random&gt;
</span></code></pre></div></div>

<p>The tradeoffs here are the usual when we’re talking about functional programming in Scala: Reasoning ability, convenience, performance, … 
In the pure case, there are also multiple other possible encodings, including free monads.
Luckily, this blog covers that topic in another <a href="/blog/2016/09/21/edsls-part-1.html">post</a>.</p>

<p>How do other libraries fare here?</p>

<ul>
  <li>ScalaCheck up to 1.12.x uses a mutable random number generator; namely, <code class="language-plaintext highlighter-rouge">scala.util.Random</code>.</li>
  <li>ScalaCheck 1.13.x+ uses its own, immutable implementation.</li>
  <li>Another Scala library for property testing, <a href="https://github.com/scalaprops/scalaprops">scalaprops</a>, does not.
I’m not familiar with it, but as far as I can tell from the <a href="https://github.com/scalaprops/scalaprops/blob/v0.3.4/gen/src/main/scala/scalaprops/Rand.scala">sources</a>, it’s similar to the <code class="language-plaintext highlighter-rouge">Seed</code> trait from above, and there is also an additional state-monadic layer on top of it.</li>
  <li>In QuickCheck, the encoding seems strange at first.
They use a primitive generator which looks a lot like <code class="language-plaintext highlighter-rouge">Seed</code>, but they don’t use the updated seed.
Instead, their approach is via an additional primitive <code class="language-plaintext highlighter-rouge">split</code> of type <code class="language-plaintext highlighter-rouge">Seed =&gt; (Seed, Seed)</code>, which gets used to “distribute” randomness during composition (see the <a href="http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf">paper by Claessen &amp; Pałka</a> about the theory behind that).
It is worth noting that Java 8 introduced a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html"><code class="language-plaintext highlighter-rouge">SplittableRandom</code></a> class.</li>
</ul>

<p><strong>For this post, we’re assuming that mutable state is a given.</strong>
We’ll use <code class="language-plaintext highlighter-rouge">scala.util.Random</code> (because it’s readily available) in a similar fashion to ScalaCheck 1.12.x.</p>

<h2 id="the-third-design-decision">The third design decision</h2>

<p>Asynchronous programming is all the rage these days.
This means that many functions will not return plain values of type <code class="language-plaintext highlighter-rouge">A</code>, but rather <code class="language-plaintext highlighter-rouge">Future[A]</code>, <code class="language-plaintext highlighter-rouge">Task[A]</code> or some other similar type.
For our testing framework, this poses a challenge:
If our properties call such asynchronous functions, the framework needs to know how to deal with a lot of <code class="language-plaintext highlighter-rouge">Future[Boolean]</code> values.
On the JVM, although not ideal, we could fall back to blocking on the result and proceed as usual.
On <a href="http://www.scala-js.org/">Scala.js</a>, this won’t fly, because you just can’t block in JavaScript.</p>

<p>Most general-purpose testing frameworks, like Specs2, have a <a href="https://etorreborre.github.io/specs2/guide/SPECS2-3.8.5/org.specs2.guide.Matchers.html">story about this</a>, enabling asynchronous checking of assertions.</p>

<p>In theory, it’s not a problem to support this in a property testing library.
But in practice, there are some complications:</p>

<ul>
  <li>Has the library been designed that way? If not, can we change it to support it?
This is a real problem: It took quite some time and some significant refactorings to support <code class="language-plaintext highlighter-rouge">Future</code>s in <a href="http://www.scalatest.org/user_guide/async_testing">ScalaTest</a>.</li>
  <li>Should random generators also return <code class="language-plaintext highlighter-rouge">Future</code> values?
We can easily imagine wanting to draw from a pool of inputs stemming from a database, or possibly to get better randomness from <a href="https://www.random.org/">random.org</a>.
(The latter is a joke.)</li>
  <li>What async type constructor should we support?
<a href="http://www.scala-lang.org/files/archive/api/2.11.8/#scala.concurrent.Future">The built-in one</a>?
<a href="https://monix.io/docs/2x/eval/task.html">Monix’ <code class="language-plaintext highlighter-rouge">Task</code></a>?
<a href="https://github.com/functional-streams-for-scala/fs2/blob/v0.9.1/core/shared/src/main/scala/fs2/Task.scala">fs2’s <code class="language-plaintext highlighter-rouge">Task</code></a>?
All of them?</li>
</ul>

<p>If in the first design decisions we had chosen exhaustive generators, this problem would be even tougher, because designing a correct effectful stream type (of all possible inputs) is not trivial.</p>

<p><strong>For this post, we’re assuming that we’re only interested in synchronous properties, or can always block.</strong>
However, I’d like to add, I’d probably try to incorporate async properties right from the start if I were to implement a testing library from scratch.</p>

<p>What about the existing libraries?</p>

<ul>
  <li>ScalaCheck itself does not support asynchronous properties.</li>
  <li>In SmallCheck, both <a href="https://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck-Series.html#t:Serial">generators</a> and <a href="https://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck.html#t:Property">properties</a> may be monadic.</li>
  <li>QuickCheck supports arbitrary I/O actions in a property via a function called <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Property.html#v:morallyDubiousIOProperty"><code class="language-plaintext highlighter-rouge">morallyDubiosIOProperty</code></a> (nowadays just <code class="language-plaintext highlighter-rouge">ioProperty</code>).
But there is also <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Monadic.html">more advanced support</a> for monadic testing.</li>
</ul>

<h2 id="the-fourth-design-decision">The fourth design decision</h2>

<p>Let’s summarize what we have so far:</p>

<ol>
  <li>randomly generated inputs</li>
  <li>… using a stateful primitive generator</li>
  <li>synchronous properties</li>
</ol>

<p>Now, I’d like to talk about how to “package” random generators.
Earlier, we’ve only seen random integer and floating-point numbers, but of course, we want something more complex, including custom data structures.
It is convenient to abstract over this and specify the concept of a <em>generator</em> for type <code class="language-plaintext highlighter-rouge">A</code>.
The idea is to make a generator for a type as “general” as possible and then provide combinators to compose them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
      <span class="nv">rnd</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>An obvious combinator is a generator for tuples:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">zip</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">genU</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="nv">genT</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">rnd</span><span class="o">),</span> <span class="nv">genU</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">rnd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But we still have a problem:
There is currently no way to talk about the <em>size</em> of the generated inputs.
Let’s say we want to check an expensive algorithm over lists, for example with a complexity of $\mathcal O(n^3)$ over lists.
A naive implemenation of a list generator would take a a random size, and then give you some generator for lists.
The problem arises at the use site: Whenver you want to change the size of the generated inputs, you need to change the expression constructing the generator.</p>

<p>But we’d like to do better here:</p>

<p><strong>For this post, there should be a way to specify a maximum size of generated values, together with a way to influence that size in the tests without having to modify the generators.</strong></p>

<p>Here’s how we can do that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;gen&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>

  <span class="k">val</span> <span class="nv">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">range</span> <span class="k">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="nv">rnd</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="n">range</span><span class="o">)</span> <span class="o">-</span> <span class="n">size</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">list</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">genA</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">length</span> <span class="k">=</span> <span class="nv">rnd</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="nv">List</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="n">length</span><span class="o">)(</span><span class="nv">genA</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>We can now check this (note that for the purpose of this post we’ll be using fixed seeds):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">printSample</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">rnd</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="nf">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">size</span><span class="o">)</span>
    <span class="nf">println</span><span class="o">(</span><span class="nv">genT</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">printSample</span><span class="o">(</span><span class="nv">Gen</span><span class="o">.</span><span class="py">int</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="mi">2</span>
<span class="mi">6</span>
<span class="o">-</span><span class="mi">6</span>
<span class="o">-</span><span class="mi">8</span>
<span class="mi">1</span>
<span class="mi">4</span>
<span class="o">-</span><span class="mi">8</span>
<span class="mi">5</span>
<span class="o">-</span><span class="mi">4</span>
<span class="o">-</span><span class="mi">8</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">printSample</span><span class="o">(</span><span class="nv">Gen</span><span class="o">.</span><span class="py">int</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="mi">2</span>
<span class="o">-</span><span class="mi">1</span>
<span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">printSample</span><span class="o">(</span><span class="nv">Gen</span><span class="o">.</span><span class="py">list</span><span class="o">(</span><span class="nv">Gen</span><span class="o">.</span><span class="py">int</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>
<span class="nc">List</span><span class="o">()</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">8</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">)</span>
<span class="nc">List</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">printSample</span><span class="o">(</span><span class="nv">Gen</span><span class="o">.</span><span class="py">list</span><span class="o">(</span><span class="nv">Gen</span><span class="o">.</span><span class="py">int</span><span class="o">),</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p>That’s already pretty cool.
But there’s another hidden design decision here:
We’re using the same size on all sub-elements in the generated thing.
For example, in <code class="language-plaintext highlighter-rouge">Gen.list</code>, we’re just passing the size through to the child generator.</p>

<p>SmallCheck does that differently: The “size” is defined to be the total number of constructors in the generated value.
For integer numbers, the “number of constructors” is basically the number itself.
For example, the value <code class="language-plaintext highlighter-rouge">List(1, 2)</code> has size $2$ in our framework (length of the list), but size $1 + 2 + 2 = 5$ in SmallCheck (roughly: size of all elements plus length of list).</p>

<p>Of course, our design decision might mean that stuff grows too fast.
The explicit size parameter can be used to alleviate that, especially for writing recursive generators:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// extremely stupid implementation, don't use it
</span>  <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">rnd</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nv">genT</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span> <span class="o">::</span> <span class="nf">recList</span><span class="o">(</span><span class="n">genT</span><span class="o">).</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">Nil</span>
<span class="o">}</span>
<span class="c1">// recList: [T](genT: Gen[T])Gen[List[T]]
</span>
<span class="nf">printSample</span><span class="o">(</span><span class="nf">recList</span><span class="o">(</span><span class="nv">Gen</span><span class="o">.</span><span class="py">int</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>
<span class="c1">// List()
// List(-6, 1, -6)
// List(-8, 8, 4, 7, 0, 5, -4)
// List(-8)
// List(9, -3, 4)
// List(1, 3, -7, -2, -3, 0, -3, 3)
// List()
// List(10, 5, -8, -4, -5, 4, -1)
// List(-5, 9, 7)
// List(-8)
</span></code></pre></div></div>

<p>We can also provide a combinator for this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">resize</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">newSize</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="nv">genT</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">newSize</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That one is useful because in reality ScalaCheck’s <code class="language-plaintext highlighter-rouge">generate</code> method takes some more parameters than just the size.
Some readers might be reminded that this is just the reader monad and its <code class="language-plaintext highlighter-rouge">local</code> combinator in disguise.</p>

<h2 id="some-sugar">Some sugar</h2>

<p>In order to make these generators nicely composable, we can leverage <code class="language-plaintext highlighter-rouge">for</code> comprehensions.
We just need to implement <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">withFilter</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>

  <span class="c1">// Generate a value and then apply a function to it
</span>  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span>
      <span class="nf">f</span><span class="o">(</span><span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="c1">// Generate a value and then use it to produce a new generator
</span>  <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span>
      <span class="nf">f</span><span class="o">(</span><span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)).</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// Repeatedly generate values until one passes the check
</span>  <span class="c1">// (We would usually call this `filter`, but Scala requires us to
</span>  <span class="c1">// call it `withFilter` in order to be used in `for` comprehensions)
</span>  <span class="k">def</span> <span class="nf">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">candidate</span> <span class="k">=</span> <span class="nv">self</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
      <span class="nf">if</span> <span class="o">(</span><span class="nf">p</span><span class="o">(</span><span class="n">candidate</span><span class="o">))</span>
        <span class="n">candidate</span>
      <span class="k">else</span> <span class="c1">// try again
</span>        <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;gen&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>

  <span class="c1">// unchanged from above
</span>
  <span class="k">val</span> <span class="nv">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">range</span> <span class="k">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="nv">rnd</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="n">range</span><span class="o">)</span> <span class="o">-</span> <span class="n">size</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">list</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">genA</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">length</span> <span class="k">=</span> <span class="nv">rnd</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="nv">List</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="n">length</span><span class="o">)(</span><span class="nv">genA</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Look how simple composition is now:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Frac</span><span class="o">(</span><span class="n">numerator</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">denominator</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="c1">// defined class Frac
</span>
<span class="k">val</span> <span class="nv">fracGen</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Frac</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">num</span> <span class="k">&lt;-</span> <span class="nv">Gen</span><span class="o">.</span><span class="py">int</span>
    <span class="n">den</span> <span class="k">&lt;-</span> <span class="nv">Gen</span><span class="o">.</span><span class="py">int</span>
    <span class="k">if</span> <span class="n">den</span> <span class="o">!=</span> <span class="mi">0</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="nc">Frac</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">den</span><span class="o">)</span>
<span class="c1">// fracGen: Gen[Frac] = &lt;gen&gt;
</span>
<span class="nf">printSample</span><span class="o">(</span><span class="n">fracGen</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="c1">// Frac(2,6)
// Frac(-6,-8)
// Frac(1,4)
// Frac(-8,5)
// Frac(-4,-8)
// Frac(-2,-8)
// Frac(4,6)
// Frac(1,4)
// Frac(0,-10)
// Frac(10,4)
</span></code></pre></div></div>

<p>And we can even read the construction nicely: “First draw a numerator, then draw a denominator, then check that the denominator is not zero, then construct a fraction.”
However, we need to be cautious with the filtering.
If you look closely at the implementation of <code class="language-plaintext highlighter-rouge">withFilter</code>, you can see that there is potential for an infinite loop.
For example, when you pass in the filter <code class="language-plaintext highlighter-rouge">_ =&gt; false</code>.
It will just keep generating values and then discard them.
How do existing frameworks alleviate this?</p>

<ul>
  <li>QuickCheck has two filter combinators: one that returns <code class="language-plaintext highlighter-rouge">Gen[A]</code> as above, and one that return <code class="language-plaintext highlighter-rouge">Gen[Option[A]]</code>.
The latter uses a number of tries and if they all fail, terminates and returns <code class="language-plaintext highlighter-rouge">None</code>.
The former uses the latter, but keeps increasing the size parameter.
Of course, this might not terminate.</li>
  <li>ScalaCheck’s <code class="language-plaintext highlighter-rouge">filter</code> method returns <code class="language-plaintext highlighter-rouge">Gen[A]</code>, but the possibility of failure is encoded in the return type of its equivalent of the <code class="language-plaintext highlighter-rouge">generate</code> method, which always returns <code class="language-plaintext highlighter-rouge">Option[T]</code>.
But there is also a combinator which retries until it finds a valid input, called <code class="language-plaintext highlighter-rouge">retryUntil</code>.</li>
</ul>

<p>As a side note: <code class="language-plaintext highlighter-rouge">Gen</code> as it is right now is <em>definitely not</em> a valid monad, because it internally relies on mutable state.
But in my opinion, it is still justified to offer the <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code> methods, but don’t give a <code class="language-plaintext highlighter-rouge">Monad</code> instance.
This prevents you from shoving <code class="language-plaintext highlighter-rouge">Gen</code> into functions which expect lawful monads.</p>

<p>It’s still tedious to having to construct these generators by hand.
Both QuickCheck and ScalaCheck introduce a thin layer atop generators, called <code class="language-plaintext highlighter-rouge">Arbitrary</code>.
This is just a type class which contains a generator, nothing more.
Here’s how it would look like in Scala:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Arbitrary</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">gen</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// in practice we would put that into the companion object
//object Arbitrary {
</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">arbitraryInt</span><span class="k">:</span> <span class="kt">Arbitrary</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Arbitrary</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">gen</span> <span class="k">=</span> <span class="nv">Gen</span><span class="o">.</span><span class="py">int</span>
  <span class="o">}</span>

<span class="c1">//}
</span></code></pre></div></div>

<p>Based on this definition, ScalaCheck provides a lot of pre-defined instances for all sorts of types.
For your custom types, the idea is that you define a low-level generator and wrap it into an implicit <code class="language-plaintext highlighter-rouge">Arbitrary</code>.
Then, in your tests, you just use the implicitly provided generator, and avoid to drop down to constructing them manually.</p>

<p>The purpose of the additional layer is explained easily: It is common to have multiple <code class="language-plaintext highlighter-rouge">Gen[T]</code> for the same <code class="language-plaintext highlighter-rouge">T</code> depending on which context it is needed in.
But there should only be one <code class="language-plaintext highlighter-rouge">Arbitrary[T]</code> for each <code class="language-plaintext highlighter-rouge">T</code>.
For example, you might have <code class="language-plaintext highlighter-rouge">Gen[Int]</code> for positive and negative integers, but you only have a single <code class="language-plaintext highlighter-rouge">Arbitrary[Int]</code> which covers all integers.
You use the latter when you actually need to supply an integer to your property, and the former to construct more complex generators, like for <code class="language-plaintext highlighter-rouge">Frac</code> above.</p>

<h2 id="the-fifth-design-decision">The fifth design decision</h2>

<p>This is where everything really comes together.
We’re now looking at how to use <code class="language-plaintext highlighter-rouge">Gen</code> to implement the desired <code class="language-plaintext highlighter-rouge">forAll</code> function we’ve seen early in the introduction of the post, and how that is related to the <code class="language-plaintext highlighter-rouge">Prop</code> type I didn’t define.
I’ll readily admit that the following isn’t really a design decision per se, because we’ll be guided by the presence of type classes in Scala.
Still, one could reasonably structure this differently, and in fact, the design of the <code class="language-plaintext highlighter-rouge">Prop</code> type in e.g. QuickCheck is much more complex than what you’ll see.</p>

<p>The rest of this post will now depart from the way it’s done in ScalaCheck, although the ideas are still similar.
Instead, I’ll try to show a simplified version without introducing complications required to make it work nicely.</p>

<p>Let’s start with the concept of a <em>property.</em>
A property is something that we can <em>run</em> and which returns a <em>result</em>.
The result should ideally be something like a boolean: Either the property holds or it doesn’t.
But one of the main features of any property testing library is that it will return a counterexample for the inputs where the property doesn’t hold.
Hence, we need to store this counterexample in the failure case.
In practice, the result type would be much richer, with attached labels, reasons, expectations, counters, … and more diagnostic fields.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Result</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Success</span> <span class="k">extends</span> <span class="nc">Result</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Result</span>

<span class="k">object</span> <span class="nc">Result</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">fromBoolean</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span>
      <span class="nc">Success</span>
    <span class="k">else</span>
      <span class="c1">// if it's false, it's false; no input has been produced,
</span>      <span class="c1">// so the counterexample is empty
</span>      <span class="nc">Failure</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You’ll note that I’ve used <code class="language-plaintext highlighter-rouge">List[String]</code> here, because in the end we only want to print the counterexample on the console.
ScalaCheck has a dedicated <code class="language-plaintext highlighter-rouge">Pretty</code> type for that.
We could do even more fancy things here if we wanted to, but let’s keep it simple.</p>

<p>Now we define the <code class="language-plaintext highlighter-rouge">Prop</code> type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;prop&gt;"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What’s missing is a way to construct properties.
Sure, we could implement the trait manually in our tests, but that would be tedious.
Type classes to the rescue!
We call something <em>testable</em> if it can be converted to a <code class="language-plaintext highlighter-rouge">Prop</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span>
<span class="o">}</span>

<span class="c1">// in practice we would put these into the companion object
//object Testable {
</span>
  <span class="c1">// Booleans can be trivially converted to a property:
</span>  <span class="c1">// They are already basically a `Result`, so no need
</span>  <span class="c1">// to run anything!
</span>  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">booleanIsTestable</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Prop</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
        <span class="nv">Result</span><span class="o">.</span><span class="py">fromBoolean</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// Props are already `Prop`s.
</span>  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">propIsTestable</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">Prop</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">Prop</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Prop</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="n">t</span>
  <span class="o">}</span>

<span class="c1">//}
</span></code></pre></div></div>

<p>Now we’re all set:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">forAll</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">O</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">O</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">arbI</span><span class="k">:</span> <span class="kt">Arbitrary</span><span class="o">[</span><span class="kt">I</span><span class="o">],</span> <span class="n">testO</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">O</span><span class="o">])</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">Prop</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">input</span> <span class="k">=</span> <span class="nv">arbI</span><span class="o">.</span><span class="py">gen</span><span class="o">.</span><span class="py">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
      <span class="k">val</span> <span class="nv">subprop</span> <span class="k">=</span> <span class="nv">testO</span><span class="o">.</span><span class="py">asProp</span><span class="o">(</span><span class="nf">prop</span><span class="o">(</span><span class="n">input</span><span class="o">))</span>
      <span class="nv">subprop</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span> <span class="k">=&gt;</span>
          <span class="nc">Success</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">Failure</span><span class="o">(</span><span class="nv">input</span><span class="o">.</span><span class="py">toString</span> <span class="o">::</span> <span class="n">counterexample</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Let’s unpack this step by step.</p>

<ol>
  <li>We’re taking a function from <code class="language-plaintext highlighter-rouge">I =&gt; O</code>.
This is supposed to be our parameterized property, for example <code class="language-plaintext highlighter-rouge">{ (x: Int) =&gt; x == x }</code>.
Because we abstracted over values that can be generated (<code class="language-plaintext highlighter-rouge">Arbitrary</code>) and things that can be tested (<code class="language-plaintext highlighter-rouge">Testable</code>), the input and output types are completely generic.
In the <code class="language-plaintext highlighter-rouge">implicit</code> block, we’re taking the instructions of how to fit everything together.</li>
  <li>We’re constructing a <code class="language-plaintext highlighter-rouge">Prop</code>; that is, a thing that we can run and that produces a boolean-ish <code class="language-plaintext highlighter-rouge">Result</code>.</li>
  <li>To run the property, we need to construct a random input.
We can use the <code class="language-plaintext highlighter-rouge">Gen[I]</code> which we get from the <code class="language-plaintext highlighter-rouge">Arbitrary[I]</code>.</li>
  <li>We pass that <code class="language-plaintext highlighter-rouge">I</code> into the parameterized property.
To stick with the example, we evaluate the anonymous function <code class="language-plaintext highlighter-rouge">{ (x: Int) =&gt; x == x }</code> at input <code class="language-plaintext highlighter-rouge">5</code>, and obtain <code class="language-plaintext highlighter-rouge">true</code>.</li>
  <li>We convert the result to a <code class="language-plaintext highlighter-rouge">Prop</code> again.
This allows us to recursively nest <code class="language-plaintext highlighter-rouge">forAll</code>s, for example when we need two inputs.</li>
  <li>We run the resulting property and check if it fails.
If it does, we prepend the generated input to the counterexample.
In the nested scenario, this allows us to see all generated inputs and the order in which we sticked them into the property.</li>
</ol>

<p>At this point we should look at an example.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">propReflexivity</span> <span class="k">=</span>
  <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="c1">// propReflexivity: Prop = &lt;prop&gt;
</span></code></pre></div></div>

<p>Cool, but how do we run this?</p>

<p>Remember that our tool is supposed to evaluate a property on multiple inputs.
All these evaluations will produce a <code class="language-plaintext highlighter-rouge">Result</code>.
Hence, we need to merge those together into a single result.
We’ll also define a convenient function that runs a property multiple times on different sizes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Result</span><span class="o">])</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
  <span class="nv">rs</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">Success</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Success</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span>
    <span class="nf">case</span> <span class="o">(</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">check</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">P</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">testP</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">rnd</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">rs</span> <span class="k">=</span>
    <span class="nf">for</span> <span class="o">(</span><span class="n">size</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">100</span><span class="o">)</span>
    <span class="k">yield</span> <span class="nv">testP</span><span class="o">.</span><span class="py">asProp</span><span class="o">(</span><span class="n">prop</span><span class="o">).</span><span class="py">run</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
  <span class="nf">merge</span><span class="o">(</span><span class="nv">rs</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="s">"✓ Property successfully checked"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="nv">pretty</span> <span class="k">=</span> <span class="nv">counterexample</span><span class="o">.</span><span class="py">mkString</span><span class="o">(</span><span class="s">"("</span><span class="o">,</span> <span class="s">", "</span><span class="o">,</span> <span class="s">")"</span><span class="o">)</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"✗ Property failed with counterexample: $pretty"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What is happening here?</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">merge</code> function takes a list of <code class="language-plaintext highlighter-rouge">Result</code>s and returns the first <code class="language-plaintext highlighter-rouge">Failure</code>, if it exists.
Otherwise it returns <code class="language-plaintext highlighter-rouge">Success</code>.
In case there are multiple <code class="language-plaintext highlighter-rouge">Failure</code>s, it doesn’t care and just discards the later ones.</li>
  <li>The <code class="language-plaintext highlighter-rouge">check</code> function initializes a fresh random generator.</li>
  <li>We have fixed the maximum size to 100 and will run the passed property with each size from 0 to 100.
This ensures that we get a nice coverage of various input sizes.
An obvious optimisation here would be to stop after the first failure, instead of merging the results in a subsequent step.</li>
  <li>In case there’s a failure, we just print the counterexample.</li>
</ol>

<p>Let’s check our property!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">check</span><span class="o">(</span><span class="n">propReflexivity</span><span class="o">)</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>
</code></pre></div></div>

<p>… and how about something wrong?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">check</span><span class="o">(</span><span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">})</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="some-more-sugar">Some more sugar</h2>

<p>Okay, we’re almost done.
The only tedious thing that remains is that we have to use the <code class="language-plaintext highlighter-rouge">forAll</code> combinator, especially in the nested case.
It would be great if we could just use <code class="language-plaintext highlighter-rouge">check</code> and pass it a function.
But since we’ve used type classes for everything, we’re in luck!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">funTestable</span><span class="o">[</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Arbitrary</span>, <span class="kt">O</span> <span class="kt">:</span> <span class="kt">Testable</span><span class="o">]</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">O</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">O</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">asProp</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">O</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span>
    <span class="c1">// wait for it ...
</span>    <span class="c1">// ...
</span>    <span class="c1">// ...
</span>    <span class="c1">// it's really simple ...
</span>    <span class="nf">forAll</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can check our functions even easier!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">)</span>

<span class="kt">scala&gt;</span> <span class="kt">check</span> <span class="o">{</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">,</span> <span class="err">1</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, if you look closely, you can basically get rid of the <code class="language-plaintext highlighter-rouge">Prop</code> class and define it as</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span>
</code></pre></div></div>

<p>If you think about this for a moment, it makes sense: A “property” is really just a thing which feeds on randomness and produces a result.
The only thing left is to define a driver which runs a couple of iterations and gathers the results; in our implementation, that’s the <code class="language-plaintext highlighter-rouge">check</code> function.
I encourage you to spell out the other functions (e.g. <code class="language-plaintext highlighter-rouge">forAll</code>), and you will notice that our <code class="language-plaintext highlighter-rouge">Prop</code> trait is indeed isomorphic to <code class="language-plaintext highlighter-rouge">Gen[Result]</code>.
In practice, QuickCheck uses such a representation (although with some more contraptions).</p>

<h2 id="summary">Summary</h2>

<p>It turns out that it’s not that hard to write a small property-testing library.
I’m going to stop here with the implementation, although there are still some things to explore:</p>

<ul>
  <li>How to <a href="https://github.com/alexarchambault/scalacheck-shapeless">get rid of the boilerplate</a> to generate “boring” data structures?</li>
  <li>How to <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html#t:CoArbitrary">generate functions</a>?</li>
  <li>How to improve usability?</li>
  <li>How to <a href="https://github.com/typelevel/discipline">bundle up a bunch of properties</a>?</li>
  <li>How to <a href="https://github.com/rickynils/scalacheck/blob/1.13.2/doc/UserGuide.md#test-case-minimisation">show useful counterexamples</a>?</li>
  <li>How to test <a href="https://github.com/rickynils/scalacheck/blob/1.13.2/doc/UserGuide.md#properties">conditional properties</a>?</li>
  <li>How to test the library itself?</li>
  <li>How to make sure that your generators produce reasonable values?</li>
  <li>How to make sure that your generators <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#v:label">cover a wide range of values</a>?</li>
  <li>How to test <a href="https://github.com/larsrh/polycheck">polymorphic properties</a>?</li>
  <li>…</li>
</ul>

<p>Finally, I’d like to note that there are many more libraries out there than I’ve mentioned here, some of which depart more, some less, from the original Haskell implementation.
They even exist for not-functional languages, e.g. <a href="http://www.javaslang.io/javaslang-docs/#_property_checking">Javaslang</a> for Java or <a href="http://hypothesis.works/">Hypothesis</a> for Python.</p>

<p><em>Correction: In a previous version of this post, I incorrectly stated that ScalaCheck uses a mutable random generator. This is only true up to ScalaCheck 1.12.x. I have updated that section in the post.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/10/17/minicheck.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/10/17/minicheck.html</guid>
      </item>
    
      <item>
        <title>Subtype type classes don't work</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p><em>Update: A comprehensive version of this blog post was published at the
<a href="https://conf.researchr.org/track/scala-2017/scala-2017-papers&lt;Paste&gt;">2017 Scala Symposium</a> and is available <a href="http://www.sigplan.org/OpenTOC/scala17.html">for free</a>
through the ACM OpenTOC service. The corresponding talk can be found
<a href="https://www.youtube.com/watch?v=BGoTXO1V0HM&amp;list=PL6KWJEIH5ulcNeQ92iKFN2k-UIV9QHExH&amp;index=3">here</a>.</em></p>

<p>The common encoding of type classes in Scala relies on subtyping. This singular
fact gives us a certain cleanliness in the code, but at what cost?</p>

<h2 id="problem">Problem</h2>

<p>Consider the following hierarchy of type classes. A similar hierarchy can be
found in both <a href="https://github.com/typelevel/cats" title="Typelevel Cats">Cats</a> and <a href="https://github.com/scalaz/scalaz/tree/series/7.3.x" title="Scalaz 7">Scalaz 7</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>

<span class="nc">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
</code></pre></div></div>

<p>For purposes of demonstration I will be using Cats for the rest of this post,
but the same arguments apply to Scalaz 7.</p>

<p>We will also assume that there is syntax accompanying this hierarchy, allowing
us to call methods like <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code>, and <code class="language-plaintext highlighter-rouge">traverse</code> directly on some
<code class="language-plaintext highlighter-rouge">F[A]</code>, provided <code class="language-plaintext highlighter-rouge">F</code> has the appropriate type class instances (<code class="language-plaintext highlighter-rouge">Functor</code>,
<code class="language-plaintext highlighter-rouge">Monad</code>, and <code class="language-plaintext highlighter-rouge">Traverse</code>, respectively).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
</code></pre></div></div>

<p>One important consequence is we can use for comprehensions in methods
parameterized over some <code class="language-plaintext highlighter-rouge">Monad</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>Notice that due to how for comprehensions <a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html" title="How does yield work?">desugar</a>, there is also
a call to <code class="language-plaintext highlighter-rouge">map</code> in there. Since our type class hierarchy is encoded via
subtyping Scala knows a <code class="language-plaintext highlighter-rouge">Monad[F]</code> implies a <code class="language-plaintext highlighter-rouge">Functor[F]</code>, so all is well.
Or is it?</p>

<p>Consider a case where we want to abstract over a data type that has
both <code class="language-plaintext highlighter-rouge">Monad</code> and <code class="language-plaintext highlighter-rouge">Traverse</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ignore the fact we're not even using `Traverse` - we can't even call `map`!
</span><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:19: error: value map is not a member of type parameter F[Int]
//        def foo[F[_]: Monad: Traverse]: F[Int] = Monad[F].pure(10).map(identity)
//                                                                   ^
// &lt;console&gt;:19: error: missing argument list for method identity in object Predef
// Unapplied methods are only converted to functions when a function type is expected.
// You can make this conversion explicit by writing `identity _` or `identity(_)` instead of `identity`.
//        def foo[F[_]: Monad: Traverse]: F[Int] = Monad[F].pure(10).map(identity)
//                                                                       ^
</span></code></pre></div></div>

<p>We’re already in trouble. In order to call <code class="language-plaintext highlighter-rouge">map</code> we need <code class="language-plaintext highlighter-rouge">F</code> to have a
<code class="language-plaintext highlighter-rouge">Functor</code> instance, which it does via <code class="language-plaintext highlighter-rouge">Monad</code> as before.. but now also via
<code class="language-plaintext highlighter-rouge">Traverse</code>. It is for precisely this reason that this does not work. Because
our encoding of type classes uses subtyping, a <code class="language-plaintext highlighter-rouge">Monad[F]</code> <strong>is a</strong> <code class="language-plaintext highlighter-rouge">Functor[F]</code>.
Similarly, a <code class="language-plaintext highlighter-rouge">Traverse[F]</code> <strong>is a</strong> <code class="language-plaintext highlighter-rouge">Functor[F]</code>. When implicit resolution
attempts to find a <code class="language-plaintext highlighter-rouge">Functor[F]</code>, it can’t decide between <code class="language-plaintext highlighter-rouge">Monad[F]</code>’s or
<code class="language-plaintext highlighter-rouge">Traverse[F]</code>’s and bails out. Even though the instances may be,
<a href="https://www.youtube.com/watch?v=hIZxTQP1ifo" title="Edward Kmett - Type Classes vs. the World">and arguably should be</a>, the same, the compiler has no way of
knowing that.</p>

<p>This problem generalizes to anytime the compiler decides an implicit is ambiguous,
such as method calls.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The fact we don't actually use `Functor` here is irrelevant.
</span><span class="k">def</span> <span class="nf">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Functor</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">callBar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="c1">// &lt;console&gt;:19: error: ambiguous implicit values:
//  both value evidence$2 of type cats.Traverse[F]
//  and value evidence$1 of type cats.Monad[F]
//  match expected type cats.Functor[F]
//        def callBar[F[_]: Monad: Traverse]: F[Int] = bar[F]
//                                                        ^
</span></code></pre></div></div>

<p>What do we do? For <code class="language-plaintext highlighter-rouge">map</code> it is easy enough to arbitrarily pick one
of the instances and call <code class="language-plaintext highlighter-rouge">map</code> on that. For function calls you
can thread the implicit through explicitly.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">map</span><span class="o">(</span><span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">))(</span><span class="n">identity</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">callBar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nf">bar</span><span class="o">(</span><span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                       <span class="c1">// or bar(Monad[F], Traverse[F])
</span></code></pre></div></div>

<p>For <code class="language-plaintext highlighter-rouge">foo</code> it’s not <em>too</em> terrible. For <code class="language-plaintext highlighter-rouge">bar</code> though we are
already starting to see it get unwieldy. While we could have passed in
<code class="language-plaintext highlighter-rouge">Monad[F]</code> or <code class="language-plaintext highlighter-rouge">Traverse[F]</code> for the second parameter which corresponds
to <code class="language-plaintext highlighter-rouge">bar</code>’s <code class="language-plaintext highlighter-rouge">Functor[F]</code> constraint, we can only pass in <code class="language-plaintext highlighter-rouge">Monad[F]</code> for
the first parameter to satisfy <code class="language-plaintext highlighter-rouge">Applicative[F]</code>. Because implicit resolution
can’t disambiguate the <code class="language-plaintext highlighter-rouge">Functor[F]</code> by itself we’ve had to pass it in
explicitly, but by doing so we also have to pass in everything else explicitly!
We become the implicit resolver. And this is with just two constraints, what
if we had three, four, five?</p>

<p>And the trouble doesn’t end there. We asked for a <code class="language-plaintext highlighter-rouge">Monad</code> so let’s try using
a for comprehension.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="py">pure</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="c1">// &lt;console&gt;:21: error: value map is not a member of type parameter F[Int]
//          b &lt;- Monad[F].pure(20)
//                            ^
</span></code></pre></div></div>

<p>This is also broken! Because of how <a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html" title="How does yield work?">for comprehensions</a> desugar, a
<code class="language-plaintext highlighter-rouge">map</code> call is inevitable which leads to the for comprehension breaking down.
This drastically reduces the ergonomics of doing anything monadic.</p>

<p>As with <code class="language-plaintext highlighter-rouge">map</code> we could call <code class="language-plaintext highlighter-rouge">flatMap</code> on <code class="language-plaintext highlighter-rouge">Monad</code> directly, but this quickly
becomes cumbersome.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">M</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="nv">M</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="nv">M</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span> <span class="o">{</span> <span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nv">M</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">M</span><span class="o">.</span><span class="py">pure</span><span class="o">(</span><span class="mi">20</span><span class="o">))</span> <span class="o">{</span> <span class="n">b</span> <span class="k">=&gt;</span>
      <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>These same problems arise if you ask for two or more type classes that share a
common superclass. Some examples of this:</p>

<ul>
  <li>Two or more of Monad{Error, Plus, Reader, State, Writer} (ambiguous Monad)
    <ul>
      <li>This prevents ergonomic use of <a href="https://hackage.haskell.org/package/mtl" title="mtl: Monad classes, using functional dependencies">“MTL-style”</a></li>
    </ul>
  </li>
  <li>MonadPlus + Monad (ambiguous Monad)</li>
  <li>Alternative + Traverse (ambiguous Functor)</li>
  <li>MonadRec + MonadPlus (ambiguous Monad)</li>
</ul>

<p>This suggests every type class have only <strong>one</strong> subclass.
That is quite limiting as is readily demonstrated by the extremely useful
<code class="language-plaintext highlighter-rouge">Applicative</code> and <code class="language-plaintext highlighter-rouge">Traverse</code> type classes. What do we do?</p>

<h2 id="solution-">Solution (?)</h2>

<p>This more or less remains an open problem in Scala. There has been
an interesting alternative prototyped in <a href="https://github.com/aloiscochard/scato" title="Scato">scato</a>, now making its way to
<a href="https://github.com/scalaz/scalaz/tree/series/8.0.x" title="Scalaz 8">Scalaz 8</a>, that has received some positive feedback. The gist of the
encoding completely throws out the notion of subtyping, encoding the hierarchy
via members instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// Definitions elided for space
</span><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">applicative</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div></div>

<p>Because there is no relation between the type classes, there is no
danger of implicit ambiguity. However, for that very reason, having a
<code class="language-plaintext highlighter-rouge">Monad[F]</code> no longer implies having a <code class="language-plaintext highlighter-rouge">Functor[F]</code>. Not currently
anyway. What we can do is use implicit conversions to re-encode the
hierarchy.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">applicativeIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">functor</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">traverseIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">functor</span>
</code></pre></div></div>

<p>But now we’re back to square one.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Syntax for Functor
</span><span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:18: error: value map is not a member of type parameter F[Int]
//          implicitly[Applicative[F]].pure(10).map(identity)
//                                              ^
// &lt;console&gt;:18: error: missing argument list for method identity in object Predef
// Unapplied methods are only converted to functions when a function type is expected.
// You can make this conversion explicit by writing `identity _` or `identity(_)` instead of `identity`.
//          implicitly[Applicative[F]].pure(10).map(identity)
//                                                  ^
</span></code></pre></div></div>

<p>Since both implicits have equal priority, the compiler
doesn’t know which one to pick. <strong>However</strong>, Scala has mechanisms for
<a href="http://eed3si9n.com/revisiting-implicits-without-import-tax" title="revisiting implicits without import tax">prioritizing implicits</a> which solves the problem.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Prioritized</span> <span class="o">{</span> <span class="c1">// needed for tut, irrelevant to demonstration
</span>  <span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>

  <span class="c1">// Prioritize implicit conversions - Functor only for brevity
</span>  <span class="k">trait</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">applicativeIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">functor</span>
  <span class="o">}</span>

  <span class="k">trait</span> <span class="nc">FunctorConversions0</span> <span class="k">extends</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">traverseIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">functor</span>
  <span class="o">}</span>

  <span class="k">object</span> <span class="nc">Functor</span> <span class="k">extends</span> <span class="nc">FunctorConversions0</span>

  <span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="k">def</span> <span class="nf">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
  <span class="o">}</span>

  <span class="c1">// Definition elided for space
</span>  <span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

  <span class="c1">// Syntax for Functor
</span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="c1">// we have Applicative
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>    <span class="c1">// we have Traverse
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>     <span class="c1">// we also have Functor!
</span>
    <span class="c1">// and we have syntax!
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Because implicit resolution treats implicits in subtypes with higher priority,
we can organize conversions appropriately to prevent ambiguity. Here this means
that <code class="language-plaintext highlighter-rouge">applicativeIsFunctor</code> has lower priority than <code class="language-plaintext highlighter-rouge">traverseIsFunctor</code>, so
when both <code class="language-plaintext highlighter-rouge">Applicative</code> and <code class="language-plaintext highlighter-rouge">Traverse</code> instances are in scope and the compiler
is looking for a <code class="language-plaintext highlighter-rouge">Functor</code>, <code class="language-plaintext highlighter-rouge">traverseIsFunctor</code> wins.</p>

<p>One thing to note is that we’ve baked the implicit hierarchy into <code class="language-plaintext highlighter-rouge">Functor</code>
itself - in general this means all superclasses are aware of their subclasses.
This is convenient from a usability perspective as companion objects are
considered during implicit resolution, but from a modularity perspective is
strange and in this case would prevent extensions to the hierarchy from external
sources. This can be solved by removing the hierarchy from the superclasses
(removing <code class="language-plaintext highlighter-rouge">Functor</code>’s <code class="language-plaintext highlighter-rouge">extends FunctorConversions0</code>), but comes at
the cost of needing an import at use sites to bring the implicits into scope.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Separate from type class definitions
</span>
<span class="k">trait</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">applicativeIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">functor</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">FunctorConversions0</span> <span class="k">extends</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">traverseIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">functor</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Prelude</span> <span class="k">extends</span> <span class="nc">FunctorConversions0</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Need this import to get implicit conversions in scope
</span><span class="k">import</span> <span class="nn">Prelude._</span>

<span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>

  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Prelude</code> could be provided by the base library, but external libraries
with their own type classes can still extend the hierarchy and provide
their own <code class="language-plaintext highlighter-rouge">Prelude</code>.</p>

<p>A more developed form can be seen in the <a href="https://github.com/scalaz/scalaz/blob/611d69f6b2bff3500181d0338dec9d6143d386ad/base/src/main/scala/BaseHierarchy.scala" title="Scalaz 8 base hierarchy">BaseHierarchy</a> of Scalaz 8.</p>

<p>Do we win? I’m not sure. This encoding is certainly more cumbersome than what
we started with, but solves the problems we ran into.</p>

<h2 id="compromise">Compromise?</h2>

<p>Another thing we can try is to make some compromise of the two. We can
continue to use subtyping for a blessed subset of the hierarchy, and use
members for any branching type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

<span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
</code></pre></div></div>

<p>This works, but is even messier than the alternatives. We have to
decide which type classes get to live in the subtype hierarchy and which are
doomed (blessed?) to express the relationship with members. But maybe the
pros outweigh the cons. Pull requests with this change have been filed for
<a href="https://github.com/typelevel/cats/pull/1379" title="MTL fix for Cats">Cats</a> and <a href="https://github.com/scalaz/scalaz/pull/1262" title="MTL fix for Scalaz">Scalaz 7.3</a>.</p>

<p>I’m not convinced that the story is over though. Maybe there’s another solution
yet to be discovered.</p>

<p>For further reading, there are open tickets for both <a href="https://github.com/typelevel/cats/issues/1210" title="Better accommodate MTL style">Cats</a> and
<a href="https://github.com/scalaz/scalaz/issues/1110" title="MTL-style doesn't seem to work in Scala">Scalaz 7</a> documenting the subtyping problem. A discussion around
the Scato encoding for Scalaz 8 can be found <a href="https://github.com/scalaz/scalaz/issues/1084" title="[scalaz8] Subtyping-free encoding for typeclasses">here</a>.</p>

<p><em>This article was tested with Scala 2.11.8 and Cats 0.7.2 using <a href="https://github.com/tpolecat/tut" title="tut: doc/tutorial generator for scala">tut</a>.</em></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 30 Sep 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html</guid>
      </item>
    
      <item>
        <title>It's programs all the way down</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p><em>This is the first of a series of articles on “Monadic EDSLs in Scala.”</em></p>

<p>Embedded domain specific languages (EDSLs) are a powerful tool for
abstracting complexities such as effects and business logic from our
programs. Instead of mixing ad-hoc error handling, database access, and web
calls through our code, we isolate each domain into a little language. These
little languages can then be used to write “mini-programs” describing, for
example, how to create a web page for a user.</p>

<p>Our program then becomes a composition of mini-programs, and running our
program becomes interpreting these mini-programs into actions. This is
analogous to running an interpreter, itself a program, which turns code
into actions.</p>

<p>The following illustrates what an EDSL might look like in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An embedded program for fetching data for a user
</span><span class="k">def</span> <span class="nf">process</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Page</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">bio</span>  <span class="k">&lt;-</span> <span class="nf">getBio</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
  <span class="n">feed</span> <span class="k">&lt;-</span> <span class="nf">getFeed</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
  <span class="n">page</span> <span class="k">&lt;-</span> <span class="nf">createPage</span><span class="o">(</span><span class="n">bio</span><span class="o">,</span> <span class="n">feed</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">page</span>

<span class="k">def</span> <span class="nf">interpretProgram</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">page</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">page</span><span class="o">.</span><span class="py">interpret</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">GetBio</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>            <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">GetFeed</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>           <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">CreatePage</span><span class="o">(</span><span class="n">bio</span><span class="o">,</span> <span class="n">feed</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">process</code> defines a program in our embedded language.
No action has actually been performed yet, that happens when it gets
interpreted by <code class="language-plaintext highlighter-rouge">interpretProgram</code> and run at runtime.</p>

<p>In many situations a program in one EDSL is translated into another EDSL,
much like a compiler (again another program).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Translate each term of the program into a database call
</span><span class="k">def</span> <span class="nf">compile</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">program</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Database</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">program</span><span class="o">.</span><span class="py">interpret</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">GetBio</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>            <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">GetFeed</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>           <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">CreatePage</span><span class="o">(</span><span class="n">bio</span><span class="o">,</span> <span class="n">feed</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">interpretDatabase</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">Database</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nv">db</span><span class="o">.</span><span class="py">interpret</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>Sometimes you can even optimize programs in an EDSL, much like an optimizing
compiler. In the above example, <code class="language-plaintext highlighter-rouge">interpretDatabase</code> could deduplicate identical
requests and batch requests to the same table.</p>

<p>In this series of articles we will explore a couple approaches to embedding
such DSLs in Scala. These techniques will be evaluated against the following
axes:</p>

<ul>
  <li>
    <p>Abstraction: Separation of <strong>structure</strong> from <strong>interpretation</strong>. Programs
describe only the structure of a computation, to be interpreted later on.
A common use case is to have a live interpreter that queries databases and
API endpoints and a test interpreter that works with in-memory stores.</p>
  </li>
  <li>
    <p>Composition: Given two or more EDSLs, how simple is it to compose them?
Given EDSLs for database access and RPC, can we query for data and send
it over the wire while maintaining the abstraction requirement?</p>
  </li>
  <li>
    <p>Performance: At the end of the day we must run our programs and therefore
interpret our mini-programs. How EDSLs are encoded will affect
how they perform and therefore affect any downstream consumers of our
programs, be it other programs or end users.</p>
  </li>
</ul>

<p>In the <a href="/blog/2016/10/26/edsls-part-2.html">next post</a> we’ll take a look
at the first of these approaches.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/09/21/edsls-part-1.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/09/21/edsls-part-1.html</guid>
      </item>
    
      <item>
        <title>Choosing variance for a phantom type</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>When you use a type parameter to abstract over actual data in your
ADT, there is typically only one
<a href="/blog/2016/02/04/variance-and-functors.html">variance</a> that makes
sense, if you choose to incorporate subtyping into your designs at
all. This is
<a href="/blog/2014/03/09/liskov_lifting.html#parametrically-sound-covariance">the natural, “parametrically sound” variance</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">I</span>, <span class="kt">-T</span>, <span class="kt">+V</span><span class="o">]</span>

<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Running</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">T</span>, <span class="kt">V</span><span class="o">](</span>
  <span class="n">run</span><span class="k">:</span> <span class="o">(</span><span class="kt">I</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">V</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">I</span>, <span class="kt">T</span>, <span class="kt">V</span><span class="o">]</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Inject</span><span class="o">[</span><span class="kt">I</span><span class="o">](</span>
  <span class="n">config</span><span class="k">:</span> <span class="kt">I</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">I</span>, <span class="kt">Any</span>, <span class="kt">Nothing</span><span class="o">]</span>
</code></pre></div></div>

<p>There are only four interesting possibilities, each of which is
illustrated above.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">V</code> occurs in only covariant positions, so can be marked covariant.</li>
  <li><code class="language-plaintext highlighter-rouge">T</code> occurs in only contravariant positions, so can be marked
contravariant.</li>
  <li><code class="language-plaintext highlighter-rouge">I</code> occurs in a pattern that meets neither of standards 1 and 2, so
may only be marked invariant, while still making sense.</li>
  <li><code class="language-plaintext highlighter-rouge">P</code> meets <em>both</em> standards 1 and 2, so…now what?</li>
</ol>

<p>The fourth case is interesting to me, firstly, because the design of
variance in Scala has not accounted for it; it is “phantom”,
<a href="/blog/2016/02/04/variance-and-functors.html#one-more-thing">the missing fourth variance</a>.
I like to write it as I did in
<a href="https://failex.blogspot.com/2016/09/the-missing-diamond-of-scala-variance.html">“The missing diamond of Scala variance”</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">👻P</span>, <span class="kt">I</span>, <span class="kt">-T</span>, <span class="kt">+V</span><span class="o">]</span>
</code></pre></div></div>

<p>Second, and more practically, it illuminates the role of variance in
pattern matching in a way that can be difficult to see with that
confusing data in the way.</p>

<h2 id="it-can-be-covariant">It can be covariant</h2>

<p>The rule for a type parameter being parametrically covariant says we
have to look at all the positions in the data where the type parameter
occurs; if every one of them is a covariant position, then the type
parameter may be marked covariant. Consider a simplified version of
<code class="language-plaintext highlighter-rouge">MyModel</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">AStr</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">AnInt</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>The type parameter <code class="language-plaintext highlighter-rouge">P</code> appears in no positions, so it vacuously
satisfies the requirement “every occurrence is in covariant position”.</p>

<p>So let us mark <code class="language-plaintext highlighter-rouge">P</code> covariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">+P</span><span class="o">]</span>
<span class="c1">// otherwise the same
</span></code></pre></div></div>

<h2 id="it-can-be-contravariant">It can be contravariant</h2>

<p>The rule for contravariance is also based on the occurrences of the
type parameter: if every occurrence is in contravariant position, then
the type parameter may be contravariant.</p>

<p>This rule seems to be contradict the rule for covariance, except that
all “every” statements are always true when the set under
consideration is empty.</p>

<ol>
  <li>Set <strong>S</strong> is empty.</li>
  <li>Every element of set <strong>S</strong> is a dog.</li>
  <li>No element of set <strong>S</strong> is a dog.</li>
</ol>

<p>2 and 3 can be true at the same time, but only if 1 is true, too. So
let us mark <code class="language-plaintext highlighter-rouge">P</code> contravariant, in a renamed ADT.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">-P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">UnStr</span> <span class="k">extends</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">UnInt</span> <span class="k">extends</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="the-usual-relationships">The usual relationships</h2>

<p>Since you can choose any variance for phantom parameters, the
important question is: what kind of type relationships should
exist within my ADT?</p>

<p>At first, this seems to be merely a question of how values of <code class="language-plaintext highlighter-rouge">Gimme</code>
and <code class="language-plaintext highlighter-rouge">Gotme</code> types ought to widen.</p>

<ol>
  <li>Every <code class="language-plaintext highlighter-rouge">Gimme[Cat]</code> is a <code class="language-plaintext highlighter-rouge">Gimme[Animal]</code>, and</li>
  <li>every <code class="language-plaintext highlighter-rouge">Gotme[Animal]</code> is a <code class="language-plaintext highlighter-rouge">Gotme[Cat]</code>. Moreover,</li>
  <li>every <code class="language-plaintext highlighter-rouge">Gimme[Nothing]</code> is a <code class="language-plaintext highlighter-rouge">Gimme[T]</code> no matter what <code class="language-plaintext highlighter-rouge">T</code> is, and</li>
  <li>every <code class="language-plaintext highlighter-rouge">Gotme[Any]</code> is a <code class="language-plaintext highlighter-rouge">Gotme[T]</code> no matter what <code class="language-plaintext highlighter-rouge">T</code> is.</li>
</ol>

<p>Obviously, if neither of these behaviors—the 1/3 nor the 2/4—is
desirable, you shouldn’t use variance. In my experience, this is the
case for most phantom types. If one is desirable, then it may be fine,
but there’s more to consider.</p>

<h2 id="extracting-the-covariant">Extracting the covariant</h2>

<p>Pattern-matching on the covariant <code class="language-plaintext highlighter-rouge">Gimme</code> reveals fully safe type
information. Unlike <code class="language-plaintext highlighter-rouge">ClassTag</code> and <code class="language-plaintext highlighter-rouge">TypeTag</code>, which are egregiously
broken for this use case, this method of carrying type information
forward into runtime is closed and
<a href="https://imgur.com/a04WoHn">Scalazzi</a>-safe.</p>

<p>What type information is revealed?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">P</span><span class="o">,</span> <span class="kt">P</span><span class="o">)</span> <span class="k">=</span> <span class="n">g</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AStr</span> <span class="k">=&gt;</span>
    <span class="c1">// implicitly[P =:= String]   will fail
</span>    <span class="c1">// implicitly[P &lt;:&lt; String]   will fail
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">String</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">P</span><span class="o">]</span>
    <span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="s">"there"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">AnInt</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">84</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If we left <code class="language-plaintext highlighter-rouge">Gimme</code>’s type parameter invariant, all three tests above
would succeed. In the case of this code, on the other hand,</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">AStr.type</code> (the type of <code class="language-plaintext highlighter-rouge">AStr</code>) widens to <code class="language-plaintext highlighter-rouge">Gimme[String]</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">Gimme[String]</code> can widen to <code class="language-plaintext highlighter-rouge">Gimme[P]</code> as long as <code class="language-plaintext highlighter-rouge">P</code> is a
<em>supertype</em> of <code class="language-plaintext highlighter-rouge">String</code>.</li>
</ol>

<p>Because we’re reversing this process, we have to assume that #2 could
have happened.</p>

<p>The expression <code class="language-plaintext highlighter-rouge">("hi", "there")</code> still compiles because <code class="language-plaintext highlighter-rouge">P</code>, while
otherwise mysterious, <em>surely is</em> a supertype of <code class="language-plaintext highlighter-rouge">String</code>. So the two
<code class="language-plaintext highlighter-rouge">String</code>s can widen to <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p>Things do not work out so well for all such functions.</p>

<h2 id="extracting-the-contravariant">Extracting the contravariant</h2>

<p>Matching on the contravariant <code class="language-plaintext highlighter-rouge">Gotme</code> likewise reveals fully safe
type information.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mklength</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Gotme</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">P</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">g</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnStr</span> <span class="k">=&gt;</span>
    <span class="c1">// implicitly[P =:= String]   will fail
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">P</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">String</span><span class="o">]</span>
    <span class="c1">// implicitly[String &lt;:&lt; P]   will fail
</span>    <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">s</span><span class="o">.</span><span class="py">length</span>
  <span class="k">case</span> <span class="nc">UnInt</span> <span class="k">=&gt;</span> <span class="n">identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now <code class="language-plaintext highlighter-rouge">P &lt;:&lt; String</code>, which failed for the covariant form but succeeds
for the contravariant. On the other hand, we lost <code class="language-plaintext highlighter-rouge">String &lt;:&lt; P</code>,
which only works for the covariant form. That’s because</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">UnStr.type</code> widens to <code class="language-plaintext highlighter-rouge">Gotme[String]</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">Gotme[String]</code> can widen to <code class="language-plaintext highlighter-rouge">Gotme[P]</code> as long as <code class="language-plaintext highlighter-rouge">P</code> is a
<em>subtype</em> of <code class="language-plaintext highlighter-rouge">String</code>.</li>
</ol>

<p>In the covariant form, we knew that every <code class="language-plaintext highlighter-rouge">String</code> was a <code class="language-plaintext highlighter-rouge">P</code>. In this
code, we know instead that every <code class="language-plaintext highlighter-rouge">P</code> is a <code class="language-plaintext highlighter-rouge">String</code>. Functions that can
handle any <code class="language-plaintext highlighter-rouge">String</code> are thus able to handle any <code class="language-plaintext highlighter-rouge">P</code>, logically, so the
type <code class="language-plaintext highlighter-rouge">String =&gt; Int</code> widens to <code class="language-plaintext highlighter-rouge">P =&gt; Int</code>.</p>

<h2 id="extracting-the-invariant">Extracting the invariant</h2>

<p><code class="language-plaintext highlighter-rouge">gimme</code> would not work with the contravariant GADT; likewise,
<code class="language-plaintext highlighter-rouge">mklength</code> would not work with the covariant GADT.</p>

<p>An invariant GADT supports both, as well as some supported by
neither. For example, we could produce a <code class="language-plaintext highlighter-rouge">(P, P) =&gt; P</code> from a pattern
match. We can do this because the equivalent of <code class="language-plaintext highlighter-rouge">AStr</code> for invariant
<code class="language-plaintext highlighter-rouge">Gimme</code> tells us <code class="language-plaintext highlighter-rouge">P = String</code>, so all three <code class="language-plaintext highlighter-rouge">implicitly</code> checks
succeed.</p>

<p>From the behavior of pattern matching over these three sorts of GADTs,
I take away two lessons about variance in Scala.</p>

<ol>
  <li>It is impractical to infer variance in Scala, because you cannot
mechanically infer what sort of GADT pattern matching functions
ought to be possible to write.</li>
  <li>The type flexibility of a generic type with variance comes at the
cost of decreased flexibility in pattern-matching
code. <a href="https://en.wikipedia.org/wiki/TANSTAAFL">There ain’t no such thing as a free lunch.</a></li>
</ol>

<h2 id="a-gadt-skolem">A GADT skolem</h2>

<p>The “reverse widening” of pattern matching lifts the veil on one of
the more confusing references in type errors, a “GADT skolem”.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">uncons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">::</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">c</span><span class="o">@(</span><span class="k">_</span> <span class="o">::</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
  <span class="c1">//                      ↑
</span>  <span class="c1">// [error] type mismatch;
</span>  <span class="c1">//  found   : ::[?A1] where type ?A1 &lt;: A
</span>  <span class="c1">//            (this is a GADT skolem)
</span>  <span class="c1">//  required: ::[A]
</span>  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>These “GADT skolems” appear all the time in sensible, compiling
code. Take a <code class="language-plaintext highlighter-rouge">List</code> with some variance carelessly tossed in.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MyCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">MyNil</span> <span class="k">extends</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</code></pre></div></div>

<p>Constructing <code class="language-plaintext highlighter-rouge">MyCons[String]</code>, here’s what can happen.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">MyCons[String]</code> widens to <code class="language-plaintext highlighter-rouge">MyList[String]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">MyList[String]</code> can widen to <code class="language-plaintext highlighter-rouge">MyList[U]</code> for any supertype <code class="language-plaintext highlighter-rouge">U</code> of
<code class="language-plaintext highlighter-rouge">String</code>.</li>
</ol>

<p>So in this code, we cannot reverse <code class="language-plaintext highlighter-rouge">MyList[A]</code> down to
<code class="language-plaintext highlighter-rouge">MyCons[A]</code>. But we <em>can</em> get <code class="language-plaintext highlighter-rouge">MyList[L]</code>, where <code class="language-plaintext highlighter-rouge">L</code> is an otherwise
mysterious subtype of <code class="language-plaintext highlighter-rouge">A</code>. <code class="language-plaintext highlighter-rouge">L</code> is the GADT skolem, similar to <code class="language-plaintext highlighter-rouge">?A1</code> in
the above compiler error. The difference is that this code compiles.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">drop1</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">MyNil</span> <span class="k">=&gt;</span> <span class="nc">MyNil</span>
    <span class="k">case</span> <span class="nc">MyCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">tl</span>
    <span class="c1">// tl: MyList[L]  (L is a GADT skolem)
</span>    <span class="c1">// L &lt;: A, therefore
</span>    <span class="c1">// MyList[L] &lt;: MyList[A] by covariance
</span>  <span class="o">}</span>
</code></pre></div></div>

<h2 id="mylists-type-parameter-is-a-phantom"><code class="language-plaintext highlighter-rouge">MyList</code>’s type parameter is a phantom</h2>

<p>We saw earlier that variance has a strong influence on the usability
of pattern matching. <code class="language-plaintext highlighter-rouge">MyList</code> has something important in common with
<code class="language-plaintext highlighter-rouge">Gimme</code>: the class definition does not use <code class="language-plaintext highlighter-rouge">A</code>, it only <em>defines</em>
it. So the scalac-enforced variance rules do not apply, and we can
make <code class="language-plaintext highlighter-rouge">MyList</code> contravariant instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">BadCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BadNil</span> <span class="k">extends</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
</code></pre></div></div>

<p>Curiously, <code class="language-plaintext highlighter-rouge">drop1</code> still works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">baddrop1</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">BadNil</span> <span class="k">=&gt;</span> <span class="nc">BadNil</span>
    <span class="k">case</span> <span class="nc">BadCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">tl</span>
    <span class="c1">// tl: BadList[U]  (U is a GADT skolem)
</span>    <span class="c1">// A &lt;: U, therefore
</span>    <span class="c1">// BadList[U] &lt;: BadList[A] by contravariance
</span>  <span class="o">}</span>
</code></pre></div></div>

<p>Other obvious functions will not work for non-obvious reasons.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">badHeadOption</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">BadNil</span> <span class="k">=&gt;</span> <span class="nc">None</span>
    <span class="k">case</span> <span class="nc">BadCons</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">hd</span><span class="o">)</span>
    <span class="c1">// [error] type mismatch;   ↑
</span>    <span class="c1">//  found   : hd.type (with underlying type Any)
</span>    <span class="c1">//  required: A
</span>  <span class="o">}</span>
</code></pre></div></div>

<p>This fails because the skolem from a contravariant parameter is a
supertype instead of subtype. So</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">hd: U</code> (<code class="language-plaintext highlighter-rouge">U</code> is a GADT skolem),</li>
  <li><code class="language-plaintext highlighter-rouge">A &lt;: U</code>,</li>
  <li>we’re stuck; there is no <code class="language-plaintext highlighter-rouge">A</code> value.</li>
</ol>

<p>This is not to imply something as silly as “covariance good,
contravariance bad”; you can just as well get these errors by marking
a parameter covariant that can only meaningfully be marked
contravariant. If anything, contravariance is more important than
covariance. The problem you must face is that the compiler is less
helpful in determining what “meaningful” marking, if any, should be
applied.</p>

<p><code class="language-plaintext highlighter-rouge">MyModel</code>, from the beginning of this article, demonstrates three
situations in which each supported variance is natural. You may use it
as a guide, but its sanity is not compiler-checked. Your variances’
sanity, or lack thereof, only becomes apparent when implementing
practical functions over a datatype.</p>

<h2 id="extracting-the-phantom">Extracting the phantom</h2>

<p>Suppose the phantom variance was defined, and we revisit the
<code class="language-plaintext highlighter-rouge">String</code>-and-<code class="language-plaintext highlighter-rouge">Int</code> GADT one more time.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">👻P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">BooStr</span> <span class="k">extends</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BooInt</span> <span class="k">extends</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>The trouble with letting the compiler infer covariance or
contravariance is that, on the face of it, either is as good as the
other. With phantom, we choose both.</p>

<p>But this variance makes the GADT utterly useless. Consider how
<code class="language-plaintext highlighter-rouge">BooStr</code> becomes <code class="language-plaintext highlighter-rouge">BooGimme[P]</code>.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">BooStr</code> widens to <code class="language-plaintext highlighter-rouge">BooGimme[String]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">BooGimme[String]</code> can widen to <code class="language-plaintext highlighter-rouge">BooGimme[P]</code> where <code class="language-plaintext highlighter-rouge">P</code> is…oops,
there are no conditions this time! <code class="language-plaintext highlighter-rouge">P</code> can be anything at all and
the widen will still work.</li>
</ol>

<p>The match tells us nothing about the type parameter; all three of the
type relationship checks via <code class="language-plaintext highlighter-rouge">implicitly</code> from the examples above
fail. We maximize the flexibility of the type parameter at the cost of
making GADT pattern matching impossible.</p>

<p>Likewise, if you mark <code class="language-plaintext highlighter-rouge">MyList[A]</code>’s type parameter phantom, there are
no bounds on the GADT skolem, so there’s little you can do with the
elements of the list.</p>

<h2 id="the-case-for-choosing-no-variance">The case for choosing no variance</h2>

<p>My <code class="language-plaintext highlighter-rouge">scalac</code> error message pet peeve is the one suggesting that you
should add a variance annotation. This message treats the addition of
variance like a mechanical change: “if it compiles, it works”. On the
contrary, we have seen that</p>

<ol>
  <li>The flexibility of variance costs flexibility elsewhere;</li>
  <li>the compiler cannot predict how this might harm your APIs’
practicality;</li>
  <li>the semantics of pattern matching are more complex in the face of
variance.</li>
</ol>

<p>Even if variance is applicable to your datatype, these costs, and the
cost of the additional complexity burden, should give you pause. Yet,
I stand by the claim I made in “The missing diamond
of Scala variance”: subtyping is incomplete without variance, so if
variance is too complicated, so is subtyping.</p>

<p>I don’t think subtyping—and its necessary component, variance—are too
complex for the working programmer to understand. Indeed, it can be a
fascinating exercise, with plenty of practical implications.</p>

<p>But, to me, the consequence of working out such exercises is that
neither variance nor subtyping ought to be used in the design of
practical programs, especially when higher-kinded type parameters and
members are available, offering far more flexibility at a better
price. There is no need to struggle in the face of all-too-often
missing features.</p>

<p><em>This article was tested with Scala 2.11.8.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 19 Sep 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/09/19/variance-phantom.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/09/19/variance-phantom.html</guid>
      </item>
    
      <item>
        <title>Higher-kinded types: the difference between giving up, and moving forward</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>As its opening sentence reminds the reader—a point often missed by
many reviewers—the book
<a href="https://www.manning.com/books/functional-programming-in-scala"><em>Functional Programming in Scala</em></a>
is not a book about Scala. This [wise] choice occasionally manifests
in peculiar ways.</p>

<p>For example, you can go quite far into the book implementing its
exercises in languages with simpler type systems. Chapters 1–8 and 10
port quite readily to
<a href="https://github.com/sbordet/fpinscala-jdk8">Java [8]</a> and C#. So
<em>Functional Programming in Scala</em> can be a very fine resource for
learning some typed functional programming, even if such languages are
all you have to work with. Within these chapters, you can remain
blissfully unaware of the limitations imposed on you by these
languages’ type systems.</p>

<p>However, there is a point of inflection in the book at chapter 11. You
can pass through with a language such as <a href="https://ocaml.org/">OCaml</a>,
Scala, Haskell, <a href="http://www.purescript.org/">PureScript</a>, or one of a
few others. However, users of Java, C#, F#,
<a href="http://elm-lang.org/">Elm</a>, and many others may proceed no further,
and must turn back here.</p>

<p><img src="/img/media/hkt-inflection.png" alt="Various languages' chapter 11 support" /></p>

<p>Here is where abstracting over type constructors, or “higher-kinded
types”, comes into play. At this point in the book, you can give up,
or proceed with a sufficiently powerful language. Let’s see how this
happens.</p>

<h2 id="functional-combinators">Functional combinators</h2>

<p>The bread and butter of everyday functional programming, the
“patterns” if you like, is the implementation of standard functional
combinators for your datatypes, and more importantly the comfortable,
confident use of these combinators in your program.</p>

<p>For example, confidence with <code class="language-plaintext highlighter-rouge">bind</code>, also known as <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> or <code class="language-plaintext highlighter-rouge">flatMap</code>,
is very important. The best way to acquire this comfort is to
reimplement it a bunch of times, so <em>Functional Programming in Scala</em>
has you do just that.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="c1">// in List[A]
</span><span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="c1">// in Option[A]
</span><span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="c1">// in Either[E, A]
</span><span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span> <span class="c1">// in State[S, A]
</span></code></pre></div></div>

<h2 id="all-flatmaps-are-the-same">All <code class="language-plaintext highlighter-rouge">flatMap</code>s are the same</h2>

<p>The similarity between these functions’ types is the most obvious
surfacing of their ‘sameness’. (Unless you wish to count their names,
which I do not.) That sameness is congruent: when you write functions
using <code class="language-plaintext highlighter-rouge">flatMap</code>, in any of the varieties above, these functions
inherit a sort of sameness from the underlying <code class="language-plaintext highlighter-rouge">flatMap</code> combinator.</p>

<p>For example, supposing we have <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code> for a type, we can
‘tuple’ the values within.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tuple</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nv">as</span><span class="o">.</span><span class="py">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nv">bs</span><span class="o">.</span><span class="py">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
    
<span class="k">def</span> <span class="nf">tuple</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nv">as</span><span class="o">.</span><span class="py">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nv">bs</span><span class="o">.</span><span class="py">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
    
<span class="k">def</span> <span class="nf">tuple</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nv">as</span><span class="o">.</span><span class="py">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nv">bs</span><span class="o">.</span><span class="py">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
    
<span class="k">def</span> <span class="nf">tuple</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nv">as</span><span class="o">.</span><span class="py">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nv">bs</span><span class="o">.</span><span class="py">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
</code></pre></div></div>

<p><em>Functional Programming in Scala</em> contains several such functions,
such as <code class="language-plaintext highlighter-rouge">sequence</code>. These are each implemented for several types, each
time with potentially the same code, if you remember to look back and
try copying and pasting a previous solution.</p>

<h2 id="to-parameterize-or-not-to-parameterize">To parameterize, or not to parameterize</h2>

<p>In programming, when we encounter such great sameness—not merely
similar code, but <em>identical</em> code—we would like the opportunity to
<em>parameterize</em>: extract the parts that are different to arguments, and
recycle the common code for all situations.</p>

<p>In <code class="language-plaintext highlighter-rouge">tuple</code>’s case, what is different are</p>

<ol>
  <li>the <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">map</code> implementations, and</li>
  <li>the <strong>type constructor</strong>: <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Option</code>, <code class="language-plaintext highlighter-rouge">State[S, ...]</code>, what
have you.</li>
</ol>

<p>We have a way to pass in implementations; that’s just higher-order
functions, or ‘functions as arguments’. For the type constructor, we
need ‘type-level functions as arguments’.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tuplef</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>We’ve handled ‘type constructor as argument’, and will add the
<code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">map</code> implementations in a moment. First, let’s learn
how to read this.</p>

<h2 id="reading-a-higher-kinded-type">Reading a higher-kinded type</h2>

<p>Confronted with a type like this, it’s helpful to sit back and muse on
the nature of a function for a moment.</p>

<p>Functions are given meaning by substitution of their arguments.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">double</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">double</code> remains “an abstraction” until we <em>substitute for x</em>; in
other words, pass an argument.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>double(2)    double(5)
2 + 2        5 + 5
4            10
</code></pre></div></div>

<p>But this isn’t enough to tell us <em>what <code class="language-plaintext highlighter-rouge">double</code> is</em>; all we see from
these tests is that <code class="language-plaintext highlighter-rouge">double</code> sometimes returns 4, sometimes 10,
sometimes maybe other things. We must imagine what <code class="language-plaintext highlighter-rouge">double</code> does in
common <em>for all possible arguments</em>.</p>

<p>Likewise, we give meaning to type-parameterized definitions like
<code class="language-plaintext highlighter-rouge">tuplef</code> by substitution. The parameter declaration <code class="language-plaintext highlighter-rouge">F[_]</code> means that
<code class="language-plaintext highlighter-rouge">F</code> may not be a simple type, like <code class="language-plaintext highlighter-rouge">Int</code> or <code class="language-plaintext highlighter-rouge">String</code>, but instead a
one-argument type constructor, like <code class="language-plaintext highlighter-rouge">List</code> or <code class="language-plaintext highlighter-rouge">Option</code>. Performing
these substitutions for <code class="language-plaintext highlighter-rouge">tuplef</code>, we get</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// original, as above
</span><span class="k">def</span> <span class="nf">tuplef</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

<span class="c1">// F = List
</span><span class="k">def</span> <span class="nf">tupleList</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

<span class="c1">// F = Option
</span><span class="k">def</span> <span class="nf">tupleOpt</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>More complicated and powerful cases are available with other kinds of
type constructors, such as by partially applying. That’s how we can
fit <code class="language-plaintext highlighter-rouge">State</code>, <code class="language-plaintext highlighter-rouge">Either</code>, and other such types with two or more
parameters into the <code class="language-plaintext highlighter-rouge">F</code> parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// F = Either[E, ...]
</span><span class="k">def</span> <span class="nf">tupleEither</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span>
    <span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

<span class="c1">// F = State[S, ...]
</span><span class="k">def</span> <span class="nf">tupleState</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span>
    <span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>Just as with <code class="language-plaintext highlighter-rouge">double</code>, though this isn’t the whole story of <code class="language-plaintext highlighter-rouge">tuplef</code>,
its true meaning arises from the common way in which it treats <em>all
possible</em> <code class="language-plaintext highlighter-rouge">F</code> arguments. That is where higher kinds start to get
interesting.</p>

<h2 id="implementing-functions-with-higher-kinded-type">Implementing functions with higher-kinded type</h2>

<p>The type of <code class="language-plaintext highlighter-rouge">tuplef</code> expresses precisely our intent—the idea of
“multiplying” two <code class="language-plaintext highlighter-rouge">F</code>s, tupling the values within—but cannot be
implemented as written. That’s because we don’t have functions that
operate on <code class="language-plaintext highlighter-rouge">F</code>-constructed values, like <code class="language-plaintext highlighter-rouge">fa: F[A]</code> and <code class="language-plaintext highlighter-rouge">fb: F[B]</code>. As
with any value of an ordinary type parameter, these are opaque.</p>

<p>In Scala, there are a few ways to pass in the necessary functions. One
option is to implement a <code class="language-plaintext highlighter-rouge">trait</code> or <code class="language-plaintext highlighter-rouge">abstract class</code> that itself uses
a higher-kinded type parameter or abstract type constructor. Here are
a couple possibilities.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Bindable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">BindableTM</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that we must use higher-kinded trait type signatures to support
our higher-kinded method types; otherwise, we can’t write the return
types for <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">BindableBad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">???</span>
            <span class="c1">// where is the B supposed to go?
</span></code></pre></div></div>

<p>Now we make every type we’d like to support either inherit from or
implicitly convert to <code class="language-plaintext highlighter-rouge">Bindable</code>, such as <code class="language-plaintext highlighter-rouge">List[+A] extends
Bindable[List, A]</code>, and write <code class="language-plaintext highlighter-rouge">tuplef</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tupleBindable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Bindable</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Bindable</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">])</span>
    <span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nv">fa</span><span class="o">.</span><span class="py">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nv">fb</span><span class="o">.</span><span class="py">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
</code></pre></div></div>

<h2 id="escaping-two-bad-choices">Escaping two bad choices</h2>

<p>There are two major problems with <code class="language-plaintext highlighter-rouge">Bindable</code>’s representation of <code class="language-plaintext highlighter-rouge">map</code>
and <code class="language-plaintext highlighter-rouge">flatMap</code>, ensuring its wild unpopularity in the Scala functional
community, though it still appears in some places, such as
<a href="https://github.com/ermine-language/ermine-parser/blob/cc77bf6e150a16129744d18d69022f7b5902814f/src/main/scala/scalaparsers/Monadic.scala">in Ermine</a>.</p>

<ol>
  <li>The choices of inheritance and implicit conversion are both bad in
different ways. Implicit conversion propagates very poorly—it
doesn’t compose, after all, and fails as soon as we do something
innocent like put the value-to-be-converted into a tuple.
Inheritance leaves its own mess: modifying a type to add new,
nonessential operations, and the weird way that <code class="language-plaintext highlighter-rouge">F</code> is declared in
the method type parameters above.</li>
  <li>The knowledge required to work out the new type signature above is
excessively magical. There are rules about when implicit conversion
happens, how much duplication of the reference to <code class="language-plaintext highlighter-rouge">Bindable</code> is
required to have the <code class="language-plaintext highlighter-rouge">F</code> parameter infer correctly, and even how
many calls to <code class="language-plaintext highlighter-rouge">Bindable</code> methods are performed. For example, we’d
have to declare the <code class="language-plaintext highlighter-rouge">F</code> parameter as <code class="language-plaintext highlighter-rouge">F[X] &lt;: Bindable[F, X]</code> if we
did one more trailing <code class="language-plaintext highlighter-rouge">map</code> call. But then we wouldn’t support
implicit conversion cases anymore, so we’d have to do something
else, too.</li>
</ol>

<p>As a result of all this magic, generic functions over higher kinds
with OO-style operations tend to be ugly; note how much <code class="language-plaintext highlighter-rouge">tuplef</code>
looked like the <code class="language-plaintext highlighter-rouge">List</code>-specific type, and how little <code class="language-plaintext highlighter-rouge">tupleBindable</code>
looks like either of them.</p>

<p>But we still really, really want to be able to write this kind of
generic function. Luckily, we have a Wadler-made alternative.</p>

<h2 id="typeclasses-constrain-higher-kinded-types-elegantly">Typeclasses constrain higher-kinded types elegantly</h2>

<p>To constrain <code class="language-plaintext highlighter-rouge">F</code> to types with the <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">map</code> we need, we use
typeclasses instead. For <code class="language-plaintext highlighter-rouge">tuplef</code>, that means we leave <code class="language-plaintext highlighter-rouge">F</code> abstract,
and leave the types of <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> as well as the return type
unchanged, but add an implicit argument, the “typeclass instance”,
which is a first-class representation of the <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code>
operations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Bind</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// note the new ↓ fa argument
</span>  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then we define instances for the types we’d like to have this on:
<code class="language-plaintext highlighter-rouge">Bind[List]</code>, <code class="language-plaintext highlighter-rouge">Bind[Option]</code>, and so on, as seen in chapter 11 of
<em>Functional Programming in Scala</em>.</p>

<p>Now we just add the argument to <code class="language-plaintext highlighter-rouge">tuplef</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tupleTC</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
           <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Bind</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nv">F</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">){</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="nv">F</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
</code></pre></div></div>

<p>We typically mirror the typeclass operations back to methods with an
implicit conversion—unlike with <code class="language-plaintext highlighter-rouge">Bindable</code>, this has no effect on
exposed APIs, so is benign. Then, we can remove the <code class="language-plaintext highlighter-rouge">implicit F</code>
argument, replacing it by writing <code class="language-plaintext highlighter-rouge">F[_]: Bind</code> in the type argument
list, and write the method body as it has been written before, with
<code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">map</code> methods.</p>

<p>There’s another major reason to prefer typeclasses, but let’s get back
to <em>Functional Programming in Scala</em>.</p>

<h2 id="getting-stuck">Getting stuck</h2>

<p>I’ve just described many of the practical mechanics of writing useful
functions that abstract over type constructors, but <em>all this is moot
if you cannot abstract over type constructors</em>. The fact that Java
provides no such capability is not an indicator that they have
sufficient abstractions to replace this missing feature: it is simply
an abstraction that they do not provide you.</p>

<p><strong>Oh, you would like to factor this common code? Sorry, you are
stuck. You will have to switch languages if you wish to proceed.</strong></p>

<h2 id="dont-get-stuck-on-the-second-order">Don’t get stuck on the second order</h2>

<p><code class="language-plaintext highlighter-rouge">map</code> functions are obvious candidates for essential parts of a usable
library for functional programming. This is the first-order
abstraction—it eliminates the concrete loops, recursive functions,
or <code class="language-plaintext highlighter-rouge">State</code> lambda specifications, you would need to write otherwise.</p>

<p>When we note a commonality in patterns and define an abstraction over
that commonality, we move “one order up”. When we stopped simply
defining functions, and started taking functions as arguments, we
moved from the first order to the second order.</p>

<p>It is not enough for a modern general-purpose functional library in
Scala to simply have a bunch of <code class="language-plaintext highlighter-rouge">map</code> functions. It must also provide
the second-order feature: the ability to <em>abstract over</em> <code class="language-plaintext highlighter-rouge">map</code>
functions, as well as many, many other functions numerous type
constructors have in common. Let’s not give up; let’s move forward.</p>

<p><em>This article was tested with Scala 2.11.7 and
<a href="https://github.com/fpinscala/fpinscala">fpinscala</a> 5b0115a answers,
with the addition of the method variants of <code class="language-plaintext highlighter-rouge">List#map</code> and
<code class="language-plaintext highlighter-rouge">List#flatMap</code>.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 21 Aug 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html</guid>
      </item>
    
      <item>
        <title>Making internal state functional</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the ninth of a series of articles on “Type Parameters and
Type Members”.</em></p>

<p>Scala’s
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/generic/CanBuildFrom.html"><code class="language-plaintext highlighter-rouge">CanBuildFrom</code> API</a>
is relatively well-founded and flexible;
<a href="https://bitbucket.org/S11001001/record-map#markdown-header-using-gadts-to-find-fast-paths-safely">in combination with GADTs, it can provide that flexibility in a fully type-safe way</a>,
if users choose not to circumvent it with typecasting.</p>

<p>However, it is designed in a purely mutable way; you cannot write a
useful <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> that does not rely on mutation, and you cannot
use the API externally in a functional way.</p>

<p>Let’s design an alternative to <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> that makes sense in a
purely functional context, allowing both implementers and users to
avoid unsightly mutation.</p>

<p>Spoiler warning! Our first pass will have one glaring inelegance. We
will use concepts from previous articles in <em>Type Parameters and Type
Members</em> to “invert the abstraction”, which will greatly simplify the
design. Once you’re comfortable with the “inversion”, you can skip the
intermediate step and use this technique directly in your own designs.</p>

<h2 id="disallowing-functional-approaches">Disallowing functional approaches</h2>

<p>The pattern of use of <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> is</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">apply</code> the CBF to produce a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/mutable/Builder.html"><code class="language-plaintext highlighter-rouge">Builder</code></a>.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">+=</code> and <code class="language-plaintext highlighter-rouge">++=</code> methods to “fill up” the <code class="language-plaintext highlighter-rouge">Builder</code>.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">result</code> to “finalize” or “commit” to the final structure.</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">collection.generic.CanBuildFrom</span>

<span class="k">val</span> <span class="nv">cbf</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">Int</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
<span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="nf">cbf</span><span class="o">()</span>
<span class="n">b</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="nv">b</span><span class="o">.</span><span class="py">result</span><span class="o">()</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s set aside that this is only suited to eager collections, not
lazy ones like
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/Stream.html"><code class="language-plaintext highlighter-rouge">Stream</code></a>. You
can tell the problem by types: <code class="language-plaintext highlighter-rouge">+=</code> and <code class="language-plaintext highlighter-rouge">++=</code> have the return type
<code class="language-plaintext highlighter-rouge">this.type</code>. Effectively, this means that if their implementations are
purely functional, all they can do is return <code class="language-plaintext highlighter-rouge">this</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="nf">++=</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span> <span class="k">=</span> <span class="k">this</span>
</code></pre></div></div>

<p>Aside from the informal contract of <code class="language-plaintext highlighter-rouge">Builder</code>, which suggests that
calls to these methods perform a side effect, the types enforce that
they <em>must</em> perform any useful work by means of side effects.</p>

<p>Returning <code class="language-plaintext highlighter-rouge">this.type</code> permits these methods to be called in a
superficially functional style:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="o">.+=(</span><span class="mi">3</span><span class="o">)</span>
 <span class="o">.++=(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
 <span class="o">.</span><span class="py">result</span><span class="o">()</span>

<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>This retouch is only skin-deep, and can’t repair the defect making
<code class="language-plaintext highlighter-rouge">CanBuildFrom</code> unsuitable for functional programs, but it implies that
a functional alternative lurks nearby. Let’s go looking for it.</p>

<h2 id="step-1-explicit-builder-state">Step 1: explicit <code class="language-plaintext highlighter-rouge">Builder</code> state</h2>

<p>First, we need to take the essential mutation out of <code class="language-plaintext highlighter-rouge">Builder</code>. That
means it needs to provide an initial state, and the other methods must
use it as a parameter and return value.</p>

<ol>
  <li>We’ll add a new method to return the initial state.</li>
  <li><code class="language-plaintext highlighter-rouge">+=</code> and <code class="language-plaintext highlighter-rouge">++=</code> will take that state as an argument, returning the
new state instead of <code class="language-plaintext highlighter-rouge">this.type</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">result</code> will take the final state as an argument, still producing
the result collection.</li>
</ol>

<p>While the intermediate state <em>might</em> be the same as the final state,
we don’t want to require that. So <code class="language-plaintext highlighter-rouge">Builder</code> also gains a type
parameter to represent the type of state, <code class="language-plaintext highlighter-rouge">S</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** Produce the initial state. */</span>
  <span class="k">def</span> <span class="nf">init</span><span class="k">:</span> <span class="kt">S</span>

  <span class="c1">// note everywhere 'S' was added
</span>  <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="nf">++=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="nf">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">To</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="a-sample-funbuilder">A sample <code class="language-plaintext highlighter-rouge">FunBuilder</code></h2>

<p>We can incrementally build a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/Vector.html"><code class="language-plaintext highlighter-rouge">Vector</code></a>,
but it may not be the most efficient way. Instead, let’s try to
accumulate a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/List.html"><code class="language-plaintext highlighter-rouge">List</code></a>,
then construct the <code class="language-plaintext highlighter-rouge">Vector</code> once we’re done.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nf">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">elem</span> <span class="o">::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="nf">++=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="nv">elems</span><span class="o">.</span><span class="py">toList</span> <span class="n">reverse_:::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="nf">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">toVector</span><span class="o">.</span><span class="py">reverse</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">vbl</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="nv">vbl</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">vbl</span><span class="o">.++=(</span><span class="n">vbl</span><span class="o">.+=(</span><span class="nv">vbl</span><span class="o">.</span><span class="py">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>(There’s a problem with <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> now, but we’ll hold off fixing
it.)</p>

<h2 id="a-slightly-different-builder">A slightly different Builder</h2>

<p>Maybe it would be better to optimize for the <code class="language-plaintext highlighter-rouge">++=</code> “bulk add” method,
though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]],</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Traversable</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="nf">++=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="nv">elems</span><span class="o">.</span><span class="py">toTraversable</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="nf">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="k">=</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]()){(</span><span class="n">z</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">as</span> <span class="o">++:</span> <span class="n">z</span><span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">vbll</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="nv">vbll</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">vbll</span><span class="o">.++=(</span><span class="n">vbll</span><span class="o">.+=(</span><span class="nv">vbll</span><span class="o">.</span><span class="py">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="hide-your-state">Hide your state</h2>

<p>The type of these builders are different, even though their usage is
the same. This design also exposes what was originally <em>internal</em>
state as part of the API. Luckily, <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> makes a point of
this when we try to integrate <code class="language-plaintext highlighter-rouge">FunBuilder</code> into our own CBF version;
there’s nowhere to put the <code class="language-plaintext highlighter-rouge">S</code> type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
<span class="o">}</span>

<span class="err">…</span><span class="o">/</span><span class="nv">FCBF</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">42</span><span class="kt">:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="k">type</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
                          <span class="o">^</span>
</code></pre></div></div>

<p>We can hide the state by forcing the caller to deal with the builder
in a state-generic context. One way to do this is with a generic
continuation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">BuilderCont</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">-To</span>, <span class="kt">+Z</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">continue</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">builder</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">])</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="c1">// in FunCanBuildFrom...
</span>  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">cont</span><span class="k">:</span> <span class="kt">BuilderCont</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span>, <span class="kt">Z</span><span class="o">])</span><span class="k">:</span> <span class="kt">Z</span>
</code></pre></div></div>

<p>Now we can implement a <code class="language-plaintext highlighter-rouge">FunCanBuildFrom</code> that can use either of the
<code class="language-plaintext highlighter-rouge">FunBuilder</code>s we’ve defined.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">bulkOptimized</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">cont</span><span class="k">:</span> <span class="kt">BuilderCont</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Z</span><span class="o">])</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">bulkOptimized</span><span class="o">)</span>
      <span class="n">cont</span> <span class="nf">continue</span> <span class="o">(</span><span class="k">new</span> <span class="nc">VectorBuilderListList</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">cont</span> <span class="nf">continue</span> <span class="o">(</span><span class="k">new</span> <span class="nc">VectorBuilderList</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Take a look at the type flow. The caller of <code class="language-plaintext highlighter-rouge">apply</code> is the one who
decides the <code class="language-plaintext highlighter-rouge">Z</code> type. But the <code class="language-plaintext highlighter-rouge">apply</code> implementation chooses the <code class="language-plaintext highlighter-rouge">S</code>
to pass to <code class="language-plaintext highlighter-rouge">continue</code>, which cannot know any more about what that
state type is. (It can even choose different types based on runtime
decisions.) Information hiding is restored.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">cbf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="kc">true</span><span class="o">)</span>
<span class="n">cbf</span><span class="o">{</span><span class="k">new</span> <span class="nc">BuilderCont</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">continue</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">vbl</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Int</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span>
    <span class="nv">vbl</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">vbl</span><span class="o">.++=(</span><span class="n">vbl</span><span class="o">.+=(</span><span class="nv">vbl</span><span class="o">.</span><span class="py">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>
<span class="o">}}</span>

<span class="n">res1</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Now the code using the <code class="language-plaintext highlighter-rouge">FunBuilder</code> can’t fiddle with the
<code class="language-plaintext highlighter-rouge">FunBuilder</code>’s state values; it can only rewind to previously seen
states, a norm to be expected in functional programming with
persistent state values.</p>

<h2 id="existential-types-are-abstraction-inversion">Existential types are abstraction inversion</h2>

<p>This is rather a lot of inconvenient ceremony, though. Instead of
passing a continuation that receives the <code class="language-plaintext highlighter-rouge">S</code> type as an argument along
with the <code class="language-plaintext highlighter-rouge">FunBuilder</code>, let’s just have <code class="language-plaintext highlighter-rouge">apply</code> return the type along
with the <code class="language-plaintext highlighter-rouge">FunBuilder</code>. We have a tool for returning a pair of type and
value using that type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="k">_</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
</code></pre></div></div>

<p>Remember that existential types are pairs.</p>

<p>Having collapsed callee-of-callee back to caller perspective, let’s
apply the rule of thumb from
<a href="/blog/2015/07/13/type-members-parameters.html">the first post in this series</a>.</p>

<blockquote>
  <p>A type parameter is usually more convenient and harder to screw up, but if you intend to use it existentially in most cases, changing it to a member is probably better.</p>
</blockquote>

<p>The usual case will be from the perspective of a CBF user, so the
usual use of the <code class="language-plaintext highlighter-rouge">S</code> parameter is existential. So let’s turn it into
the equivalent type member.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// rewrite the heading of FunBuilder as
</span><span class="k">trait</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span>
  
<span class="c1">// and FunCanBuildFrom#apply as
</span>  <span class="k">def</span> <span class="nf">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>

<span class="c1">// and the parameter S moves to a member
// for all implementations so far;
// fix until compile or see appendix
</span></code></pre></div></div>

<p>And we can see the information stays hidden.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">cbf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="kc">true</span><span class="o">)</span>
<span class="n">cbf</span><span class="k">:</span> <span class="kt">fcbf.VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">fcbf</span><span class="o">.</span><span class="py">VectorCBF</span><span class="k">@</span><span class="mi">4363</span><span class="n">e2ba</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">vb</span> <span class="k">=</span> <span class="nf">cbf</span><span class="o">()</span>
<span class="n">vb</span><span class="k">:</span> <span class="kt">fcbf.FunBuilder</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">fcbf</span><span class="o">.</span><span class="py">VectorBuilderListList</span><span class="k">@</span><span class="mi">527</span><span class="n">c222e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">with1</span> <span class="k">=</span> <span class="n">vb</span><span class="o">.+=(</span><span class="nv">vb</span><span class="o">.</span><span class="py">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">with1</span><span class="k">:</span> <span class="kt">vb.S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">with2</span> <span class="k">=</span> <span class="n">vb</span><span class="o">.++=(</span><span class="n">with1</span><span class="o">,</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">with2</span><span class="k">:</span> <span class="kt">vb.S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">vb</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">with2</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p>As in
<a href="/blog/2015/07/30/values-never-change-types.html#naming-the-existential">“Values never change types”</a>,
<code class="language-plaintext highlighter-rouge">vb.S</code> is abstract, existential, irreducible.</p>

<h2 id="last-minute-adjustments">Last minute adjustments</h2>

<p><code class="language-plaintext highlighter-rouge">Builder</code> had to be separate from <code class="language-plaintext highlighter-rouge">CanBuildFrom</code> because the latter
had to be stateless, with <code class="language-plaintext highlighter-rouge">Builder</code> needing to be stateful. Now that
both are stateless, the <code class="language-plaintext highlighter-rouge">FunBuilder</code> API can probably be collapsed
into <code class="language-plaintext highlighter-rouge">FunCanBuildFrom</code>.</p>

<p>This leaves the question, what about the mutable-state <code class="language-plaintext highlighter-rouge">Builder</code>s?
They can mutate the <code class="language-plaintext highlighter-rouge">S</code>, returning the input state from <code class="language-plaintext highlighter-rouge">+=</code> and
<code class="language-plaintext highlighter-rouge">++=</code>. You can’t use <code class="language-plaintext highlighter-rouge">S</code> values to rewind such a <code class="language-plaintext highlighter-rouge">FunBuilder</code>, but you
couldn’t before, anyway.</p>

<p>In the next part, “Avoiding refinement with dependent method types”,
we’ll look at the meaning of Scala’s “dependent method types” feature,
using it to replace some more type parameters with type members in
non-existential use cases.</p>

<p><em>This article was tested with Scala 2.11.8.</em></p>

<h2 id="appendix-final-funbuilder-examples">Appendix: final <code class="language-plaintext highlighter-rouge">FunBuilder</code> examples</h2>

<p>The rewrite from <code class="language-plaintext highlighter-rouge">S</code> type parameter to member in the <code class="language-plaintext highlighter-rouge">FunBuilder</code>
implementations is a boring, mechanical transform, but I’ve included
it here for easy reference.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">elem</span> <span class="o">::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="nf">++=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="nv">elems</span><span class="o">.</span><span class="py">toList</span> <span class="n">reverse_:::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="nf">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">toVector</span><span class="o">.</span><span class="py">reverse</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>

  <span class="k">def</span> <span class="nf">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="nf">+=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Traversable</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="nf">++=</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="nv">elems</span><span class="o">.</span><span class="py">toTraversable</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="nf">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]()){(</span><span class="n">z</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">as</span> <span class="o">++:</span> <span class="n">z</span><span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">bulkOptimized</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">()</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">bulkOptimized</span><span class="o">)</span>
      <span class="k">new</span> <span class="nc">VectorBuilderListList</span>
    <span class="k">else</span>
      <span class="k">new</span> <span class="nc">VectorBuilderList</span>
<span class="o">}</span>
</code></pre></div></div>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 10 May 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/05/10/internal-state.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/05/10/internal-state.html</guid>
      </item>
    
      <item>
        <title>The Typelevel Summit in Boulder is Cancelled</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>As a result of
<a href="http://degoes.net/articles/lambdaconf-inclusion">LambdaConf’s decision</a>
to invite Curtis Yarvin as a speaker, the organizers of the Typelevel
Summit Boulder have decided that affiliation with LambdaConf is no
longer compatible with Typelevel’s goals, and we are cancelling the
event, which was scheduled to happen on the Wednesday before the
conference.</p>

<p>Yarvin is an unapologetic proponent of bigotry. As a result of his
modest celebrity in this regard, it is not possible for his views to
be “left at the door.” By extending a speaking invitation, LambdaConf
places him in a position of prestige and tacit endorsement that
Typelevel cannot accept.</p>

<p>We recognize LambdaConf’s goal of “harmony in diversity” and applaud
them for sharing their deliberations, but respectfully disagree with
the outcome.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/03/24/typelevel-boulder.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/03/24/typelevel-boulder.html</guid>
      </item>
    
      <item>
        <title>Information hiding, enforced</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>Code should be reusable. An expression traversing a data structure
shouldn’t be written multiple times, it should be pulled out into a
generic traversal function. At a larger scale, a random number generator
shouldn’t be written multiple times, but rather pulled out into a
module that can be used by others.</p>

<p>It is important that such abstractions must be done carefully.
Often times a type is visible to the caller, and if the type
is not handled carefully the abstraction can leak.</p>

<p>For example, a set with fast random indexing (useful for random
walks on a graph) can be implemented with a sorted <code class="language-plaintext highlighter-rouge">Vector</code>.
However, if the <code class="language-plaintext highlighter-rouge">Vector</code> type is
leaked, the user can use this knowledge to violate the invariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="cm">/** (i in repr, position of i in repr) */</span>
<span class="k">def</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">Boolean</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="cm">/* elided */</span>

<span class="k">object</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nv">Vector</span><span class="o">.</span><span class="py">empty</span>

  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">isMember</span><span class="o">,</span> <span class="n">indexOf</span><span class="o">)</span> <span class="k">=</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">)</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">isMember</span><span class="o">)</span> <span class="n">repr</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="nf">val</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span> <span class="k">=</span> <span class="nv">repr</span><span class="o">.</span><span class="py">splitAt</span><span class="o">(</span><span class="n">indexOf</span><span class="o">)</span>
      <span class="n">prefix</span> <span class="o">++</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="nf">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">).</span><span class="py">_1</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">IntSet._</span>
<span class="c1">// import IntSet._
</span>
<span class="k">val</span> <span class="nv">good</span> <span class="k">=</span> <span class="nf">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">)))</span>
<span class="c1">// good: IntSet.Repr = Vector(1, 5, 10)
</span>
<span class="k">val</span> <span class="nv">goodResult</span> <span class="k">=</span> <span class="nf">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">good</span><span class="o">)</span>
<span class="c1">// goodResult: Boolean = true
</span>
<span class="k">val</span> <span class="nv">bad</span> <span class="k">=</span> <span class="nv">good</span><span class="o">.</span><span class="py">reverse</span> <span class="c1">// We know it's a Vector!
// bad: scala.collection.immutable.Vector[Int] = Vector(10, 5, 1)
</span>
<span class="k">val</span> <span class="nv">badResult</span> <span class="k">=</span> <span class="nf">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">bad</span><span class="o">)</span>
<span class="c1">// badResult: Boolean = false
</span>
<span class="k">val</span> <span class="nv">bad2</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// Alternatively..
// bad2: scala.collection.immutable.Vector[Int] = Vector(10, 5, 1)
</span>
<span class="k">val</span> <span class="nv">badResult2</span> <span class="k">=</span> <span class="nf">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">bad2</span><span class="o">)</span>
<span class="c1">// badResult2: Boolean = false
</span></code></pre></div></div>

<p>The issue here is the user knows more about the representation than they
should. The function <code class="language-plaintext highlighter-rouge">add</code> enforces the sorted invariant on each insert,
and the function <code class="language-plaintext highlighter-rouge">contains</code> leverages this to do an efficient look-up.
Because the <code class="language-plaintext highlighter-rouge">Vector</code> definition of <code class="language-plaintext highlighter-rouge">Repr</code> is exposed, the user is
free to create any <code class="language-plaintext highlighter-rouge">Vector</code> they wish which may violate the invariant,
thus breaking <code class="language-plaintext highlighter-rouge">contains</code>.</p>

<p>In general, the <strong>name</strong> of the representation type is needed but the
<strong>definition</strong> is not. If the definition is hidden, the user is only able to
work with the type to the extent the module allows. This is precisely
the notion of information hiding. If this can be enforced by the type
system, modules can be swapped in and out without worrying about breaking
client code.</p>

<h1 id="quantification">Quantification</h1>
<p>It turns out there is a <a href="http://dl.acm.org/citation.cfm?id=6042" title="On understanding types, data abstraction, and polymorphism - Luca Cardelli, Peter Wegner">well understood principle</a>
behind this idea called <em>existential quantification</em>. Contrast with
universal quantification which says “for all”, existential quantification
says “there is a.”</p>

<p>Below is an encoding of universal quantification via parametric polymorphism.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Universal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">Universal#apply</code> says <em>for all</em> choices of <code class="language-plaintext highlighter-rouge">A</code>, a function <code class="language-plaintext highlighter-rouge">A =&gt; A</code> can be
written. In the <a href="http://homepages.inf.ed.ac.uk/wadler/topics/history.html#propositions-as-types" title="Propositions as Types - Philip Wadler">Curry-Howard Isomorphism</a>, a profound
relationship between logic and computation, this translates to “for all propositions
<code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">A</code> implies <code class="language-plaintext highlighter-rouge">A</code>.” It is therefore acceptable to write the following, which picks
<code class="language-plaintext highlighter-rouge">A</code> to be <code class="language-plaintext highlighter-rouge">Int</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">intInstantiatedU</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">Universal</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">u</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="c1">// intInstantiatedU: (u: Universal)Int =&gt; Int
</span></code></pre></div></div>

<p>Existential quantification can also be written in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Existential</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">A</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that this is just one way of encoding existentials - for a deeper
discussion, refer to the excellent <a href="/blog/2015/07/13/type-members-parameters.html" title="Type members are [almost] type parameters">Type Parameters and Type Members</a>
blog series.</p>

<p>The type parameter on <code class="language-plaintext highlighter-rouge">apply</code> has been moved up to a type member of the trait.
Practically, this means every instance of <code class="language-plaintext highlighter-rouge">Existential</code> must pick <strong>one</strong> choice of
<code class="language-plaintext highlighter-rouge">A</code>, whereas in <code class="language-plaintext highlighter-rouge">Universal</code> the <code class="language-plaintext highlighter-rouge">A</code> was parameterized and therefore free. In the
language of logic, <code class="language-plaintext highlighter-rouge">Existential#apply</code> says “there is a” or “there exists some <code class="language-plaintext highlighter-rouge">A</code> such that
<code class="language-plaintext highlighter-rouge">A</code> implies <code class="language-plaintext highlighter-rouge">A</code>.” This “there is a” is the crux of the error when trying
to write a corresponding <code class="language-plaintext highlighter-rouge">intExistential</code> function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">intInstantiatedE</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Existential</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">e</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:19: error: type mismatch;
//  found   : i.type (with underlying type Int)
//  required: e.A
//          (i: Int) =&gt; e.apply(i)
//                              ^
</span></code></pre></div></div>

<p>In code, the type in <code class="language-plaintext highlighter-rouge">Existential</code> is chosen per-instance, so there is no way
of knowing what the actual type chosen is. In logical terms, the only guarantee is
that there exists some proposition that satisfies the implication, but it is not
necessarily the case (and often is not) it holds for all propositions.</p>

<h1 id="abstract-types">Abstract types</h1>
<p>In the ML family of languages (e.g. Standard ML, OCaml), existential quantification
and thus information hiding, is achieved through <a href="http://dl.acm.org/citation.cfm?id=45065" title="Abstract types have existential type">type members</a>.
Programs are organized into <a href="https://realworldocaml.org/v1/en/html/files-modules-and-programs.html" title="Real World OCaml: Files, Modules, and Programs">modules</a> which are what contain these
types.</p>

<p>In Scala, this translates to organizing code with the object system, using the same
type member feature to hide representation. The earlier example of <code class="language-plaintext highlighter-rouge">IntSet</code> can then
be written:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Abstract signature */</span>
<span class="k">trait</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span>

  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Repr</span>
  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
  <span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>

<span class="cm">/** Concrete implementation */</span>
<span class="k">object</span> <span class="nc">VectorIntSet</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nv">Vector</span><span class="o">.</span><span class="py">empty</span>

  <span class="k">def</span> <span class="nf">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">isMember</span><span class="o">,</span> <span class="n">indexOf</span><span class="o">)</span> <span class="k">=</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">)</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">isMember</span><span class="o">)</span> <span class="n">repr</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="nf">val</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span> <span class="k">=</span> <span class="nv">repr</span><span class="o">.</span><span class="py">splitAt</span><span class="o">(</span><span class="n">indexOf</span><span class="o">)</span>
      <span class="n">prefix</span> <span class="o">++</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="nf">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">).</span><span class="py">_1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As long as client code is written against the signature, the
representation cannot be leaked.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">goodUsage</span><span class="o">(</span><span class="n">set</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">set._</span>
  <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nf">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">)))</span>
  <span class="nf">contains</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// goodUsage: (set: IntSet)Boolean
</span></code></pre></div></div>

<p>If the user tries to assert the representation type, the type
checker prevents it <strong>at compile time</strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">badUsage</span><span class="o">(</span><span class="n">set</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">set._</span>
  <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nf">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nf">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">empty</span><span class="o">))</span>

  <span class="c1">// Maybe it's a Vector
</span>  <span class="nv">s</span><span class="o">.</span><span class="py">reverse</span>
  <span class="nf">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">// &lt;console&gt;:23: error: value reverse is not a member of set.Repr
//          s.reverse
//            ^
// &lt;console&gt;:24: error: type mismatch;
//  found   : scala.collection.immutable.Vector[Int]
//  required: set.Repr
//          contains(10, Vector(10, 5, 1))
//                             ^
</span></code></pre></div></div>

<h1 id="parametricity">Parametricity</h1>
<p>Abstract types enforce information hiding at the definition site (the definition
of <code class="language-plaintext highlighter-rouge">IntSet</code> is what hides <code class="language-plaintext highlighter-rouge">Repr</code>). There is another mechanism that enforces information
hiding, which pushes the constraint to the use site.</p>

<p>Consider implementing the following function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Given nothing is known about <code class="language-plaintext highlighter-rouge">a</code>, the only possible thing <code class="language-plaintext highlighter-rouge">foo</code> can do is return <code class="language-plaintext highlighter-rouge">a</code>. If
instead of a type parameter the function was given more information..</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bar</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"not even going to use `a`"</span>
</code></pre></div></div>

<p>..that information can be leveraged to do unexpected things. This is similar to
the first <code class="language-plaintext highlighter-rouge">IntSet</code> example when knowledge of the underlying <code class="language-plaintext highlighter-rouge">Vector</code> allowed unintended
behavior to occur.</p>

<p>From the outside looking in, <code class="language-plaintext highlighter-rouge">foo</code> is universally quantified - the caller gets to
pick any <code class="language-plaintext highlighter-rouge">A</code> they want. From the inside looking out, it is
<a href="/blog/2016/01/28/existential-inside.html" title="It’s existential on the inside">existentially quantified</a> - the implementation knows only as much
about <code class="language-plaintext highlighter-rouge">A</code> as there are constraints on <code class="language-plaintext highlighter-rouge">A</code> (in this case, nothing).</p>

<p>Consider another function <code class="language-plaintext highlighter-rouge">listReplace</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">listReplace</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Given the type parameters, <code class="language-plaintext highlighter-rouge">listReplace</code> looks fairly constrained. The name and signature
suggests it takes each element of <code class="language-plaintext highlighter-rouge">as</code> and replaces it with <code class="language-plaintext highlighter-rouge">b</code>, returning a new list.
However, even knowledge of <code class="language-plaintext highlighter-rouge">List</code> can lead to type checking implementations with strange behavior.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Completely ignores the input parameters
</span><span class="k">def</span> <span class="nf">listReplace</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>Here, knowledge of <code class="language-plaintext highlighter-rouge">List</code> allows the implementation
to create a list out of thin air and use that in the implementation. If instead <code class="language-plaintext highlighter-rouge">listReplace</code>
only knew about some <code class="language-plaintext highlighter-rouge">F[_]</code> where <code class="language-plaintext highlighter-rouge">F</code> is a <code class="language-plaintext highlighter-rouge">Functor</code>, the implementation becomes much more
constrained.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">listFunctor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nv">fa</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">replace</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="py">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">replace</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="s">"typelevel"</span><span class="o">)</span>
<span class="c1">// res8: List[String] = List(typelevel, typelevel, typelevel)
</span></code></pre></div></div>

<p>Absent any knowledge of <code class="language-plaintext highlighter-rouge">F</code> other than the ability to <code class="language-plaintext highlighter-rouge">map</code> over it, <code class="language-plaintext highlighter-rouge">replace</code> is
forced to do the correct thing. Put differently, irrelevant information about <code class="language-plaintext highlighter-rouge">F</code> is hidden.</p>

<p>The fundamental idea behind this is known as parametricity, made popular by Philip Wadler’s
seminal <a href="http://dl.acm.org/citation.cfm?id=99404" title="Theorems for free!">Theorems for free!</a> paper. The technique is best summarized by the
following excerpt from the paper:</p>

<blockquote>
  <p>Write down the definition of a polymorphic function on a piece of paper. Tell me its type,
but be careful not to let me see the function’s definition. I will tell you a theorem that
the function satisfies.</p>
</blockquote>

<h1 id="why-types-matter">Why types matter</h1>
<p>Information hiding is a core tenet of good program design, and it is important to make
sure it is enforced. Underlying information hiding is existential quantification,
which can manifest itself in computation through abstract types and
parametricity. Few languages support defining abstract type members, and fewer
yet support higher-kinded types used in the <code class="language-plaintext highlighter-rouge">replace</code> example. It is therefore
to the extent that a language’s type system is expressive that
<a href="https://www.cis.upenn.edu/~bcpierce/tapl/" title="Types and Programming Languages - Benjamin C. Pierce">abstraction can be enforced</a>.</p>

<p><em>This blog post was tested with Scala 2.11.7 using <a href="https://github.com/tpolecat/tut" title="tut: doc/tutorial generator for scala">tut</a>.</em></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 13 Mar 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/03/13/information-hiding.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/03/13/information-hiding.html</guid>
      </item>
    
      <item>
        <title>Of variance and functors</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>Scala’s type system allows us to annotate type parameters with their variance: covariant, contravariant, invariant.
Variance allows us to define the subtyping relationships between type constructors – that is, under which
conditions <code class="language-plaintext highlighter-rouge">F[A]</code> is a subtype of <code class="language-plaintext highlighter-rouge">F[B]</code>.</p>

<p>Similarly in functional programming, there are covariant functors, contravariant functors, and invariant functors. The
similarity in names is not coincidental.</p>

<h1 id="covariance">Covariance</h1>
<p>The common example is <code class="language-plaintext highlighter-rouge">List[+A]</code> which is covariant in its type parameter, denoted by the <code class="language-plaintext highlighter-rouge">+</code> next to the <code class="language-plaintext highlighter-rouge">A</code>.
A type constructor with a covariant type parameter means that if there is a subtyping relationship between the
type parameter, there is a subtyping relationship between the two instances of the type constructor.
For example if we have a <code class="language-plaintext highlighter-rouge">List[Circle]</code>, we can substitute it anywhere we have a <code class="language-plaintext highlighter-rouge">List[Shape]</code>.</p>

<h2 id="read">Read</h2>
<p>Another example of covariance is in parsing, for example in the following <code class="language-plaintext highlighter-rouge">Read</code> type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It makes sense to make <code class="language-plaintext highlighter-rouge">Read</code> covariant because if we can read a subtype, then we can read the supertype by
reading the subtype and throwing away the subtype-specific information. For instance, if we can read a
<code class="language-plaintext highlighter-rouge">Circle</code>, we can read a valid <code class="language-plaintext highlighter-rouge">Shape</code> by reading the <code class="language-plaintext highlighter-rouge">Circle</code> and ignoring any <code class="language-plaintext highlighter-rouge">Circle</code>-specific information.</p>

<h2 id="array">Array</h2>
<p>A type that cannot safely be made covariant is <code class="language-plaintext highlighter-rouge">Array</code>. If <code class="language-plaintext highlighter-rouge">Array</code> were covariant, we could substitute
an <code class="language-plaintext highlighter-rouge">Array[Circle]</code> for an <code class="language-plaintext highlighter-rouge">Array[Shape]</code>. This can get us in a nasty situation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">circles</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Array</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="mi">10</span><span class="o">)(</span><span class="nc">Circle</span><span class="o">(..))</span>
<span class="k">val</span> <span class="nv">shapes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="n">circles</span> <span class="c1">// works only if Array is covariant
</span><span class="nf">shapes</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Square</span><span class="o">(..)</span> <span class="c1">// Square is a subtype of Shape
</span></code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">Array</code> was covariant this would compile fine, but fail at runtime. In fact, Java arrays are
covariant and so the analogous Java code would compile, throwing an <code class="language-plaintext highlighter-rouge">ArrayStoreException</code> when
run. The compiler accepts this because it is valid to upcast an <code class="language-plaintext highlighter-rouge">Array[Circle]</code> into an <code class="language-plaintext highlighter-rouge">Array[Shape]</code>,
and it is valid to insert a <code class="language-plaintext highlighter-rouge">Shape</code> into an <code class="language-plaintext highlighter-rouge">Array[Shape]</code>. However the runtime representation of
<code class="language-plaintext highlighter-rouge">shapes</code> is still an <code class="language-plaintext highlighter-rouge">Array[Circle]</code> and inserting a <code class="language-plaintext highlighter-rouge">Square</code> into that isn’t allowed.</p>

<h2 id="read-only-and-covariance">Read-only and covariance</h2>
<p>In general, a type can be made safely covariant if it is read-only. If we know how to read a specific type, we know
how to read a more general type by throwing away any extra information. <code class="language-plaintext highlighter-rouge">List</code> is safe to to make
covariant because it is immutable and we can only ever read information off of it. With <code class="language-plaintext highlighter-rouge">Array</code>, we
cannot make it covariant because we are able to write to it.</p>

<h2 id="functor">Functor</h2>
<p>As we’ve just seen, covariance states that when <code class="language-plaintext highlighter-rouge">A</code> subtypes <code class="language-plaintext highlighter-rouge">B</code>, then <code class="language-plaintext highlighter-rouge">F[A]</code> subtypes <code class="language-plaintext highlighter-rouge">F[B]</code>. Put differently,
if <code class="language-plaintext highlighter-rouge">A</code> can be turned into a <code class="language-plaintext highlighter-rouge">B</code>, then <code class="language-plaintext highlighter-rouge">F[A]</code> can be turned into an <code class="language-plaintext highlighter-rouge">F[B]</code>. We can encode this behavior
literally in the notion of a <code class="language-plaintext highlighter-rouge">Functor</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is often encoded slightly differently by changing the order of the arguments:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can implement <code class="language-plaintext highlighter-rouge">Functor</code> for <code class="language-plaintext highlighter-rouge">List</code> and <code class="language-plaintext highlighter-rouge">Read</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">listFunctor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
      <span class="k">case</span> <span class="n">a</span> <span class="o">::</span> <span class="n">as</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">::</span> <span class="nf">map</span><span class="o">(</span><span class="n">as</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="nv">readFunctor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">Read</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Read</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
          <span class="nv">fa</span><span class="o">.</span><span class="py">read</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
          <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>With that we can do useful things like</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">circles</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Circle</span><span class="o">(..),</span> <span class="nc">Circle</span><span class="o">(..))</span>
<span class="k">val</span> <span class="nv">shapes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="nv">listFunctor</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">circles</span><span class="o">)(</span><span class="n">circle</span> <span class="k">=&gt;</span> <span class="n">circle</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="c1">// upcast
</span>
<span class="k">val</span> <span class="nv">parseCircle</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">parseShape</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="nv">readFunctor</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">parseCircle</span><span class="o">)(</span><span class="n">circle</span> <span class="k">=&gt;</span> <span class="n">circle</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="c1">// upcast
</span></code></pre></div></div>

<p>or more generally:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">upcast</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">functor</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">upcast</code>’s behavior does exactly what covariance does – given some supertype <code class="language-plaintext highlighter-rouge">A</code> (<code class="language-plaintext highlighter-rouge">Shape</code>) and a subtype <code class="language-plaintext highlighter-rouge">B</code> (<code class="language-plaintext highlighter-rouge">Circle</code>),
we can mechanically (and safely) turn an <code class="language-plaintext highlighter-rouge">F[B]</code> into an <code class="language-plaintext highlighter-rouge">F[A]</code>. Put differently, anywhere we expect an <code class="language-plaintext highlighter-rouge">F[A]</code> we can provide
an <code class="language-plaintext highlighter-rouge">F[B]</code>, i.e. covariance. For this reason, <code class="language-plaintext highlighter-rouge">Functor</code> is sometimes referred to in full as covariant functor.</p>

<h1 id="contravariance">Contravariance</h1>
<p>Contravariance flips the direction of the relationship in covariance – an <code class="language-plaintext highlighter-rouge">F[Shape]</code> is considered a
subtype of <code class="language-plaintext highlighter-rouge">F[Circle]</code>. This seems strange – when I was first learning about variance I couldn’t
come up with a situation where this would make sense.</p>

<p>If we have a <code class="language-plaintext highlighter-rouge">List[Shape]</code> we cannot safely treat it as a <code class="language-plaintext highlighter-rouge">List[Circle]</code> – doing so comes with all the usual
warnings about downcasting. Similarly if we have a <code class="language-plaintext highlighter-rouge">Read[Shape]</code>, we cannot treat it as a <code class="language-plaintext highlighter-rouge">Read[Circle]</code> –
we know how to parse a <code class="language-plaintext highlighter-rouge">Shape</code>, but we don’t know how to parse any additional information <code class="language-plaintext highlighter-rouge">Circle</code> may need.</p>

<h2 id="show">Show</h2>
<p>It appears fundamentally read-only types cannot be treated as contravariant. However, given that contravariance
is covariance with the direction reversed, can we also reverse the idea of a read-only type? Instead of reading
a value <em>from</em> a <code class="language-plaintext highlighter-rouge">String</code>, we can write a value <em>to</em> a <code class="language-plaintext highlighter-rouge">String</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Show</code> is the other side of <code class="language-plaintext highlighter-rouge">Read</code> – instead of going from a <code class="language-plaintext highlighter-rouge">String</code> to an <code class="language-plaintext highlighter-rouge">A</code>, we go from an <code class="language-plaintext highlighter-rouge">A</code> into
a <code class="language-plaintext highlighter-rouge">String</code>. This reversal allows us to define contravariant behavior – if we are asked to provide a way
to show a <code class="language-plaintext highlighter-rouge">Circle</code> (<code class="language-plaintext highlighter-rouge">Show[Circle]</code>), we can give instead a way to show just a <code class="language-plaintext highlighter-rouge">Shape</code>. This is a valid
substitution because we can show a <code class="language-plaintext highlighter-rouge">Circle</code> by throwing away <code class="language-plaintext highlighter-rouge">Circle</code>-specific information and showing just
the <code class="language-plaintext highlighter-rouge">Shape</code> bits. This means that <code class="language-plaintext highlighter-rouge">Show[Shape]</code> is a subtype of <code class="language-plaintext highlighter-rouge">Show[Circle]</code>, despite <code class="language-plaintext highlighter-rouge">Circle</code> being a
subtype of <code class="language-plaintext highlighter-rouge">Shape</code>.</p>

<p>In general, we can show (or write) a subtype if we know how to show a supertype by tossing away subtype-specific
information (an upcast) and showing the remainder. Again, this means <code class="language-plaintext highlighter-rouge">Show[Supertype]</code> is substitutable, or a
subtype of, <code class="language-plaintext highlighter-rouge">Show[Subtype]</code>.</p>

<p>For similar reasons that read-only types can be made covariant, write-only types can be made contravariant.</p>

<h2 id="array-again">Array, again</h2>
<p><code class="language-plaintext highlighter-rouge">Array</code>s cannot be made contravariant either. If they were, we could do unsafe reads:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">shapes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Array</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="mi">10</span><span class="o">)(</span><span class="nc">Shape</span><span class="o">(..),</span> <span class="nc">Shape</span><span class="o">(..))</span>
<span class="k">val</span> <span class="nv">circles</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="n">shapes</span> <span class="c1">// Works only if Array is contravariant
</span><span class="k">val</span> <span class="nv">circle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=</span> <span class="nf">circles</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">circle</code>, having been read from an <code class="language-plaintext highlighter-rouge">Array[Circle]</code> has type <code class="language-plaintext highlighter-rouge">Circle</code>. To the compiler this would be fine, but
at runtime, the underlying <code class="language-plaintext highlighter-rouge">Array[Shape]</code> may give us a <code class="language-plaintext highlighter-rouge">Shape</code> that is not a <code class="language-plaintext highlighter-rouge">Circle</code> and crash the program.</p>

<h2 id="contravariant">Contravariant</h2>
<p>Our <code class="language-plaintext highlighter-rouge">Functor</code> interface made explicit the behavior of covariance - we can define a similar interface that
captures contravariant behavior. If <code class="language-plaintext highlighter-rouge">B</code> can be used where <code class="language-plaintext highlighter-rouge">A</code> is expected, then <code class="language-plaintext highlighter-rouge">F[A]</code> can be used where an
<code class="language-plaintext highlighter-rouge">F[B]</code> is expected. To encode this explicitly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// Alternative encoding:
</span>  <span class="c1">// def contramap[A, B](f: B =&gt; A): F[A] =&gt; F[B]
</span>
  <span class="c1">// More typical encoding
</span>  <span class="k">def</span> <span class="nf">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can implement an instance for <code class="language-plaintext highlighter-rouge">Show</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">showContravariant</span><span class="k">:</span> <span class="kt">Contravariant</span><span class="o">[</span><span class="kt">Show</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">Show</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
          <span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
          <span class="nv">fa</span><span class="o">.</span><span class="py">show</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Here we are saying if we can show an <code class="language-plaintext highlighter-rouge">A</code>, we can show a <code class="language-plaintext highlighter-rouge">B</code> by turning a <code class="language-plaintext highlighter-rouge">B</code> into an <code class="language-plaintext highlighter-rouge">A</code> before showing it.
Upcasting is a specific case of this, when <code class="language-plaintext highlighter-rouge">B</code> is a subtype of <code class="language-plaintext highlighter-rouge">A</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">contraUpcast</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">contra</span><span class="k">:</span> <span class="kt">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">contra</span><span class="o">.</span><span class="py">contramap</span><span class="o">(</span><span class="n">fb</span><span class="o">)((</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span>
</code></pre></div></div>

<p>Going back to <code class="language-plaintext highlighter-rouge">Shape</code>s and <code class="language-plaintext highlighter-rouge">Circle</code>s, we can show a <code class="language-plaintext highlighter-rouge">Circle</code> by upcasting it into a <code class="language-plaintext highlighter-rouge">Shape</code> and showing that.</p>

<h1 id="function-variance">Function variance</h1>
<p>We observed that read-only types are covariant and write-only types are contravariant. This can be
seen in the context of functions and what function types are subtypes of others.</p>

<h2 id="parameters">Parameters</h2>
<p>An example function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Right now we only care about the input
</span><span class="k">def</span> <span class="nf">squiggle</span><span class="o">(</span><span class="n">circle</span><span class="k">:</span> <span class="kt">Circle</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">???</span>

<span class="c1">// or
</span>
<span class="k">val</span> <span class="nv">squiggle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>What type is a valid subtype of <code class="language-plaintext highlighter-rouge">Circle =&gt; Unit</code>? An important note is we’re not
looking for what subtypes we can <em>pass in</em> to the function, we are looking for a value with a type
that satisfies the entirety of the function type <code class="language-plaintext highlighter-rouge">Circle =&gt; Unit</code>.</p>

<p>A first guess may involve some subtype of <code class="language-plaintext highlighter-rouge">Circle</code> like <code class="language-plaintext highlighter-rouge">Dot</code> (a circle with a radius of 0), such
as <code class="language-plaintext highlighter-rouge">Dot =&gt; Unit</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">squiggle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Dot</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">d</span><span class="o">.</span><span class="py">someDotSpecificMethod</span><span class="o">()</span>
</code></pre></div></div>

<p>This doesn’t work – we are asserting with the moral equivalent of a downcast that any
<code class="language-plaintext highlighter-rouge">Circle</code> input to the function is a <code class="language-plaintext highlighter-rouge">Dot</code>, which is not safe to assume.</p>

<p>What if we used a supertype of <code class="language-plaintext highlighter-rouge">Circle</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">squiggle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">s</span><span class="o">.</span><span class="py">shapeshift</span><span class="o">()</span>
</code></pre></div></div>

<p>This is valid – from the outside looking in we have a function that takes a <code class="language-plaintext highlighter-rouge">Circle</code> and
returns <code class="language-plaintext highlighter-rouge">Unit</code>. Internally, we can take any <code class="language-plaintext highlighter-rouge">Circle</code>, upcast it into a <code class="language-plaintext highlighter-rouge">Shape</code>, and go from there.
Showing things a bit differently reveals better the relationship:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
<span class="k">val</span> <span class="nv">inputSubtype</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">s</span><span class="o">.</span><span class="py">shapeshift</span><span class="o">()</span>
<span class="k">val</span> <span class="nv">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="n">inputSubtype</span>
</code></pre></div></div>

<p>We have <code class="language-plaintext highlighter-rouge">Input[Shape] &lt;: Input[Circle]</code>, with <code class="language-plaintext highlighter-rouge">Circle &lt;: Shape</code>, so function parameters are contravariant.</p>

<p>The type checker enforces this when we try to use covariant type parameters in contravariant positions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">occurs</span> <span class="kt">in</span> <span class="kt">contravariant</span> <span class="kt">position</span> <span class="kt">in</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">a</span>
       <span class="k">trait</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">foo</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">}</span>
                               <span class="o">^</span>
</code></pre></div></div>

<p>Since type parameters are contravariant, a type in that position cannot also be covariant. To solve this
we “reverse” the constraint imposed by the covariant annotation by parameterizing with a supertype <code class="language-plaintext highlighter-rouge">B</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">}</span>
<span class="n">defined</span> <span class="k">trait</span> <span class="nc">Foo</span>
</code></pre></div></div>

<h2 id="return">Return</h2>
<p>Let’s do the same exercise with function return types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">squaggle</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Shape</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Since using the supertype seemed to work with parameters, let’s pick a supertype here, <code class="language-plaintext highlighter-rouge">Object</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">squaggle</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Shape</span> <span class="k">=</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">somethingThatReturnsObject</span><span class="o">()</span>
</code></pre></div></div>

<p>For similar issues with using a subtype for the input parameter, we cannot use
a supertype for the output. The function type states the return type is <code class="language-plaintext highlighter-rouge">Shape</code>, but we’re
returning an <code class="language-plaintext highlighter-rouge">Object</code> which may or may not be a valid <code class="language-plaintext highlighter-rouge">Shape</code>. As far as the type checker is concerned,
this is invalid and the checker rejects the program.</p>

<p>Trying instead with a subtype:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">squaggle</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Shape</span> <span class="k">=</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Circle</span><span class="o">(..)</span>
</code></pre></div></div>

<p>This makes sense – the function type says it returns a <code class="language-plaintext highlighter-rouge">Shape</code> and inside we return a <code class="language-plaintext highlighter-rouge">Circle</code> which is
a perfectly valid <code class="language-plaintext highlighter-rouge">Shape</code>.</p>

<p>As before, rephrasing the type signatures leads to some insights.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Output</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Unit</span> <span class="k">=&gt;</span> <span class="n">A</span>
<span class="k">val</span> <span class="nv">outputSubtype</span><span class="k">:</span> <span class="kt">Output</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Circle</span><span class="o">(..)</span>
<span class="k">val</span> <span class="nv">output</span><span class="k">:</span> <span class="kt">Output</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="n">outputSubtype</span>
</code></pre></div></div>

<p>That is <code class="language-plaintext highlighter-rouge">Output[Circle] &lt;: Output[Shape]</code> with <code class="language-plaintext highlighter-rouge">Circle &lt;: Shape</code> – function return types are covariant.</p>

<p>Again the type checker will enforce this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">bar</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">contravariant</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">occurs</span> <span class="kt">in</span> <span class="kt">covariant</span> <span class="kt">position</span> <span class="kt">in</span> <span class="k">type</span> <span class="o">()</span><span class="kt">A</span> <span class="kt">of</span> <span class="kt">method</span> <span class="kt">bar</span>
       <span class="k">trait</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">bar</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span> <span class="o">}</span>
                           <span class="o">^</span>
</code></pre></div></div>

<p>As before, we solve this by “reversing” the contraint imposed by the variance annotation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="nf">bar</span><span class="o">[</span><span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">]()</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">???</span> <span class="o">}</span>
<span class="n">defined</span> <span class="k">trait</span> <span class="nc">Bar</span>
</code></pre></div></div>

<h2 id="all-together-now">All together now</h2>
<p>Function inputs are contravariant and function outputs are covariant. Taking the previous examples together,
a function type <code class="language-plaintext highlighter-rouge">Shape =&gt; Circle</code> can be put in a place expecting a function type <code class="language-plaintext highlighter-rouge">Circle =&gt; Shape</code>.</p>

<p>We arrived at this conclusion by observing the behavior of subtype variance and the corresponding functors. Taken
in the context of functional programming where the only primitive is a function, we can draw a conclusion in
the other direction. Where function inputs are contravariant, types in positions where computations are
done (e.g. input or read-only positions) are also contravariant (similarly for covariance).</p>

<h1 id="invariance">Invariance</h1>
<p>Unannotated type parameters are considered invariant – the only relationship that holds is if a type <code class="language-plaintext highlighter-rouge">A</code>
is equal to a type <code class="language-plaintext highlighter-rouge">B</code>, then <code class="language-plaintext highlighter-rouge">F[A]</code> is equal to <code class="language-plaintext highlighter-rouge">F[B]</code>. Otherwise different instantiations of a
type constructor have no relationship with one another. Given invariant
<code class="language-plaintext highlighter-rouge">F[_]</code>, an <code class="language-plaintext highlighter-rouge">F[Circle]</code> is not a subtype of <code class="language-plaintext highlighter-rouge">F[Shape]</code> – you need to explicitly provide the conversion.</p>

<h2 id="array-once-more">Array once more</h2>
<p><code class="language-plaintext highlighter-rouge">Array</code>s are invariant in Scala because they can be neither covariant nor contravariant. If we make it
covariant, we can get unsafe writes. If we make it contravariant, we can get unsafe reads. Since
read-only types can only be covariant and write-only types contravariant, our compromise is to make
types that support both invariant.</p>

<p>In order to treat an <code class="language-plaintext highlighter-rouge">Array</code> of one type as an <code class="language-plaintext highlighter-rouge">Array</code> of another, we need to have conversions
in both directions. This must be provided manually as the type checker has no way of knowing what the
conversion would be.</p>

<h2 id="invariant">Invariant</h2>
<p>Similar to (covariant) <code class="language-plaintext highlighter-rouge">Functor</code> and <code class="language-plaintext highlighter-rouge">Contravariant</code>, we can write <code class="language-plaintext highlighter-rouge">Invariant</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For demonstration purposes we write our own <code class="language-plaintext highlighter-rouge">Array</code> type</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">repr</span> <span class="k">=</span> <span class="nv">ListBuffer</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">read</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="nf">repr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">write</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">repr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span>
<span class="o">}</span>
</code></pre></div></div>

<p>and define <code class="language-plaintext highlighter-rouge">Invariant[Array]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">arrayInvariant</span><span class="k">:</span> <span class="kt">Invariant</span><span class="o">[</span><span class="kt">Array</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">Array</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="c1">// Convert read A to B before returning – covariance
</span>        <span class="k">override</span> <span class="k">def</span> <span class="nf">read</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
          <span class="nf">f</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">read</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

        <span class="c1">// Convert B to A before writing – contravariance
</span>        <span class="k">override</span> <span class="k">def</span> <span class="nf">write</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
          <span class="nv">fa</span><span class="o">.</span><span class="py">write</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="nf">g</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="serialization">Serialization</h2>
<p>Another example of a read-write type that doesn’t involve <code class="language-plaintext highlighter-rouge">Array</code>s (or mutation) can be
found by just combining the <code class="language-plaintext highlighter-rouge">Read</code> and <code class="language-plaintext highlighter-rouge">Show</code> interfaces:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Serializer</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Serializer</code> both reads (from a <code class="language-plaintext highlighter-rouge">String</code>) and writes (to a <code class="language-plaintext highlighter-rouge">String</code>). We can’t make it
covariant because that would cause issues with <code class="language-plaintext highlighter-rouge">show</code>, and we can’t make it contravariant
because that would cause issues with <code class="language-plaintext highlighter-rouge">read</code>. Therefore our only choice is to keep it
invariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">serializerInvariant</span><span class="k">:</span> <span class="kt">Invariant</span><span class="o">[</span><span class="kt">Serializer</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">Serializer</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Serializer</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Serializer</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Serializer</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nv">fa</span><span class="o">.</span><span class="py">read</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
        <span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nv">fa</span><span class="o">.</span><span class="py">show</span><span class="o">(</span><span class="nf">g</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<h1 id="bringing-everything-together">Bringing everything together</h1>
<p>We can see the <code class="language-plaintext highlighter-rouge">Invariant</code> interface is more general than both <code class="language-plaintext highlighter-rouge">Functor</code> and <code class="language-plaintext highlighter-rouge">Contravariant</code> –
where <code class="language-plaintext highlighter-rouge">Invariant</code> requires functions going in both directions, <code class="language-plaintext highlighter-rouge">Functor</code> and <code class="language-plaintext highlighter-rouge">Contravariant</code> only
require one. We can make <code class="language-plaintext highlighter-rouge">Functor</code> and <code class="language-plaintext highlighter-rouge">Contravariant</code> subtypes of <code class="language-plaintext highlighter-rouge">Invariant</code> by ignoring
the direction we don’t care about.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">contramap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">g</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Going back to treating <code class="language-plaintext highlighter-rouge">Array</code> and <code class="language-plaintext highlighter-rouge">Serializer</code> as a read/write store, if we make it read-only (like a read-only
handle on a resource) we can safely treat it as if it were covariant. If we are asked to read
<code class="language-plaintext highlighter-rouge">Shape</code>s and we know how to read <code class="language-plaintext highlighter-rouge">Circle</code>s, we can read a <code class="language-plaintext highlighter-rouge">Circle</code> and upcast it into a <code class="language-plaintext highlighter-rouge">Shape</code>
before handing it over.</p>

<p>Similarly if we make it write-only (like a write-only handle on a resource) we can safely treat
it as contravariant. If we are asked to store <code class="language-plaintext highlighter-rouge">Circle</code>s and we know how to store <code class="language-plaintext highlighter-rouge">Shape</code>s,
we can upcast each <code class="language-plaintext highlighter-rouge">Circle</code> into a <code class="language-plaintext highlighter-rouge">Shape</code> before storing it.</p>

<p>Variance manifests in two levels: one at the type level where subtyping relationships are defined, and
the other at the value level where it is encoded as an interface which certain types can conform to.</p>

<h2 id="one-more-thing">One more thing</h2>
<p>Thus far we have seen the three kinds of variances Scala supports:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">1.</span> <span class="n">invariance</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">B</span> <span class="o">→</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="mf">2.</span> <span class="n">covariance</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span> <span class="kt">→</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">&lt;:</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="mf">3.</span> <span class="n">contravariance</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">B</span> <span class="kt">→</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">&lt;:</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>This gives us the following graph:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   invariance
     ↑   ↑
    /      \
   -        +
</code></pre></div></div>

<p>Completing the diamond implies a fourth kind of variance, one that takes contravariance and
covariance together. This is known as phantom variance or anyvariance, a variance with no constraints on the
type parameters: <code class="language-plaintext highlighter-rouge">F[A] = F[B]</code> regardless of what <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are. Unfortunately Scala’s type system is
missing this kind of variance which leaves us just short of a nice diamond, but we can still encode it
in an interface.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Phantom</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">pmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Given any <code class="language-plaintext highlighter-rouge">F[A]</code>, we can turn that into an <code class="language-plaintext highlighter-rouge">F[B]</code>, for all choices of <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>. With this power we can
implement covariant and contravariant functors.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Phantom</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">pmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nf">pmap</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nf">pmap</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This completes our diamond of variance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   invariance
     ↑   ↑
    /      \
   -        +
   ↑        ↑
    \      /
    phantom
</code></pre></div></div>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 04 Feb 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/02/04/variance-and-functors.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/02/04/variance-and-functors.html</guid>
      </item>
    
      <item>
        <title>First batch of talks at the Philadelphia Summit</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>The work on the programme for the <a href="/event/2016-03-summit-philadelphia/">Philadelphia Summit</a> is in full swing!
As announced earlier, we’re happy to share with you the first batch of accepted talks.
Don’t worry though, there’s still time until the end of the week to <a href="http://goo.gl/forms/SX3plxsOKb">submit a proposal</a>.</p>

<h3 id="becoming-a-cats-person">Becoming a cat(s) person</h3>

<p>Want to contribute to Cats?
Let’s head over to the Cats Issues list and do some live coding!
Along the way we will see how the codebase is organized, the various bits of automation provided, and how you can use our various channels to get feedback on your work.</p>

<p><img src="/img/media/speakers/adelbertchang.jpeg" class="portrait" />
<em>Adelbert Chang is a Software Engineer at Box and a recent graduate from UC Santa Barbara where he studied Computer Science and researched graph querying and modeling. He enjoys helping with functional programming education and learning more about programming.</em>
<br style="clear: both;" /></p>

<h3 id="direct-syntax-for-monad-comprehensions">Direct syntax for monad comprehensions</h3>

<p>Easy, intuitive, direct-style syntax for monad comprehensions!
Like Scala <code class="language-plaintext highlighter-rouge">async</code> or SBT <code class="language-plaintext highlighter-rouge">.value</code>, but generalized to any monad.
Implemented, ready to be used and requiring only vanilla Scala 2.10/2.11 and blackbox macros.
Future extensions could include automatic use of Applicative where possible, support for more embedded control-flow operations, comprehensions over multiple compatible monads at once for user-defined notions of compatible and compiler tweaks for syntactic improvements.</p>

<p><img src="/img/media/speakers/chrisvogt.jpg" class="portrait" />
<em>Chris Vogt. Slick co-author, Compossible records author, frequent Scala conference/user group speaker, former member of Martin’s team at LAMP/EPFL, based in NYC, Senior Software Engineer at x.ai</em>
<br style="clear: both;" /></p>

<p><img src="/img/media/speakers/chrishodapp.jpg" class="portrait" />
<em>Chris Hodapp. Several-time Scala GSOC student and eventually mentor, author of the ill-fated Comprehensive Comprehensions project. He’s hoping to see tooling and techniques from the FP/Typelevel community improve the leverage of the average developer. Based in the SF Bay Area.</em>
<br style="clear: both;" /></p>

<h3 id="scala-exercises">Scala Exercises</h3>

<p>Scala Exercises is a web based community tool open sourced by 47 Degrees.
It contains multiple koan and free form style exercises maintained by library authors and maintainers to help you master some of the most important tools in the Scala Ecosystem.
Version 2 comes with a brand new backend and exercise tracking where you can login simply using your Github account and track your progress throughout exercises and libraries.
Version 2 will launch with exercises for the stdlib, Cats, Shapeless and other well known libraries and frameworks part of the Scala ecosystem.</p>

<p><img src="/img/media/speakers/raulraja.jpg" class="portrait" />
<em>Raul Raja. Functional programming enthusiast, CTO and Co-founder at 47 Degrees, a functional programming consultancy specialized in Scala.</em>
<br style="clear: both;" /></p>

<h3 id="probabilistic-programming-what-it-is-and-how-it-works">Probabilistic Programming: What It Is and How It Works</h3>

<p>Probabilistic programming is the other Big Thing to happen in machine learning alongside deep learning.
It is also closely tied to functional programming. In this talk I will explain the goals of probabilistic programming and how we can implement a probabilistic programming language in Scala.
Probabilistic models are one of the main approaches in machine learning.
Probabilistic programming aims to make expressive probabilistic models cheaper to develop.
This is achieved by expressing the model within an embedded DSL, and then compiling learning (inference) algorithms from the model description.
This automates one of the main tasks in building a probabilistic model, and provides the same benefits as a compiler for a traditional high-level language.
With the close tie of functional programming to mathematics, and the use of techniques like the free monad, functional programming languages are an ideal platform for embedding probabilistic programming.</p>

<p><img src="/img/media/speakers/noelwelsh.png" class="portrait" />
<em>Noel Welsh is a partner at Underscore, a consultancy that specializes in Scala. He’s been using Scala for 6 years in all sorts of applications. He’s the author of Advanced Scala, which is in the process of being rewritten to use Cats.</em>
<br style="clear: both;" /></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 28 Jan 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/01/28/summit_programme.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/28/summit_programme.html</guid>
      </item>
    
      <item>
        <title>It’s existential on the inside</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the eighth of a series of articles on “Type Parameters and
Type Members”.  You may wish to
<a href="/blog/2015/07/13/type-members-parameters.html">check out the beginning</a>,
which introduces the <code class="language-plaintext highlighter-rouge">PList</code> type we refer to throughout this article
without further ado.</em></p>

<p>When you start working with type parameters, nothing makes it
immediately apparent that you are working with universal and
existential types at the same time. It is literally a matter of
perspective.</p>

<p>I will momentarily set aside a lengthy explanation of what this means,
in favor of some diagrams.</p>

<h2 id="universal-outside-existential-inside">Universal outside, existential inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fizzle</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">rec</span><span class="o">(</span><span class="n">pl</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">tl</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">pl</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">rec</span><span class="o">(</span><span class="nc">PCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">pl</span><span class="o">),</span> <span class="n">xs</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">xs</span> <span class="k">=&gt;</span> <span class="nf">rec</span><span class="o">(</span><span class="nc">PNil</span><span class="o">(),</span> <span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-fizzle.png" alt="Universal outside existential inside" /></p>

<p>The caller can select any <code class="language-plaintext highlighter-rouge">A</code>, but the implementation must work with
whatever <code class="language-plaintext highlighter-rouge">A</code> the caller chooses. So <code class="language-plaintext highlighter-rouge">fizzle</code> is universal in <code class="language-plaintext highlighter-rouge">A</code> from
the outside, but existential in <code class="language-plaintext highlighter-rouge">A</code> from the inside.</p>

<p>So what happens when the caller and callee ‘trade places’?</p>

<h2 id="existential-outside-universal-inside">Existential outside, universal inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wazzle</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">n</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">PCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
       <span class="k">else</span> <span class="nc">PCons</span><span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-wazzle.png" alt="Existential outside universal inside" /></p>

<p>Now the implementation gets to choose an <code class="language-plaintext highlighter-rouge">A</code>, and the caller must work
with whatever <code class="language-plaintext highlighter-rouge">A</code> the implementation chooses. So <code class="language-plaintext highlighter-rouge">wazzle</code> is universal
in <code class="language-plaintext highlighter-rouge">A</code> from the inside, but existential in <code class="language-plaintext highlighter-rouge">A</code> from the outside.</p>

<p>A good way to think about these two, <code class="language-plaintext highlighter-rouge">fizzle</code> and <code class="language-plaintext highlighter-rouge">wazzle</code>, is that
<code class="language-plaintext highlighter-rouge">fizzle</code> takes a type <em>argument</em> from the caller, but <code class="language-plaintext highlighter-rouge">wazzle</code>
<em>returns</em> a type (alongside the list) to the caller.</p>

<h2 id="universal--outside-existential-inside">Universal (!) outside, existential inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">duzzle</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">duzzle</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">duzzle2</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">duzzle2</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-duzzle.png" alt="Universal outside existential inside" /></p>

<p><code class="language-plaintext highlighter-rouge">wazzle</code> “returns” a type, alongside the list, because the existential
appears as part of the return type. However, <code class="language-plaintext highlighter-rouge">duzzle2</code> places the
existential in argument position. So, as with all type-parameterized
cases, <code class="language-plaintext highlighter-rouge">duzzle</code> among them, this is one where the caller determines
the type.</p>

<p>We’ve <a href="/blog/2015/07/16/method-equiv.html">discussed</a> how you can
prove that <code class="language-plaintext highlighter-rouge">duzzle</code> ≡<em><sub><small>m</small></sub></em> <code class="language-plaintext highlighter-rouge">duzzle2</code>, in a
previous post. Now, it’s time to see why.</p>

<h2 id="type-parameters-are-parameters">Type parameters are parameters</h2>

<p>The caller chooses the value of a type parameter. It also chooses the
value of normal parameters. So, it makes sense to treat them the same.</p>

<p>Let’s try to look at <code class="language-plaintext highlighter-rouge">fizzle</code>’s type this way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="existential-types-are-pairs">Existential types are pairs</h2>

<p>If <code class="language-plaintext highlighter-rouge">wazzle</code> returns a type and a value, it makes sense to treat them
as a returned pair.</p>

<p>Let’s look at <code class="language-plaintext highlighter-rouge">wazzle</code>’s type this way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>This corresponds exactly to the <code class="language-plaintext highlighter-rouge">forSome</code> scope
<a href="/blog/2015/07/27/nested-existentials.html">we have explored previously</a>.
So we can interpret <code class="language-plaintext highlighter-rouge">PList[PList[_]]</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span><span class="o">}]</span>  <span class="c1">// explicitly scoped
</span><span class="nc">PList</span><span class="o">[([</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])]</span>            <span class="c1">// “paired”
</span></code></pre></div></div>

<h2 id="the-duzzles-are-currying">The <code class="language-plaintext highlighter-rouge">duzzle</code>s are currying</h2>

<p>With these two models, we can finally get to the bottom of
<code class="language-plaintext highlighter-rouge">duzzle</code> ≡<em><sub><small>m</small></sub></em> <code class="language-plaintext highlighter-rouge">duzzle2</code>. Here are their
types, rewritten in the forms we’ve just seen.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span>
<span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Int</span>
</code></pre></div></div>

<p>Recognize that? They’re just the curried and uncurried forms of the
same function type.</p>

<p>You can also see why the same type change will not work for <code class="language-plaintext highlighter-rouge">wazzle</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
<span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>We’ve moved part of the return type into an argument, which is…not the
same.</p>

<h2 id="the-future-of-types">The future of types?</h2>

<p>This formulation of universal and existential types is due to
dependently-typed systems, in which they are “dependent functions” and
“dependent pairs”, respectively, though with significantly more
expressive power than we’re working with here. They come by way of the
description of the Quest programming language in
<a href="http://www.lucacardelli.name/Papers/TypefulProg.pdf">“Typeful Programming” by Luca Cardelli</a>,
which shows in a clear, syntactic way that the dependent view of
universal and existential types is perfectly cromulent to
non-dependent type systems like Scala’s.</p>

<p>It is also the root of my frustration that Scala doesn’t support a
<code class="language-plaintext highlighter-rouge">forAll</code>, like <code class="language-plaintext highlighter-rouge">forSome</code> but for universally-quantified types. After
all, you can’t work with one without the other.</p>

<p>Now we have enough groundwork for
<a href="/blog/2016/05/10/internal-state.html">“Making internal state functional”</a>,
the next part of this series. I suspect it will be a little prosaic at
this point, though.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 28 Jan 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/01/28/existential-inside.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/28/existential-inside.html</guid>
      </item>
    
      <item>
        <title>Keynote at the Philadelphia Summit</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>While the CfP for the <a href="/event/2016-03-summit-philadelphia/">Philadelphia Summit</a> is still open (<a href="http://goo.gl/forms/SX3plxsOKb">have you submitted a proposal yet?</a>), we can already announce our keynote speaker:</p>

<p><img src="/img/media/speakers/sweirich.jpg" style="float: right; width: 30%; margin-left: 1em;" />
Stephanie Weirich is a Professor at the University of Pennsylvania. Her research centers on programming languages, type theory and machine-assisted reasoning. In particular, she studies generic programming, metaprogramming, dependent type systems, and type inference in the context of functional programming languages. She is currently an Editor of the Journal of Functional Programming and served as the program chair for ICFP in 2010 and the Haskell Symposium in 2009.</p>

<p><br style="clear: both;" /></p>

<p>Stephanie will join the Summit on March 2nd to talk about <em>Dependently-Typed Haskell</em>.
We hope this will give us an exciting opportunity to exchange knowledge between the Haskell and Scala communities.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 20 Jan 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/01/20/summit_keynote.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/20/summit_keynote.html</guid>
      </item>
    
      <item>
        <title>Assistance and Bursaries for the Typelevel Summits</title>
        
          <dc:creator>davegurnell</dc:creator>
                
        <description><![CDATA[<p><em>Update: The summits are over, which means applying for assistance is not possible any longer.</em></p>

<p>As it says in our <a href="/conduct.html">code of conduct</a>, we are dedicated to creating a harrassment-free, inclusive community of developers. We want to extend this philosophy to the Typelevel Summits in <a href="/event/2016-03-summit-philadelphia/">Philadelphia</a> and <a href="/event/2016-05-summit-oslo/">Oslo</a> by providing assistance and bursaries to help speakers and attendees who would otherwise not be able to join us.</p>

<h3 id="bursaries-for-speakers-and-attendees">Bursaries for Speakers and Attendees</h3>

<p>We are approaching sponsors and commercial partners to arrange bursaries for conference registration, travel and accommodation. Everyone is welcome to apply. However, note that we may not be able to provide funding in all cases.</p>

<h3 id="speaker-assistance-help-with-talk-proposals">Speaker Assistance: Help with Talk Proposals</h3>

<p>Many people don’t submit talk proposals to conferences because they can’t think of something to say or don’t think their ideas are interesting.</p>

<p>We are offering feedback and suggestions on talk proposals to anyone who requests it. Hopefully we can help you turn a rough idea into a compelling abstract to submit alongside abstracts from other potential speakers.</p>

<p>Asking us for help won’t guarantee you a slot in the programme, but it will give you an idea for a talk that would compete against the other submissions.</p>

<p>If you have a good talk idea but for some reason it doesn’t make it into the conference, we will help you find another conference or meetup group for your first public speaking experience.</p>

<h3 id="speaker-assistance-speaker-training">Speaker Assistance: Speaker Training</h3>

<p>Many people are concerned or nervous about public speaking. We are offering free workshops to provide newer speakers with advice for tech speaking, whether your abstract is accepted or not.</p>

<p>Given the international nature of the Summits, we probably won’t be able to organise face-to-face workshops. We will deliver the workshops over Google Hangouts to reach as many attendees as possible.</p>

<h3 id="speaker-assistance-help-with-talk-writing">Speaker Assistance: Help with Talk Writing</h3>

<p>If your abstract is accepted to the conference, we are offering free mentoring services to provide advice and feedback as you turn your abstract into a talk.</p>

<p>We will assign a mentor to each participating speaker. Your mentor will be available to act as a sounding board as your talk develops from an outline to a fully formed presentation.</p>

<h3 id="sound-interesting">Sound Interesting?</h3>

<p>If you are planning on attending or speaking in Philadelphia or Oslo, and you would like to apply for any of the services above, please please fill out the application form linked at the top of the page.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2016/01/14/summit_assistance.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/14/summit_assistance.html</guid>
      </item>
    
      <item>
        <title>Announcement: Typelevel Summits coming up in 2016</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>We have a big announcement to make. In 2016, there will be not just one, but
two Typelevel Summits. Also, we’ve updated our website to include an up-to-date
list of Typelevel projects. There’s been much work behind the scenes which we
will talk about in a later post, so stay tuned!  But first, here are some
details about the Summits.</p>

<h3 id="typelevel-summit-us">Typelevel Summit US</h3>

<p>The first Typelevel Summit will be co-located with the Northeast Scala
Symposium in Philadelphia. As Brian Clapper already announced on Twitter, NE
Scala is going to happen on 4th and 5th of March with one day of recorded talks
and one day of unconference. Just today, we finalized the booking of the venue
and are happy to report that the Typelevel Summit will have the same format and
take place on 2nd and 3rd of March at the same venue (The Hub’s Cira Centre,
next to 30th Street Station).</p>

<h3 id="typelevel-summit-europe">Typelevel Summit Europe</h3>

<p>The second Typelevel Summit will be co-located with
<a href="http://2016.flatmap.no/">flatMap(Oslo)</a>. We will meet on the 4th of May after
the conference at the same venue (Teknologihuset). More details are to be
announced!</p>

<h3 id="call-for-speakers-attendance--faqs">Call for Speakers, Attendance, &amp; FAQs</h3>

<p>The planning phase is in full swing and we’ll announce more details soon.
Attendance will probably be limited to about 100. We’re also looking for
sponsors to help pay for the venue and cover other expenses. And we’re also
starting a diversity fund to support people from underrepresented groups, and
to mentor new speakers. If you want to contribute or have any other questions,
please contact us via <a href="mailto:info@typelevel.org">info@typelevel.org</a>.</p>

<p>The Summits are open to all, not just current contributors to and users of the
Typelevel projects, and we are especially keen to encourage participation from
people who are new to them. Whilst many of the Typelevel projects use somewhat
“advanced” Scala, they are a lot more approachable than many people think, and
a major part of Typelevel’s mission is to make the ideas they embody much more
widely accessible. So, if you’re interested in types and pure functional
programming, want to make those ideas commonplace and are willing to abide by
the Typelevel code of conduct, then the Summits are for you and we’d love to
see you there.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/12/11/announcement_summit.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/12/11/announcement_summit.html</guid>
      </item>
    
      <item>
        <title>To change types, change values</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the seventh of a series of articles on “Type Parameters and
Type Members”.  You may wish to
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>;
more specifically, this post is meant as a followup to
<a href="/blog/2015/07/30/values-never-change-types.html">the previous entry</a>.
However, in a first for this series, it stands on its own, as
introductory matter.</em></p>

<p>A program is a system for converting data from one format to another,
which we have endowed with the color of magic.  In typed programming,
we use a constellation of types to mediate this transformation; a
function’s result can only be passed as another function’s argument to
the extent to which those parts of the functions’ types unify.</p>

<p>We rely on the richness of our types in these descriptions.  So it is
natural to want the types to change as you move to different parts of
the process; each change reflects the reality of what has just
happened.  For example, when you parse a string into an AST, your
program’s state has changed types, from <code class="language-plaintext highlighter-rouge">String</code> to <code class="language-plaintext highlighter-rouge">MyAST</code>.</p>

<p>But, as we have just seen, due to decisions we have made to simplify
our lives,
<a href="/blog/2015/07/30/values-never-change-types.html">values cannot change types</a>,
no matter how important it is to the sanity of our code.  At the same
time, we don’t want to give up the richness of using more than one
type to describe our data.</p>

<p>Fortunately, there is a solution that satisfies these competing
concerns: to change types, change values.  You can’t do anything about
the values you have, but you can create new ones of the right type,
and use those instead.</p>

<h2 id="type-changing-is-program-organization">Type-changing is program organization</h2>

<p>In values with complex construction semantics, it is common to write
imperative programs that leave “holes” in the data structures using
the terrible <code class="language-plaintext highlighter-rouge">null</code> misfeature of Java, Scala, and many other
languages.  This looks something like this.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Document</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">Path</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// this structure has three parts:
</span>  <span class="k">var</span> <span class="n">text</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// ← a body of text,
</span>  <span class="k">var</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="kc">null</span>
    <span class="c1">// ↑ an index of words to every
</span>    <span class="c1">// occurrence in the text,
</span>  <span class="k">var</span> <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="kc">null</span>
    <span class="c1">// ↑ the most frequently used words
</span>    <span class="c1">// in the text, and their number of
</span>    <span class="c1">// occurrences
</span><span class="o">...</span>
</code></pre></div></div>

<p>Now, we must fill in these variables, by computing and assigning to
each in turn.  First, we compute the corpus text.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">initText</span><span class="o">()</span>
</code></pre></div></div>

<p>Then, we compute and fill in the word index.  If we didn’t fill in
<code class="language-plaintext highlighter-rouge">text</code> first, this compiles, but crashes at runtime.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">initWordIndex</span><span class="o">()</span>
</code></pre></div></div>

<p>Finally, we figure out which words are most popular.  If we didn’t
fill in <code class="language-plaintext highlighter-rouge">wordIndex</code> first, this compiles, but crashes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">initMostPopular</span><span class="o">()</span>
</code></pre></div></div>

<p>How do I know that?  Well, I have to inspect the definitions of these
three methods.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">initText</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">text</span> <span class="k">=</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="nv">filename</span><span class="o">.</span><span class="py">toFile</span><span class="o">).</span><span class="py">mkString</span>

  <span class="k">def</span> <span class="nf">initWordIndex</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">words</span> <span class="k">=</span> <span class="s">"""\w+"""</span><span class="o">.</span><span class="py">r</span> <span class="n">findAllMatchIn</span> <span class="n">text</span>
    <span class="n">wordIndex</span> <span class="k">=</span> <span class="nv">words</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]()){</span>
      <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">mtch</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="nv">word</span> <span class="k">=</span> <span class="nv">mtch</span><span class="o">.</span><span class="py">matched</span>
        <span class="k">val</span> <span class="nv">idx</span> <span class="k">=</span> <span class="nv">mtch</span><span class="o">.</span><span class="py">start</span>
        <span class="n">m</span> <span class="o">+</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">::</span> <span class="nv">m</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">initMostPopular</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">mostPopular</span> <span class="k">=</span> <span class="nv">wordIndex</span><span class="o">.</span><span class="py">mapValues</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">size</span><span class="o">).</span><span class="py">toList</span>
      <span class="o">.</span><span class="py">sortBy</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="o">-</span> <span class="nv">p</span><span class="o">.</span><span class="py">_2</span><span class="o">).</span><span class="py">take</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</code></pre></div></div>

<p>This method of organizing object initialization is popular because,
among other properties:</p>

<ol>
  <li>it <em>seems</em> self-documenting,</li>
  <li>you don’t have to pass data around, and</li>
  <li>steps can be customized by subclassing and overriding.</li>
</ol>

<p>However!  It has the tremendous drawback of preventing the compiler
from helping you get the order of initialization correct.  Go, look;
see if you can spot why I said the latter two calls would crash if you
don’t get the order exactly right.  Now, I have four questions for
you.</p>

<ol>
  <li>Would you trust yourself to notice these implicit dependencies
every time you look at this code?</li>
  <li>Suppose you commented on the dependencies.  Would you trust these
comments to be updated when the initialization details change?</li>
  <li>Would you trust subclasses that customize the initialization to
respect the order in which we call these three <code class="language-plaintext highlighter-rouge">init</code> functions?</li>
  <li>Could you keep track of this if the initialization was
significantly more complex?  (This <em>is</em> a toy example for a blog
post, after all.)</li>
</ol>

<p>Ironically, as your initialization becomes more complex, the compiler
becomes less able to help you with uninitialized-variable warnings and
the like.  But, this is not the natural order of things; it is a
consequence of using imperative variable initialization but not
representing this
<a href="https://github.com/facebook/flow/releases/tag/v0.14.0">variable refinement</a>
in the type system.  By initializing in a different way, we can
recover type safety.</p>

<div class="side-note">
  The implications of refinement, linked above, are much less severe
  than those of unrestricted type-changing of a variable.  So Flow did
  not solve, nor did it aim to solve, those difficulties by
  introducing the refinement feature.
</div>

<h2 id="the-four-types-of-document">The four types of <code class="language-plaintext highlighter-rouge">Document</code></h2>

<p>If we consider <code class="language-plaintext highlighter-rouge">Document</code> as the simple product of its three state
variables, with some special functions associated with them as
whatever <code class="language-plaintext highlighter-rouge">Document</code> methods we intend to support, we have a simple
3-tuple.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
 <span class="nc">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>Let us no longer pretend that it is any more complicated than that.</p>

<p>But this cannot be mutated to fill these in as they are initialized,
you say!  Yes, that’s right, we want a <em>type-changing</em> transformation.
By <em>changing values</em>, this is easy.  There are three phases of
initialization, so four states, including uninitialized.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span>
<span class="nc">String</span>
<span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span>
<span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span> <span class="nc">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>For interesting phases, such as the final one, we might create a <code class="language-plaintext highlighter-rouge">case
class</code> to hold its contents, instead.  Let us call that class, for
this example, <code class="language-plaintext highlighter-rouge">Doc</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Doc</span>
  <span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
   <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>Finally, we can build 3 functions to take us through these steps.
Each begins by taking one as an argument, and produces the next state
as a return type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">initText</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">Path</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="nv">filename</span><span class="o">.</span><span class="py">toFile</span><span class="o">).</span><span class="py">mkString</span>

  <span class="k">def</span> <span class="nf">initWordIndex</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">words</span> <span class="k">=</span> <span class="s">"""\w+"""</span><span class="o">.</span><span class="py">r</span> <span class="n">findAllMatchIn</span> <span class="nf">text</span>
    <span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="nv">words</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]()){</span>
       <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">mtch</span><span class="o">)</span> <span class="k">=&gt;</span>
       <span class="k">val</span> <span class="nv">word</span> <span class="k">=</span> <span class="nv">mtch</span><span class="o">.</span><span class="py">matched</span>
       <span class="k">val</span> <span class="nv">idx</span> <span class="k">=</span> <span class="nv">mtch</span><span class="o">.</span><span class="py">start</span>
       <span class="n">m</span> <span class="o">+</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">::</span> <span class="nv">m</span><span class="o">.</span><span class="py">getOrElse</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
     <span class="o">})</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">initMostPopular</span><span class="o">(</span><span class="n">twi</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]))</span><span class="k">:</span> <span class="kt">Doc</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">val</span> <span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">wordIndex</span><span class="o">)</span> <span class="k">=</span> <span class="n">twi</span>
    <span class="nc">Doc</span><span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">wordIndex</span><span class="o">,</span>
        <span class="nv">wordIndex</span><span class="o">.</span><span class="py">mapValues</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">size</span><span class="o">).</span><span class="py">toList</span>
          <span class="o">.</span><span class="py">sortBy</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="o">-</span> <span class="nv">p</span><span class="o">.</span><span class="py">_2</span><span class="o">).</span><span class="py">take</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>If we have a <code class="language-plaintext highlighter-rouge">Path</code>, we can get a <code class="language-plaintext highlighter-rouge">Doc</code> by <code class="language-plaintext highlighter-rouge">(initText _) andThen
initWordIndex andThen initMostPopular: Path =&gt; Doc</code>.  But that hardly
replicates the rich runtime behavior of our imperative version, does
it?  That is, we can do reordering of operations in a larger context
with <code class="language-plaintext highlighter-rouge">Document</code>, but not <code class="language-plaintext highlighter-rouge">Doc</code>.  Let us see what that means.</p>

<h2 id="many-docs">Many docs</h2>

<p>Dealing with one document in isolation is one thing, but suppose we
have a structure of <code class="language-plaintext highlighter-rouge">Document</code>s.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">DocumentTree</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SingleDocument</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">Document</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">DocumentTree</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocumentCategory</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocumentTree</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">DocumentTree</span>
</code></pre></div></div>

<p>In the imperative mode, we can batch and reorder initialization.  Say,
for example, we don’t initialize <code class="language-plaintext highlighter-rouge">Document</code> when we create it.  This
tree then contains <code class="language-plaintext highlighter-rouge">Document</code>s that contain only <code class="language-plaintext highlighter-rouge">Path</code>s.  We can walk
the tree, doing step 1 for every <code class="language-plaintext highlighter-rouge">Document</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// add this to DocumentTree
</span>  <span class="k">def</span> <span class="nf">foreach</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Document</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SingleDocument</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">dts</span> <span class="nf">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">}</span>

<span class="c1">// now we can initialize the text everywhere,
// given some dtree: DocumentTree
</span><span class="n">dtree</span> <span class="nf">foreach</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">initText</span><span class="o">())</span>
</code></pre></div></div>

<p>The way software does, it got more complex.  And we can be ever less
sure that we’re doing things right, under this arrangement.</p>

<h2 id="the-four-phases-problem-stuck-in-a-tree">The four phases problem, stuck in a tree</h2>

<p>Our tree only supports one type of document.  We could choose the
final one, <code class="language-plaintext highlighter-rouge">Doc</code>, but there is no way to replicate more exotic
document tree initializations like the one above.</p>

<p>Instead, we want the type of the tree to adapt along with the document
changes.  If we have four states, <em>Foo</em>, <em>Bar</em>, <em>Baz</em>, and <em>Quux</em>, we
want four different kinds of <code class="language-plaintext highlighter-rouge">DocumentTree</code> to go along with them.  In
a language with type parameters, this is easy: we can model those four
as <code class="language-plaintext highlighter-rouge">DocTree[Foo]</code>, <code class="language-plaintext highlighter-rouge">DocTree[Bar]</code>, <code class="language-plaintext highlighter-rouge">DocTree[Baz]</code>, and
<code class="language-plaintext highlighter-rouge">DocTree[Quux]</code>, respectively, by adding a type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SingleDoc</span><span class="o">[</span><span class="kt">D</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">D</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocCategory</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]])</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>Now we need a replacement for the <code class="language-plaintext highlighter-rouge">foreach</code> that we used with the
unparameterized <code class="language-plaintext highlighter-rouge">DocumentTree</code> to perform each initialization step on
every <code class="language-plaintext highlighter-rouge">Document</code> therein.  Now that <code class="language-plaintext highlighter-rouge">DocTree</code> is agnostic with respect
to the specific document type, this is a little more abstract, but
quite idiomatic.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// add this to DocTree
</span>  <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">D2</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D2</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D2</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SingleDoc</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">SingleDoc</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">d</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">dts</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>It’s worth comparing these side by side.  Now we should be able to
step through initialization of <code class="language-plaintext highlighter-rouge">DocTree</code> with <code class="language-plaintext highlighter-rouge">map</code>, just as with
<code class="language-plaintext highlighter-rouge">DocumentTree</code> and <code class="language-plaintext highlighter-rouge">foreach</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">dtp</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">Path</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="s">"rt"</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nv">Paths</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="s">"hello.md"</span><span class="o">))))</span>
<span class="n">dtp</span><span class="k">:</span> <span class="kt">tmtp7.DocTree</span><span class="o">[</span><span class="kt">java.nio.file.Path</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">rt</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="nv">hello</span><span class="o">.</span><span class="py">md</span><span class="o">)))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">dtp</span> <span class="n">map</span> <span class="nv">Doc</span><span class="o">.</span><span class="py">initText</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">tmtp7.DocTree</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">DocCategory</span><span class="o">(</span><span class="n">rt</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="n">contents</span> <span class="n">of</span> <span class="n">the</span> <span class="nv">hello</span><span class="o">.</span><span class="py">md</span> <span class="n">file</span><span class="o">!)))</span>
</code></pre></div></div>

<h2 id="you-wouldnt-avoid-writing-functions-would-you">You wouldn’t avoid writing functions, would you?</h2>

<p>There is nothing magical about <code class="language-plaintext highlighter-rouge">DocTree</code> that makes it especially
amenable to the introduction of a type parameter.  This is <em>not</em> a
feature whose proper use is limited to highly abstract or
general-purpose data structures; with its <code class="language-plaintext highlighter-rouge">String</code>s and <code class="language-plaintext highlighter-rouge">Int</code>s strewn
about, it is <em>utterly</em> domain-specific, “business” code.</p>

<p>In fact, if we were likely to annotate <code class="language-plaintext highlighter-rouge">Doc</code>s with more data, <code class="language-plaintext highlighter-rouge">Doc</code>
would be a perfect place to add a type parameter!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// suppose we add some "extra" data
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Doc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
   <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)],</span>
   <span class="n">extra</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</code></pre></div></div>

<p>You can use a type parameter to represent one simple slot in an
otherwise concretely specified structure, as above.  You can
<a href="https://bitbucket.org/ermine-language/ermine-writers/src/9ec9a98c30bc9924cc49888895f8832e8ce4f8e1/writers/html/src/main/scala/com/clarifi/reporting/writers/HTMLDeps.scala?at=default#HTMLDeps.scala-37">use one to represent 10 slots</a>.</p>

<p>Parameterized types are the type system’s version of functions.  They
aren’t just for collections, abstract code, or highly general-purpose
libraries: they’re for <em>your</em> code!</p>

<p>Unless you are going to suggest that <em>functions</em> are “too academic”.
Or that functions have no place in “business logic”.  Or perhaps that,
while it would be nice to define functions to solve this, that, and
sundry, you’ll just do the quick no-defining-functions hack for now
and maybe come back to add some functions later when “paying off
technical debt”.  <em>Then</em>, I’m not sure what to say.</p>

<h2 id="the-virtuous-circle-of-fp-and-types">The virtuous circle of FP and types</h2>

<p>Now we are doing something very close to functional programming.
Moreover, we were led here not by a desire for referential
transparency, nor for purity, but merely for a way to represent the
states of our program in a more well-typed way.</p>

<p>In this series of posts, I have deliberately avoided discussion of
functional programming until this section; my chosen subject is types,
not functional programming.  But the features we have been considering
unavoidably coalesce here into an empirical argument for functional
programming.  Type parameters let us elegantly lift transformations
from one part of our program to another; the intractable complexities
of imperative type-changing direct us to program more functionally, by
computing new values instead of changing old ones, if we want access
to these features.  This, in turn, encourages ever more of our program
to be written in a functional style, just as the switch to different
<code class="language-plaintext highlighter-rouge">Doc</code> representations induced a switch to different document tree
representations, <code class="language-plaintext highlighter-rouge">map</code> instead of <code class="language-plaintext highlighter-rouge">foreach</code>.</p>

<h2 id="paying-it-back">Paying it Back</h2>

<p>Likewise, the use of functional programming style feeds back, in the
aforementioned virtuous circle, to encourage the use of stronger
types.</p>

<p>When we wanted stronger guarantees about the initialization of our
documents, and thereby also of the larger structures incorporating
them, we turned to the most powerful tool we have at our disposal for
describing and ensuring such guarantees: the type system.  In so
doing, we induced an explosion of explicit data representations; where
we had two, we now have eight, whose connections to each other are
mediated by the types of functions involved.</p>

<p>With the increase in the number of explicit concepts in the code comes
a greater need for an automatic method of keeping track of all these
connections.  The type system is ideally suited to this role.</p>

<div class="side-note">
  We induced more <em>explicit</em> data representation, not more
  representations overall.  The imperative <code>Document</code> has
  four stages of initialization, at each of which it exhibits
  different behavior.  All we have done is expose this fact to the
  type system level, at which our usage can be checked.
</div>

<h2 id="dont-miss-one">Don’t miss one!</h2>

<p>As it is declared, the type-changing <code class="language-plaintext highlighter-rouge">DocTree#map</code> has another
wonderful advantage over <code class="language-plaintext highlighter-rouge">DocumentTree#foreach</code>.</p>

<p>Let us say that each category should also have a document of its own,
not just a list of subtrees.  In refactoring, we adjust the
definitions of <code class="language-plaintext highlighter-rouge">DocumentCategory</code> or <code class="language-plaintext highlighter-rouge">DocCategory</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// imperative version
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocumentCategory</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">Document</span><span class="o">,</span>
   <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocumentTree</span><span class="o">])</span>
   <span class="k">extends</span> <span class="nc">DocumentTree</span>

<span class="c1">// functional version
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocCategory</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">D</span><span class="o">,</span>
   <span class="n">members</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>So far, so good.  Next, neither <code class="language-plaintext highlighter-rouge">foreach</code> nor <code class="language-plaintext highlighter-rouge">map</code> compile anymore.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TmTp7.scala:70: wrong number of arguments for pattern
⤹ tmtp7.DocumentCategory(name: String,doc: tmtp7.Document,
⤹                        members: List[tmtp7.DocumentTree])
      case DocumentCategory(_, dts) =&gt;
                           ^
TmTp7.scala:71: not found: value d
        f(d)
          ^
TmTp7.scala:91: wrong number of arguments for pattern
⤹ tmtp7.DocCategory[D](name: String,doc: D,members: List[tmtp7.DocTree[D]])
      case DocCategory(c, dts) =&gt;
                      ^
TmTp7.scala:92: not enough arguments for method
⤹ apply: (name: String, doc: D, members: List[tmtp7.DocTree[D]]
⤹        )tmtp7.DocCategory[D] in object DocCategory.
Unspecified value parameter members.
        DocCategory(c, dts map (_ map f))
                   ^
</code></pre></div></div>

<p>So let us fix <code class="language-plaintext highlighter-rouge">foreach</code> in the simplest way possible.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//                 added ↓
</span>    <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
</code></pre></div></div>

<p>This compiles.  It is wrong, and we can figure out exactly why by
trying the same shortcut with <code class="language-plaintext highlighter-rouge">map</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">case</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<p>We are treating the <code class="language-plaintext highlighter-rouge">d: D</code> like the <code class="language-plaintext highlighter-rouge">name: String</code>, just passing it
through.  It is “ignored” in precisely the same way as the <code class="language-plaintext highlighter-rouge">foreach</code>
ignores the new data.  But this version does not compile!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TmTp7</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">90</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">d.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">D</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">D2</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
                       <span class="o">^</span>
</code></pre></div></div>

<p>More broadly, <code class="language-plaintext highlighter-rouge">map</code> must return a <code class="language-plaintext highlighter-rouge">DocTree[D2]</code>.  By implication, the
second argument must be a <code class="language-plaintext highlighter-rouge">D2</code>, not a <code class="language-plaintext highlighter-rouge">D</code>.  We can fix it by using
<code class="language-plaintext highlighter-rouge">f</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">d</span><span class="o">),</span> <span class="n">dts</span> <span class="nf">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<p>Likewise, we should make a similar fix to <code class="language-plaintext highlighter-rouge">DocumentTree#foreach</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nf">f</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
      <span class="n">dts</span> <span class="nf">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<p>But only in the case of <code class="language-plaintext highlighter-rouge">map</code> did we get help from the compiler.
That’s because <code class="language-plaintext highlighter-rouge">DocumentTree</code> is not the only thing to gain a type
parameter in this new design.  When we made <code class="language-plaintext highlighter-rouge">DocTree</code> take one, it was
only natural to define <code class="language-plaintext highlighter-rouge">map</code> with one, too.</p>

<p>We can see how this works out by looking at both <code class="language-plaintext highlighter-rouge">foreach</code> and <code class="language-plaintext highlighter-rouge">map</code>
as the agents of our practical goal: transformation of the tree by
transforming the documents therein.  <code class="language-plaintext highlighter-rouge">foreach</code> works like this.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              document transformer
               (Document =&gt; Unit)
 DocumentTree ~~~~~~~~~~~~~~~~~~~&gt; DocumentTree
 ------------                      -----------------
initial state                      final state
  (old tree)                       (same type, “new”
                                    but same tree)
</code></pre></div></div>

<p>The way <code class="language-plaintext highlighter-rouge">map</code> looks at <code class="language-plaintext highlighter-rouge">DocTree</code> is very similar, and we give it the
responsibilities that <code class="language-plaintext highlighter-rouge">foreach</code> had, so it is unsurprising that the
“shape” we imagine for transformation is similar.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               document transformer
                    (D =&gt; D2)
    DocTree[D] ~~~~~~~~~~~~~~~~~~~~&gt; DocTree[D2]
 -------------                       ----------------
 initial state                       final state
  (old tree)                         (changed type,
                                      changed value!)
</code></pre></div></div>

<p>The replacement of <code class="language-plaintext highlighter-rouge">D</code> with <code class="language-plaintext highlighter-rouge">D2</code> also means that values of type <code class="language-plaintext highlighter-rouge">D</code>
cannot occur anywhere in the result, as <code class="language-plaintext highlighter-rouge">D</code> is abstract, so only
appears as <code class="language-plaintext highlighter-rouge">doc</code> by virtue of being the type parameter passed to
<code class="language-plaintext highlighter-rouge">DocTree</code> and its data constructors (er, “subclasses”).</p>

<p>As our result type is <code class="language-plaintext highlighter-rouge">DocTree[D2]</code>, we have two options, considering
only the result type:</p>

<ol>
  <li>return a <code class="language-plaintext highlighter-rouge">DocTree</code> with no <code class="language-plaintext highlighter-rouge">D2</code>s in its representation, one role of
<code class="language-plaintext highlighter-rouge">None</code> and <code class="language-plaintext highlighter-rouge">Nil</code> in <code class="language-plaintext highlighter-rouge">Option</code> and <code class="language-plaintext highlighter-rouge">List</code> respectively, or</li>
  <li>make <code class="language-plaintext highlighter-rouge">D2</code>s from the <code class="language-plaintext highlighter-rouge">D</code>s in the <code class="language-plaintext highlighter-rouge">DocTree[D]</code> we have in hand, by
passing them to the ‘document transformer’ <code class="language-plaintext highlighter-rouge">D =&gt; D2</code>.</li>
</ol>

<p>Similarly, no <code class="language-plaintext highlighter-rouge">DocTree[D]</code> values can appear anywhere in the result.
As with the <code class="language-plaintext highlighter-rouge">D</code>s, they must all be transformed or dropped, with a
different ‘empty’ <code class="language-plaintext highlighter-rouge">DocTree</code> chosen.</p>

<h2 id="the-dangers-of-simplifying">The dangers of “simplifying”</h2>

<p>Suppose we instead defined <code class="language-plaintext highlighter-rouge">map</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>If you subscribe to the idea of type parameters being for wonky
academics, this is “simpler”.  And it’s fine, I suppose, if you only
have one <code class="language-plaintext highlighter-rouge">D</code> in mind, one document type in mind.  Setting aside that
we have four, there is another problem.  Let’s take a look at the
“shape” of this transformation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               document transformer
                     (D =&gt; D)
    DocTree[D] ~~~~~~~~~~~~~~~~~~~~&gt; DocTree[D]
 -------------                       ----------------
 initial state                       final state
  (old tree)                         (but no promise,
                                      same type!)
</code></pre></div></div>

<p>The problem with a <code class="language-plaintext highlighter-rouge">D =&gt; D</code> transformer is that we can’t make promises
that all our data passed through it.  After all, a source <code class="language-plaintext highlighter-rouge">d</code> has the
same type as <code class="language-plaintext highlighter-rouge">f(d)</code>.  We could even get away with</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">map[D2]</code> is strictly more general.  <strong>Even if we have only one <code class="language-plaintext highlighter-rouge">D</code> in
mind for <code class="language-plaintext highlighter-rouge">DocTree</code>, it still pays to type-parameterize it and to add
‘type-changing’ extra type parameters like <code class="language-plaintext highlighter-rouge">D2</code>.</strong></p>

<h2 id="the-dangers-of-missing-values">The dangers of missing values</h2>

<p>Have you ever started getting a new bill, then missed a payment
because you thought you were covered for the month?</p>

<p>Have you ever gone on vacation and, in your relief at having not left
anything important at home, left something behind when packing for
your return trip?</p>

<p>This kind of thing cannot be characterized in the manner of “well, I
would just get a runtime error if I didn’t have a type checker, so
it’s fine.”  Yet it simply falls out of the system we have chosen;
moreover, we have barely begun to consider the possibilities.</p>

<p>In this series, I have focused on existential types, which we can in
one sense consider merely abstract types that the compiler checks that
we treat as independent, like <code class="language-plaintext highlighter-rouge">D</code> and <code class="language-plaintext highlighter-rouge">D2</code>.  Existential types are
only one natural outcome of the system of type abstraction brought to
us by type parameters; there are many more interesting conclusions,
like the ones described above.</p>

<p>Next, in
<a href="/blog/2016/01/28/existential-inside.html">“It’s existential on the inside”</a>,
we will see how deeply intertwined universal and existential types
really are.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 21 Sep 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/09/21/change-values.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/09/21/change-values.html</guid>
      </item>
    
      <item>
        <title>Symbolic operators and type classes for Cats</title>
        
          <dc:creator>non</dc:creator>
                
        <description><![CDATA[<p>This post is an introduction into how operators are implemented in Cats and has been originally published in <a href="https://gist.github.com/non/3abdb35a72c39276d3d9">August 2015</a>.
Some more details can be found in the <a href="/blog/2015/08/06/machinist.html">previous post</a>.</p>

<p>One of the simplest and most recognizable type classes is the semigroup.
This type class abstracts over the ability to combine values of a certain
type in an associative manner.</p>

<div class="side-note">
  What does <em>associativity</em> mean?
  We call an operation $\oplus$ associative, if for all $a$, $b$ and $c$, $a \oplus (b \oplus c) = (a \oplus b) \oplus c$ holds.
  Read more about this in the <a href="https://github.com/non/algebra#algebraic-properties-and-terminology">README of the algebra repository</a>.
</div>

<p>Cats provides <code class="language-plaintext highlighter-rouge">cats.Semigroup[A]</code> to model semigroups.
The <code class="language-plaintext highlighter-rouge">combine</code> method takes two values of the type <code class="language-plaintext highlighter-rouge">A</code> and returns an <code class="language-plaintext highlighter-rouge">A</code> value.</p>

<p>In addition, Cats defines syntax allowing the binary operator <code class="language-plaintext highlighter-rouge">|+|</code> to be
used in place of the <code class="language-plaintext highlighter-rouge">combine</code> method.</p>

<h2 id="small-example">Small example</h2>

<p>Here is a small method that provides a generic way to combine the elements
of a list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Semigroup</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="nf">gsum</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">values</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">if</span> <span class="o">(</span><span class="nv">values</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="nv">values</span><span class="o">.</span><span class="py">reduceLeft</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>(A similar method is built into Cats as <code class="language-plaintext highlighter-rouge">Semigroup.combineAllOption</code>.)</p>

<h2 id="how-does-it-work">How does it work?</h2>

<p>One of the parts of <code class="language-plaintext highlighter-rouge">gsum</code> that might be hard to understand is where
the <code class="language-plaintext highlighter-rouge">|+|</code> method comes from. Since <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are totally generic values
(of type <code class="language-plaintext highlighter-rouge">A</code>) how can we call a method on them?</p>

<p>To boil the example down further, consider this simpler example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="mi">19</span> <span class="o">|+|</span> <span class="mi">20</span> <span class="c1">// produces 39
</span></code></pre></div></div>

<p>How does this work? We know that the <code class="language-plaintext highlighter-rouge">Int</code> type does not have a <code class="language-plaintext highlighter-rouge">|+|</code> method.
Experienced Scala developers will suspect that implicits play a role here,
but what are the details?</p>

<h2 id="in-detail">In detail</h2>

<p>Let’s walk through how the expression <code class="language-plaintext highlighter-rouge">19 |+| 20</code> is compiled.</p>

<p>First, a <code class="language-plaintext highlighter-rouge">|+|</code> method is needed on <code class="language-plaintext highlighter-rouge">Int</code>. Since
<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/Int.scala"><code class="language-plaintext highlighter-rouge">Int</code></a>
does not provide one, the compiler searches for an implicit conversion to a
type that <em>does</em> have a <code class="language-plaintext highlighter-rouge">|+|</code> method.</p>

<p>Due to our import, it will find the
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/core/src/main/scala/cats/syntax/semigroup.scala#L8"><code class="language-plaintext highlighter-rouge">semigroupSyntax[A]</code></a>
method, which returns a type that has a <code class="language-plaintext highlighter-rouge">|+|</code> method (specifically
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/core/src/main/scala/cats/syntax/semigroup.scala#L12"><code class="language-plaintext highlighter-rouge">SemigroupOps[A]</code></a>).
However, <code class="language-plaintext highlighter-rouge">semigroupSyntax</code> requires an implicit <code class="language-plaintext highlighter-rouge">Semigroup[A]</code> value to be in scope.
Do we have a <code class="language-plaintext highlighter-rouge">Semigroup[Int]</code> in scope?</p>

<p>Yes we do. Our import also provides an implicit value <a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/std/src/main/scala/cats/std/anyval.scala#L23"><code class="language-plaintext highlighter-rouge">intGroup</code></a>
of type <code class="language-plaintext highlighter-rouge">AdditiveCommutativeGroup[Int]</code>. Leaving aside what <em>additive</em>, <em>commutative</em>,
and <em>group</em> mean here, this is a subtype of <code class="language-plaintext highlighter-rouge">Semigroup[Int]</code>, so it matches.</p>

<p>Let’s continue with our current example. At this point we have gone from:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">19</span> <span class="o">|+|</span> <span class="mi">20</span> <span class="c1">// produces 39
</span></code></pre></div></div>

<p>to:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semigroupSyntax</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">19</span><span class="o">)(</span><span class="n">intGroup</span><span class="o">)</span> <span class="o">|+|</span> <span class="mi">20</span>
</code></pre></div></div>

<p>But we aren’t out of the woods yet! We still need to see how this expression
is evaluated.</p>

<h2 id="of-macros-and-machinists">Of macros and machinists</h2>

<p>Looking at how the <code class="language-plaintext highlighter-rouge">|+|</code> method is
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/core/src/main/scala/cats/syntax/semigroup.scala#L13">implemented</a>
reveals the cryptic <code class="language-plaintext highlighter-rouge">macro Ops.binop[A, A]</code>. What is this?</p>

<p>Following the rabbit hole farther, we come to
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/macros/src/main/scala/cats/macros/Ops.scala#L6"><code class="language-plaintext highlighter-rouge">cats.macros.Ops</code></a>
which provides the macro implementation that <code class="language-plaintext highlighter-rouge">|+|</code> is using. Aside from a
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/macros/src/main/scala/cats/macros/Ops.scala#L18">suggestively named</a>
item in the <code class="language-plaintext highlighter-rouge">operatorNames</code> map, we don’t have any clues what is going on.</p>

<p>The <a href="https://github.com/typelevel/machinist">machinist</a> project was created
to optimize exactly this kind of implicit syntax problem. What will happen here
is that <code class="language-plaintext highlighter-rouge">operatorNames</code> describes how to rewrite expressions using type
classes. Long-story short, we will transform:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semigroupSyntax</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">19</span><span class="o">)(</span><span class="n">intGroup</span><span class="o">)</span> <span class="o">|+|</span> <span class="mi">20</span>
</code></pre></div></div>

<p>into:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">intGroup</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="mi">19</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
</code></pre></div></div>

<p>The aforementioned suggestive map item tells us that we should rewrite the <code class="language-plaintext highlighter-rouge">|+|</code> operator
to method calls on the given type class (i.e. <code class="language-plaintext highlighter-rouge">intGroup</code>) using <code class="language-plaintext highlighter-rouge">.combine</code>.</p>

<h2 id="finishing-up">Finishing up</h2>

<p>Just to confirm that we’re done, let’s look at what <code class="language-plaintext highlighter-rouge">intGroup.combine</code> will do.
We started with a call to <code class="language-plaintext highlighter-rouge">AdditiveCommutativeGroup[Int]</code>, which will find
<a href="https://github.com/non/algebra/blob/v0.3.1/std/shared/src/main/scala/algebra/std/int.scala#L12"><code class="language-plaintext highlighter-rouge">intAlgebra</code></a>.
Then we call the <a href="https://github.com/non/algebra/blob/v0.3.1/core/src/main/scala/algebra/ring/Additive.scala#L93"><code class="language-plaintext highlighter-rouge">.additive</code></a>
method on it to produce a <code class="language-plaintext highlighter-rouge">CommutativeGroup[Int]</code>.</p>

<p>So putting that together, we can see that calling <code class="language-plaintext highlighter-rouge">intGroup.combine(19, 20)</code>
will call <code class="language-plaintext highlighter-rouge">intAlgebra.plus(19, 20)</code>, and that this is defined as <code class="language-plaintext highlighter-rouge">19 + 20</code>,
as we would expect.</p>

<p>Whew!</p>

<h2 id="conclusion">Conclusion</h2>

<p>This is a lot of machinery. The incredibly terse and expressive syntax it
enables is quite nice, but you can see that even leaving out one import
will cause the whole edifice to come tumbling down.</p>

<p>The easiest way to use Cats is to just import <code class="language-plaintext highlighter-rouge">cats.implicits._</code>. That
way, you can be sure that you have all of it. There are individual imports
from <code class="language-plaintext highlighter-rouge">cats.syntax</code> and <code class="language-plaintext highlighter-rouge">cats.std</code> which can be used to pinpoint the exact
values and method you want to put into scope, but getting these right
can be a bit tricky, especially for newcomers.</p>

<p>Some more examples of Machinist can be found in the <a href="https://github.com/typelevel/machinist/blob/v0.4.1/README.md#examples">README</a>.</p>

<h2 id="errata">Errata</h2>

<p>You may also decide that the syntax convenience is not worth it. To write our
original example without syntax implicits (but still using implicit values)
you could say:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Semigroup</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="nf">gsum</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">values</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nf">if</span> <span class="o">(</span><span class="nv">values</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="nv">values</span><span class="o">.</span><span class="py">reduceLeft</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">s</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>

<span class="c1">// values.reduceLeft(s.combine) would also work
</span></code></pre></div></div>

<p>Whether to use syntax implicits or explicit method calls is mostly a matter
of preference. Personally, I like using syntax explicits to help make generic
code read in a clearer manner, but as always, your mileage may vary.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 07 Aug 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/08/07/symbolic-operators.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/08/07/symbolic-operators.html</guid>
      </item>
    
      <item>
        <title>Machinist vs. value classes</title>
        
          <dc:creator>non</dc:creator>
                
        <description><![CDATA[<p>This article is about <a href="https://github.com/typelevel/machinist">machinist</a>, a stand-alone project which started out as part of the <a href="https://github.com/non/spire">spire</a> project and has been originally published in <a href="https://gist.github.com/non/a6ff3c0796e566db20d1">October 2014</a>.
The original description can be found on <a href="/blog/2013/10/13/spires-ops-macros.html">this blog</a>.
You should read that linked post first if you are not familiar with how Machinist works.</p>

<h2 id="introduction">Introduction</h2>

<p><a href="https://github.com/typelevel/machinist/issues/2">Machinist Issue #2</a> asks:</p>

<blockquote>
  <p>Is it correct, that this stuff is completely obsolete now due to
value classes or are there still some use cases? An example of using
value class for zero-cost implicit enrichment: […]</p>
</blockquote>

<p>The short answer is that value classes existed before the Machinist macros were implemented, and they do not solve the same problem Machinist solves.</p>

<p>This article is the long answer.</p>

<h2 id="the-base-case">The base case</h2>

<p>The Machinist’s goal is to remove <em>any</em> overhead that would distinguish
using a type class “directly” from using it indirectly via an implicit
operator.</p>

<p>Imagine we have the following “toy” type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Div</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">DivString</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">rhs</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This allows us to write generic code such as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Test1</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">gen</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">ev</span><span class="o">.</span><span class="py">div</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nf">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have a generic method <code class="language-plaintext highlighter-rouge">gen</code> that works with any type we have a <code class="language-plaintext highlighter-rouge">Div[A]</code> instance for, and we verify that it works using a <code class="language-plaintext highlighter-rouge">test</code> method that operates on some strings. So far, so good. But obviously, calling <code class="language-plaintext highlighter-rouge">ev.div</code> is a bit ugly.</p>

<h2 id="implicit-conversion-with-a-value-class">Implicit conversion with a value class</h2>

<p>We can make the <code class="language-plaintext highlighter-rouge">gen</code> method look a bit nicer by using an implicit conversion. Here’s the code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="nv">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">/</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">ev</span><span class="o">.</span><span class="py">div</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test3.DivOps</span>
  <span class="k">def</span> <span class="nf">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="nf">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nf">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, we can just say <code class="language-plaintext highlighter-rouge">x / y</code> and have that call <code class="language-plaintext highlighter-rouge">Div#div</code> automatically. We also don’t need a reference to <code class="language-plaintext highlighter-rouge">ev: Div[A]</code> so we can use the nicer <code class="language-plaintext highlighter-rouge">[A: Div]</code> syntax.</p>

<p>With a normal implicit conversion, every call to <code class="language-plaintext highlighter-rouge">gen</code> would construct an instance of <code class="language-plaintext highlighter-rouge">Test3.DivOps</code>. However, since we have defined <code class="language-plaintext highlighter-rouge">Test3.DivOps</code> as a value class (by extending <code class="language-plaintext highlighter-rouge">AnyVal</code>), the object instantiation is ellided. Instead, the method call is dispatched to <code class="language-plaintext highlighter-rouge">Test3.DivOps.$div$extension</code> which calls <code class="language-plaintext highlighter-rouge">ev.div</code>.</p>

<p>We often talk about value classes as not having a <em>cost</em>. Since no class is instantiated, we are not required to pay a cost in allocations, but we do still pay a cost in indirection (instead of calling <code class="language-plaintext highlighter-rouge">ev.div</code> directly as in <code class="language-plaintext highlighter-rouge">Test1</code> we have an intermediate extension method).</p>

<p>You can see the difference in the output from <code class="language-plaintext highlighter-rouge">javap</code>.</p>

<p>In the case of <code class="language-plaintext highlighter-rouge">Test1.gen</code>, the call to <code class="language-plaintext highlighter-rouge">ev.div</code> and return are all handled with 5 instructions (8 bytes of bytecode):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// cost.Test1.gen(A, A, Div[A]): A
0: aload_3
1: aload_1
2: aload_2
3: invokeinterface #16,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
8: areturn
</code></pre></div></div>

<p>In the case of <code class="language-plaintext highlighter-rouge">Test3.gen</code>, there is extra ceremony setting up the companion objects, and a call to the extension method (<code class="language-plaintext highlighter-rouge">$div$extension</code>), which is defined in <code class="language-plaintext highlighter-rouge">Test3.DivOps</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// cost.Test3.gen(A, A, Div[A]): A
0: getstatic     #25                 // Field cost/Test3$DivOps$.MODULE$:Lcost/Test3$DivOps$;
3: getstatic     #16                 // Field cost/Test3$.MODULE$:Lcost/Test3$;
6: aload_1
7: invokevirtual #18                 // Method cost/Test3$.DivOps:(Ljava/lang/Object;)Ljava/lang/Object;
10: aload_2
11: aload_3
12: invokevirtual #28                 // Method cost/Test3$DivOps$.$div$extension:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
15: areturn

// cost.Test3.DivOps.$div$extension(A, A, Div[A]): A
0: aload_3
1: aload_1
2: aload_2
3: invokeinterface #20,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
8: areturn
</code></pre></div></div>

<p>In fact the bytecode for the extension method is uncannily similar to that of <code class="language-plaintext highlighter-rouge">Test1.gen</code>, but in this case <code class="language-plaintext highlighter-rouge">Test3.gen</code> involves 8 more instructions (15 bytes).</p>

<p>In some cases these bytecode differences might not be significant (for example if the running time of <code class="language-plaintext highlighter-rouge">Div[A].div</code> is expected to dwarf the cost of method dispatch). However, when type classes are used to support primitive operations (such as addition or comparisons) it’s likely that this overhead might be significant.</p>

<h2 id="enter-machinist">Enter machinist</h2>

<p>Machinist is based on a set of macros that were introduced in <a href="https://github.com/non/spire">Spire</a> to remove the performance penalties associated with generic math implementations. These macros were based on an even earlier approach which used a compiler plugin.</p>

<p>The basic approach has not changed: at compile-time we can detect situations where we build an object just to assemble a method call with the arguments to its constructor. In these cases we rewrite the tree, removing the object allocation and making the method call directly. Machinist’s documentation goes to some trouble to explain it, but basically, we want to be able to write code like <code class="language-plaintext highlighter-rouge">Test3.gen</code> but have it interpreted as <code class="language-plaintext highlighter-rouge">Test1.gen</code>. That is literally the entire purpose of machinist.</p>

<p>Here’s a construction that works for this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">/</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">macro</span> <span class="nv">machinist</span><span class="o">.</span><span class="py">DefaultOps</span><span class="o">.</span><span class="py">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test2.DivOps</span>
  <span class="k">def</span> <span class="nf">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="nf">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nf">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We use the <code class="language-plaintext highlighter-rouge">machinist.DefaultOps</code> object to provide an instance of the <code class="language-plaintext highlighter-rouge">binop</code> macros, which will rewrite <code class="language-plaintext highlighter-rouge">DivOps(x)(ev).$div(y)</code> into <code class="language-plaintext highlighter-rouge">ev.div(x, y)</code>.</p>

<p>Here’s what we end up with in bytecode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// cost.Test2.gen(A, A, Div[A]): A
0: aload_3
1: aload_1
2: aload_2
3: invokeinterface #26,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
8: areturn
</code></pre></div></div>

<p>As you can see, the sourcecode for <code class="language-plaintext highlighter-rouge">Test2.gen</code> is identical to <code class="language-plaintext highlighter-rouge">Test3.gen</code>, and the bytecode for <code class="language-plaintext highlighter-rouge">Test2.gen</code> is identical to that of <code class="language-plaintext highlighter-rouge">Test1.gen</code>. Success!</p>

<h2 id="caveats">Caveats</h2>

<p>There are a few caveats that are worth mentioning:</p>

<h3 id="managing-compilation-units">Managing compilation units</h3>

<p>The issue that sparked this article used the operator <code class="language-plaintext highlighter-rouge">+/+</code>. Machinist claims to be able to support any symbolic operator. Why didn’t we use that operator here?</p>

<p>The answer has to do with how Scala macros work. Scala requires that macros be defined in a separate “compilation unit” from the one they are invoked in. This makes it very awkward to create a code snippet that both defines and uses a macro. In this case, it means that we can’t extend <code class="language-plaintext highlighter-rouge">machinist.Ops</code> to define new symbolic operators in the same file that demonstrates their use. This is why we used <code class="language-plaintext highlighter-rouge">/</code> (which maps to <code class="language-plaintext highlighter-rouge">div</code> and is a “default operator”).</p>

<p>You can arrange your “real” projects so that they are not affected by this limitation.</p>

<h3 id="use-outside-of-generic-methods">Use outside of generic methods</h3>

<p>Now that we’ve demonstrated the cost that implicit conversions to value classes impose, you might imagine wanting to perform this transformation on <em>all</em> your implicit conversions.</p>

<p>Unfortunately, Machinist is not sufficiently general to support this. Right now its macros support a number of different “shapes” but assume generic method which dispatches to an implicit evidence parameter. It might be possible to write macros which inline the method body of a concrete implicit class, but that’s outside the scope of the project.</p>

<h2 id="postscript-messy-details">Postscript: messy details</h2>

<p>This article throws around a lot of source code and bytecode.  Below are included the files needed to build the demo (<code class="language-plaintext highlighter-rouge">cost.scala</code> and <code class="language-plaintext highlighter-rouge">build.sbt</code>) as well as the <code class="language-plaintext highlighter-rouge">javap</code> output from the three test classes, and the value class.</p>

<h3 id="costscala">cost.scala</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">cost</span>

<span class="k">import</span> <span class="nn">language.implicitConversions</span>
<span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>

<span class="k">trait</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Div</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">DivString</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">rhs</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test1</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">gen</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">ev</span><span class="o">.</span><span class="py">div</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nf">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">/</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">macro</span> <span class="nv">machinist</span><span class="o">.</span><span class="py">DefaultOps</span><span class="o">.</span><span class="py">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test2.DivOps</span>
  <span class="k">def</span> <span class="nf">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="nf">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nf">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="nv">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">/</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">ev</span><span class="o">.</span><span class="py">div</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test3.DivOps</span>
  <span class="k">def</span> <span class="nf">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="nf">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nf">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="buildsbt">build.sbt</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">:=</span> <span class="s">"cost"</span>

<span class="n">scalaVersion</span> <span class="o">:=</span> <span class="s">"2.11.2"</span>

<span class="n">resolvers</span> <span class="o">+=</span> <span class="s">"bintray/non"</span> <span class="n">at</span> <span class="s">"http://dl.bintray.com/non/maven"</span>

<span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"org.typelevel"</span> <span class="o">%%</span> <span class="s">"machinist"</span> <span class="o">%</span> <span class="s">"0.2.2"</span>
</code></pre></div></div>

<h3 id="test1out">Test1.out</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test1 {
  public &lt;A extends java/lang/Object&gt; A gen(A, A, cost.Div&lt;A&gt;);
    Code:
       0: aload_3       
       1: aload_1       
       2: aload_2       
       3: invokeinterface #16,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
       8: areturn       

  public java.lang.String test();
    Code:
       0: aload_0       
       1: ldc           #27                 // String foo
       3: ldc           #29                 // String bar
       5: getstatic     #35                 // Field cost/Div$.MODULE$:Lcost/Div$;
       8: invokevirtual #39                 // Method cost/Div$.DivString:()Lcost/Div;
      11: invokevirtual #41                 // Method gen:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      14: checkcast     #43                 // class java/lang/String
      17: areturn       

  public cost.Test1();
    Code:
       0: aload_0       
       1: invokespecial #47                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
}
</code></pre></div></div>

<h3 id="test2out">Test2.out</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test2 {
  public static &lt;A extends java/lang/Object&gt; cost.Test2$DivOps&lt;A&gt; DivOps(A, cost.Div&lt;A&gt;);
    Code:
       0: getstatic     #16                 // Field cost/Test2$.MODULE$:Lcost/Test2$;
       3: aload_0       
       4: aload_1       
       5: invokevirtual #18                 // Method cost/Test2$.DivOps:(Ljava/lang/Object;Lcost/Div;)Lcost/Test2$DivOps;
       8: areturn       

  public &lt;A extends java/lang/Object&gt; A gen(A, A, cost.Div&lt;A&gt;);
    Code:
       0: aload_3       
       1: aload_1       
       2: aload_2       
       3: invokeinterface #26,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
       8: areturn       

  public java.lang.String test();
    Code:
       0: aload_0       
       1: ldc           #37                 // String foo
       3: ldc           #39                 // String bar
       5: getstatic     #44                 // Field cost/Div$.MODULE$:Lcost/Div$;
       8: invokevirtual #48                 // Method cost/Div$.DivString:()Lcost/Div;
      11: invokevirtual #50                 // Method gen:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      14: checkcast     #52                 // class java/lang/String
      17: areturn       

  public cost.Test2();
    Code:
       0: aload_0       
       1: invokespecial #56                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
}
</code></pre></div></div>

<h3 id="test3out">Test3.out</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test3 {
  public static java.lang.Object DivOps(java.lang.Object);
    Code:
       0: getstatic     #16                 // Field cost/Test3$.MODULE$:Lcost/Test3$;
       3: aload_0       
       4: invokevirtual #18                 // Method cost/Test3$.DivOps:(Ljava/lang/Object;)Ljava/lang/Object;
       7: areturn       

  public &lt;A extends java/lang/Object&gt; A gen(A, A, cost.Div&lt;A&gt;);
    Code:
       0: getstatic     #25                 // Field cost/Test3$DivOps$.MODULE$:Lcost/Test3$DivOps$;
       3: getstatic     #16                 // Field cost/Test3$.MODULE$:Lcost/Test3$;
       6: aload_1       
       7: invokevirtual #18                 // Method cost/Test3$.DivOps:(Ljava/lang/Object;)Ljava/lang/Object;
      10: aload_2       
      11: aload_3       
      12: invokevirtual #28                 // Method cost/Test3$DivOps$.$div$extension:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      15: areturn       

  public java.lang.String test();
    Code:
       0: aload_0       
       1: ldc           #39                 // String foo
       3: ldc           #41                 // String bar
       5: getstatic     #46                 // Field cost/Div$.MODULE$:Lcost/Div$;
       8: invokevirtual #50                 // Method cost/Div$.DivString:()Lcost/Div;
      11: invokevirtual #52                 // Method gen:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      14: checkcast     #54                 // class java/lang/String
      17: areturn       

  public cost.Test3();
    Code:
       0: aload_0       
       1: invokespecial #58                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
}
</code></pre></div></div>

<h3 id="test3divopsout">Test3.DivOps.out</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test3$DivOps$ {
  public static final cost.Test3$DivOps$ MODULE$;

  public static {};
    Code:
       0: new           #2                  // class cost/Test3$DivOps$
       3: invokespecial #12                 // Method "&lt;init&gt;":()V
       6: return        

  public final &lt;A extends java/lang/Object&gt; A $div$extension(A, A, cost.Div&lt;A&gt;);
    Code:
       0: aload_3       
       1: aload_1       
       2: aload_2       
       3: invokeinterface #20,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
       8: areturn       

  public final &lt;A extends java/lang/Object&gt; int hashCode$extension(A);
    Code:
       0: aload_1       
       1: invokevirtual #32                 // Method java/lang/Object.hashCode:()I
       4: ireturn       

  public final &lt;A extends java/lang/Object&gt; boolean equals$extension(A, java.lang.Object);
    Code:
       0: aload_2       
       1: astore_3      
       2: aload_3       
       3: instanceof    #36                 // class cost/Test3$DivOps
       6: ifeq          15
       9: iconst_1      
      10: istore        4
      12: goto          18
      15: iconst_0      
      16: istore        4
      18: iload         4
      20: ifeq          61
      23: aload_2       
      24: ifnonnull     31
      27: aconst_null   
      28: goto          38
      31: aload_2       
      32: checkcast     #36                 // class cost/Test3$DivOps
      35: invokevirtual #40                 // Method cost/Test3$DivOps.lhs:()Ljava/lang/Object;
      38: astore        5
      40: aload_1       
      41: aload         5
      43: invokestatic  #45                 // Method scala/runtime/BoxesRunTime.equals:(Ljava/lang/Object;Ljava/lang/Object;)Z
      46: ifeq          53
      49: iconst_1      
      50: goto          54
      53: iconst_0      
      54: ifeq          61
      57: iconst_1      
      58: goto          62
      61: iconst_0      
      62: ireturn       

  public cost.Test3$DivOps$();
    Code:
       0: aload_0       
       1: invokespecial #47                 // Method java/lang/Object."&lt;init&gt;":()V
       4: aload_0       
       5: putstatic     #49                 // Field MODULE$:Lcost/Test3$DivOps$;
       8: return        
}
</code></pre></div></div>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 06 Aug 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/08/06/machinist.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/08/06/machinist.html</guid>
      </item>
    
      <item>
        <title>Values never change types</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the sixth of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>In a subtyping language such as Java or Scala, first-class
existentials are a helpful ally for modeling values and methods that
abstract over subtypes in different ways.  In a language with
mutation, such as Java or Scala, existentials help deal with certain
kinds of state changes without violating type safety.</p>

<p>But values, <em>themselves</em>, never change types.  When you first practice
with existentials, the Java and Scala compilers seem to become
veritable minefields of type errors—do something slightly different in
your code, and everything falls apart.  But this is just about
<a href="http://blog.higher-order.com/blog/2014/12/21/maximally-powerful/">nothing being a free lunch</a>:
<strong>the wide variety of values meeting any given existential type,
combined with the possibility for mutation, means a sound typechecker
must be very conservative about what it permits when using those
values</strong>.</p>

<p>So, in this article, we’ll explore some of these type error pitfalls,
see why it’s perfectly reasonable for the compilers to complain about
these pieces of code, and fix the errors using the equivalence rules
we’ve learned about in previous articles.  This is a big topic, so in
the next article, we’ll talk about taking advantage of the freedoms
that the compilers are concerned about in this one.</p>

<h2 id="aliasing-prevents-replacement">Aliasing prevents replacement</h2>

<p>Let’s say you have a list of strings, <code class="language-plaintext highlighter-rouge">strs: List[String]</code>.  But you
want that value to change: you want it to be a <code class="language-plaintext highlighter-rouge">List[Int]</code> instead.
Maybe every value in the list parses to an integer and you want to
“map in place”; maybe you want to use <code class="language-plaintext highlighter-rouge">-1</code> for every string that can’t
be parsed.</p>

<p>Generic systems like those of Java, Scala, and the ML family don’t let
you do this for a few reasons.</p>

<p>First, with regard to structures like <code class="language-plaintext highlighter-rouge">List</code>, let’s suppose we are
adding this feature to the type system, and that the list has type
<code class="language-plaintext highlighter-rouge">List[String]</code> before replacement, and <code class="language-plaintext highlighter-rouge">List[Int]</code> after.  What type
does it have when we’re halfway done?  The type system requires us to
<em>guarantee</em> that there are no strings, only ints, left once we’re
done; how do we track our progress?  Remember that vague promises of
“I tested the code” are meaningless to the type system; you have to
<em>prove</em> it mathematically.  This is a solvable problem, but the known
solutions far complicate the type system beyond the design goals of
these languages: the cost is far too high for the benefit.</p>

<p>Second, let us suppose that we’ve solved the first problem.  Or, let
us suppose that we introduce a structure for which this isn’t a
problem.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">OneThing</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
</code></pre></div></div>

<p>There, no chance of “halfway done” there!  But something else happens.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">strs</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OneThing</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="nv">strs</span><span class="o">.</span><span class="py">value</span> <span class="k">=</span> <span class="mi">42</span>
<span class="c1">// won't compile, just a thought experiment
</span></code></pre></div></div>

<p>Now, presumably, completely aside from the value, the variable <code class="language-plaintext highlighter-rouge">strs</code>
has <em>changed types</em> to <code class="language-plaintext highlighter-rouge">OneThing[Int]</code>.  Not just the value in it, the
variable itself.  OK, so what if that variable came from someplace
else?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">replaceWithInt</span><span class="o">(</span><span class="n">ote</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="nv">t</span><span class="o">.</span><span class="py">value</span> <span class="k">=</span> <span class="mi">42</span>

<span class="k">val</span> <span class="nv">strs</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OneThing</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="nf">replaceWithInt</span><span class="o">(</span><span class="n">strs</span><span class="o">)</span>
<span class="c1">// also won't compile, thought experiment
</span></code></pre></div></div>

<p>Now, the type of <code class="language-plaintext highlighter-rouge">replaceWithInt</code> must contain a note that “by the
way, the type of <code class="language-plaintext highlighter-rouge">ote</code>, and any variables that refer to it, and any
variables that refer to <em>those</em> variables, and so on until it stops,
will change as a result of this call”.</p>

<p>This is a problem of <em>aliases</em>, all the locations that may refer to a
value.  If you change the type of the value, you also have to update
every reference to it, at compile time!  This is <em>the type system</em>;
your promise that you have no other references is not good enough.
You have to <em>prove</em> it.</p>

<p>As with the previous problem, the known solutions to this problem
would complicate the type systems of Java and Scala beyond their
design goals.  In a sense, <strong>this aspect of their type systems can be
considered to encourage functional programming</strong>.  A type-changing map
that builds a new list of the new type, or what have you, instead of
mutating the old one, is <em>trivial</em> in the Java/Scala generics systems.
There are no chances of aliasing problems, because no one could
possibly have an unknown reference to the value you just constructed.
This is a even more obvious design choice in the ML family languages,
which make no secret of favoring functional programming.</p>

<h2 id="assignment-rewrites-existentials">Assignment rewrites existentials</h2>

<p><a href="/blog/2015/07/16/method-equiv.html">We saw earlier</a> that a simple get from a
<code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>, followed by adding that value right back to the same list,
didn’t work, but if we took that <code class="language-plaintext highlighter-rouge">xs</code> and passed it to a
type-parameterized version, everything worked fine.  Why is that?</p>

<p>If you have a <em>mutable</em> variable of an existential type, the
existentialized part of the type may have different [type] values at
different parts of the program.  Let’s use
<a href="/blog/2015/07/23/type-projection.html#a-good-reason-to-use-type-members">the <code class="language-plaintext highlighter-rouge">StSource</code> from the projection post</a>.
Note that the <code class="language-plaintext highlighter-rouge">S</code> member is existential, because we did not bind it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">mxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="c1">// at this point in the program, the S is Int
</span><span class="k">val</span> <span class="nv">s1</span> <span class="k">=</span> <span class="nv">mxs</span><span class="o">.</span><span class="py">init</span>
<span class="c1">// now I'm going to change mxs
</span><span class="n">mxs</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="s">"ab"</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nv">x</span><span class="o">.</span><span class="py">reverse</span><span class="o">))</span>
<span class="c1">// at this point in the program, the S is String
</span><span class="nv">mxs</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>

<span class="nv">TmTp6</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">14</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp6.Tmtp4Funs.s1.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">#</span><span class="kt">S</span><span class="o">)</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">2</span><span class="kt">.S</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">2</span><span class="kt">:</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="nv">mxs</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
         <span class="o">^</span>
</code></pre></div></div>

<p>And it’s good that this happens, because the value we got from <code class="language-plaintext highlighter-rouge">init</code>
is definitely incompatible with the argument type to <code class="language-plaintext highlighter-rouge">emit</code>.</p>

<p>If we don’t want to track when this happens—and we certainly can’t
decide, in all cases, when a mutable variable such as this has been
overwritten so as to change its existentials, given the freedoms
afforded by Java—how can we treat a mutable variable with existentials
as safe?  The type system makes a simplifying assumption: <em>every
reference to the variable gets fresh values to fill in the
existentials</em>.</p>

<p>If it helps, you can think of a mutable variable as an <em>immutable</em>
variable that wraps its type with an extra layer.  In fact, that’s
<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/runtime/ObjectRef.java#L14-L17">what scalac does when you capture a <code class="language-plaintext highlighter-rouge">var</code></a>.
So <code class="language-plaintext highlighter-rouge">mxs</code> is, in a sense, of type <code class="language-plaintext highlighter-rouge">Ref[StSource[String]]</code>, where</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">value</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="nf">update</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So, by substitution, the variable <code class="language-plaintext highlighter-rouge">mxs</code> is really a pair of functions,
<code class="language-plaintext highlighter-rouge">() =&gt; StSource[String]</code> and <code class="language-plaintext highlighter-rouge">StSource[String] =&gt; Unit</code>.  The “getter”
returns <code class="language-plaintext highlighter-rouge">StSource[String]</code>; each time you invoke that getter, you
might get an <code class="language-plaintext highlighter-rouge">StSource[String]</code> with a different <code class="language-plaintext highlighter-rouge">S</code> member, because
the <code class="language-plaintext highlighter-rouge">forSome</code> effectively occurs inside the body, as described in
<a href="/blog/2015/07/27/nested-existentials.html#what-if-we-list-different-existentials">the substitutions of “Nested existentials”</a>.</p>

<p>Of course, this means you can take advantage of this in your own
designs, to get <em>some</em> of the behavior of a type-changing value
mutation.  The use of variable references to delineate existentials
means that, even when we replace <code class="language-plaintext highlighter-rouge">mxs</code> above, the behavior of the
variable in the context of an instance hasn’t really changed, so
nothing about the containing value’s type has changed.  We thus
preserve our property, that values never change types.</p>

<p>When you make a single reference, it has to be consistent; subsequent
mutations have no effect on the value we got from that reference.  So
we can pass that reference somewhere that asserts that this doesn’t
happen in its own context, such as a type-parameterized
≡<em><sub><small>m</small></sub></em> method.  If you have a mutable variable
of type <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code>, even if you don’t know what <code class="language-plaintext highlighter-rouge">T</code> is, you know that
any updates to that variable will keep the same <code class="language-plaintext highlighter-rouge">T</code>.</p>

<h2 id="making-variables-read-only-matters">Making variables read-only matters</h2>

<p>If I change the variable to <code class="language-plaintext highlighter-rouge">final</code> in Java, and remove mutation, I
shouldn’t have this problem anymore.  Surprisingly, I do; this is what
happened in
<a href="/blog/2015/07/16/method-equiv.html">the original <code class="language-plaintext highlighter-rouge">copyToZero</code> example</a>,
where the argument was declared <code class="language-plaintext highlighter-rouge">final</code>.  I assume that this is just a
simplifying assumption in <code class="language-plaintext highlighter-rouge">javac</code>, that the extra guarantee of
unchanging existentials offered by <code class="language-plaintext highlighter-rouge">final</code> isn’t understood by the
compiler.</p>

<p>In the case of Scala, though, <strong>when you are using existential type
members, Scala can understand the implications of an immutable
variable, declared with <code class="language-plaintext highlighter-rouge">val</code></strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">imxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">s1</span> <span class="k">=</span> <span class="nv">imxs</span><span class="o">.</span><span class="py">init</span>
<span class="c1">// you can do whatever you want here; the compiler will stop you from
// changing imxs
</span><span class="nv">imxs</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</code></pre></div></div>

<p>It can’t pull off this trick for type parameters, having just as much
trouble as Java there.  So this is another reason for
<a href="/blog/2015/07/13/type-members-parameters.html">our original rule of thumb</a>.</p>

<h2 id="naming-the-existential">Naming the existential</h2>

<p>The benefit we get from
<a href="/blog/2015/07/16/method-equiv.html">passing <code class="language-plaintext highlighter-rouge">copyToZeroP</code>’s argument to <code class="language-plaintext highlighter-rouge">copyToZeroT</code></a>
is that we <em>name</em> the existential for the single reference to the
argument that we make.  We name it <code class="language-plaintext highlighter-rouge">T</code> there, for the scope of its
invocation.</p>

<p>Likewise, in Scala, each <code class="language-plaintext highlighter-rouge">val</code> introduces, while it is in scope, each
existential member it has, as a type name.  There are
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#paths">a lot of rules in Scala</a>
for exactly when this happens, but you may want to simply experiment.
We got a hint of what that name is
<a href="/blog/2015/07/23/type-projection.html#type-parameters-see-existentially">when we used <code class="language-plaintext highlighter-rouge">StSource</code> existentially in the REPL</a>.
Here’s the previous example again, with a type annotation for <code class="language-plaintext highlighter-rouge">s1</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">imxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">s1</span><span class="k">:</span> <span class="kt">imxs.S</span> <span class="o">=</span> <span class="nv">imxs</span><span class="o">.</span><span class="py">init</span>
<span class="nv">imxs</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</code></pre></div></div>

<p>We have gained convenience, not power, with this <em>path-dependent
types</em> feature; we can always pass into a type-parameterized local
method, with only the inconvenience of having to write out the whole
polymorphic method and call dance.  Moreover, this is nowhere near
<a href="/blog/2015/07/23/type-projection.html#a-failed-attempt-at-simplified-emitting">a solution to the type projection problem</a>;
there are too many things that a type parameter can do that we can’t
with this feature.  But we’ll dive into that in a later post.</p>

<h2 id="by-name-existential-arguments-arent-equivalent">By-name existential arguments aren’t equivalent!</h2>

<p>There is another little corner case in method equivalence to consider.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">copyToZeroNP</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="k">def</span> <span class="nf">copyToZeroNT</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
</code></pre></div></div>

<p>These method types are not equivalent!  That’s because <code class="language-plaintext highlighter-rouge">copyToZeroNP</code>
can be called with a by-name <em>that evaluates to a list with a
different element type each time</em>; <code class="language-plaintext highlighter-rouge">copyToZeroNT</code> doesn’t allow this.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">time</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">t</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">currentTimeMillis</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">PCons</span><span class="o">(</span><span class="s">"even"</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
  <span class="k">else</span> <span class="nc">PCons</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
<span class="o">}</span>

<span class="nf">copyToZeroNP</span><span class="o">(</span><span class="n">time</span><span class="o">)</span>  <span class="c1">// ok
</span><span class="nf">copyToZeroNT</span><span class="o">(</span><span class="n">time</span><span class="o">)</span>  <span class="c1">// not ok
</span></code></pre></div></div>

<p>In effect, <code class="language-plaintext highlighter-rouge">=&gt;</code> is like a type constructor; we can think of these
arguments as <code class="language-plaintext highlighter-rouge">byname[PList[_]]</code> and <code class="language-plaintext highlighter-rouge">byname[PList[T]]</code>.  So we have
exactly the same problem as we had with
<a href="/blog/2015/07/27/nested-existentials.html#method-equivalence-%E2%80%A6-broken"><code class="language-plaintext highlighter-rouge">plenLength</code> and <code class="language-plaintext highlighter-rouge">plenLengthTP</code></a>.</p>

<p>Unfortunately,
<a href="https://issues.scala-lang.org/browse/SI-9419">Scala currently accepts this, where it shouldn’t</a>.</p>

<p>The difference between these two methods gives us a hint about working
with existentials: if we can shift the scope for a given existential
outside the function that keeps giving us different types on every
reference, we might have an easier time working with it, even if we
can’t change it to a <code class="language-plaintext highlighter-rouge">val</code>; maybe it needs to be lazy and not saved,
for example.  So, despite the occasional convenience of path-dependent
types, <strong>type parameterized methods are still your best friends when
working with existential types</strong>.</p>

<p>In
<a href="/blog/2015/09/21/change-values.html">the next article, “To change types, change values”</a>,
we’ll look at some programs that make use of the two kinds of “type
changing” discussed above.  After that, we’ll finally talk about
methods that <em>return</em> values of existential type, rather than merely
taking them as arguments.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 30 Jul 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/07/30/values-never-change-types.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/30/values-never-change-types.html</guid>
      </item>
    
      <item>
        <title>Nested existentials</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the fifth of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>Let’s consider a few values of type <code class="language-plaintext highlighter-rouge">MList</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">estrs</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="s">"bye"</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">eints</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">21</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">ebools</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
</code></pre></div></div>

<p>Recall
<a href="/blog/2015/07/13/type-members-parameters.html#why-all-the-type-t">from the first part</a>
that the equivalent type in <code class="language-plaintext highlighter-rouge">PList</code> style is <code class="language-plaintext highlighter-rouge">PList[_]</code>.  Now, these
variables all have the “same” type, by virtue of forgetting what their
specific element type is, though you know that every value of, for
example, <code class="language-plaintext highlighter-rouge">estrs</code> has the same type.</p>

<h2 id="what-if-we-list-different-existentials">What if we list <em>different</em> existentials?</h2>

<p>Lists hold values of the same type, and as you might expect, you can
put these three lists in another list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">elists</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nc">PCons</span><span class="o">(</span><span class="n">estrs</span><span class="o">,</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">eints</span><span class="o">,</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">ebools</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())))</span>
</code></pre></div></div>

<p>Again, the equivalent is <code class="language-plaintext highlighter-rouge">PList[PList[_]]</code>.  We can see what this
means merely by doing substitution in the <code class="language-plaintext highlighter-rouge">PList</code> type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">head</span><span class="k">:</span> <span class="kt">MList</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span>
<span class="c1">// don't compile this, it's a thought process
</span></code></pre></div></div>

<p>Equivalently, <code class="language-plaintext highlighter-rouge">head</code> would have type <code class="language-plaintext highlighter-rouge">PList[_]</code>, a homogeneous list of
unknown element type, just like <code class="language-plaintext highlighter-rouge">MList</code>.</p>

<h2 id="method-equivalence--broken">Method equivalence … broken?</h2>

<p>But we come to a problem.  Suppose we wish to count the elements of
doubly-nested lists.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plenLength</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="nf">plenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">plenLengthTP</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">plengthT</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="nf">plenLengthTP</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>

<span class="nv">TmTp5</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">16</span><span class="kt">:</span> <span class="kt">no</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">for</span> <span class="kt">method</span> <span class="kt">plenLengthTP:</span>
<span class="kt">⤹</span> <span class="o">(</span><span class="kt">xss:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="nc">Int</span> <span class="n">exist</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span>
<span class="o">⤹</span> <span class="n">can</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="nf">arguments</span> <span class="o">(</span><span class="nv">tmtp</span><span class="o">.</span><span class="py">PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span>
 <span class="o">---</span> <span class="n">because</span> <span class="o">---</span>
<span class="n">argument</span> <span class="n">expression</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">compatible</span> <span class="kt">with</span> <span class="kt">formal</span> <span class="kt">parameter</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">?T</span><span class="o">]]</span>
</code></pre></div></div>

<p>According to our equivalence test, neither of these methods works to
implement the other!  This despite
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">the “simple rule” we have already discussed</a>.
Here’s the error the other way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TmTp5</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">20</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
</code></pre></div></div>

<p>The problem with calling <code class="language-plaintext highlighter-rouge">plenLengthTP</code> from <code class="language-plaintext highlighter-rouge">plenLength</code> is <em>there is
no one <code class="language-plaintext highlighter-rouge">T</code> we can choose, even an unspeakable one, to call
<code class="language-plaintext highlighter-rouge">plenLengthTP</code></em>.  That’s what the <code class="language-plaintext highlighter-rouge">?T</code> and the “no type parameters”
phrasing in the first error above means.</p>

<p>This is an accurate compiler error because <code class="language-plaintext highlighter-rouge">PList[PList[_]]</code> means
<code class="language-plaintext highlighter-rouge">PList[PList[E] forSome {type E}]</code>.  Let’s see the substitution again.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">head</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">},</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span>
<span class="c1">// don't compile this, it's a thought process
</span></code></pre></div></div>

<p>Java has the same problem.  See?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">llLength</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">xss</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">llLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">);</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="nf">llLengthTP</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">xss</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// we only care about types in this example</span>
<span class="o">}</span>

<span class="nc">TmTp5</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">7</span><span class="o">:</span>  <span class="nl">error:</span> <span class="n">method</span> <span class="n">llLengthTP</span> <span class="n">in</span> <span class="kd">class</span> <span class="nc">TmTp5</span>
<span class="err">⤹</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">given</span> <span class="n">types</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">llLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">);</span>
           <span class="o">^</span>

<span class="c1">// or, with llLengthTP calling llLength</span>
<span class="nc">TmTp5</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">11</span><span class="o">:</span>  <span class="nl">error:</span> <span class="n">incompatible</span> <span class="nl">types:</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span>
<span class="err">⤹</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">converted</span> <span class="n">to</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;?&gt;&gt;</span>
    <span class="k">return</span> <span class="nf">llLength</span><span class="o">(</span><span class="n">xss</span><span class="o">);</span>
                    <span class="o">^</span>
</code></pre></div></div>

<p>This discovery, which I made for myself
<a href="https://bitbucket.org/ermine-language/ermine-writers/src/c63d4060a74f1c8520ea1c8c3ba51ebd5d269780/writers/javafx/src/main/java/com/clarifi/reporting/writers/jfx/table/JFXTables.java?at=default#JFXTables.java-163">in the depths of the Ermine Java code</a>
(though it was certainly already well-known to others), was my first
clue, personally, that the term
<a href="/blog/2015/07/16/method-equiv.html#why-are-existentials-harder-to-think-about">“wildcard” was a lie, as discussed in a previous part</a>.</p>

<h2 id="scoping-existential-quantifiers">Scoping existential quantifiers</h2>

<p>The difference is, in Scala, we can write an equivalent for
<code class="language-plaintext highlighter-rouge">plenLengthTP</code>, using the Scala-only
<a href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.3"><code class="language-plaintext highlighter-rouge">forSome</code> <em>existential quantifier</em></a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plenLengthE</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">})</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="nf">plenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>
</code></pre></div></div>

<p>Of course, this type doesn’t mean the same thing as <code class="language-plaintext highlighter-rouge">plenLength</code>’s
type; for both <code class="language-plaintext highlighter-rouge">plenLengthE</code> and <code class="language-plaintext highlighter-rouge">plenLengthTP</code>, we demand proof that
each sublist in the argument has the same element type, which is not a
condition satisfied by either <code class="language-plaintext highlighter-rouge">PList[PList[_]]</code> or its equivalent
<code class="language-plaintext highlighter-rouge">PList[MList]</code>.</p>

<div class="side-note">
  <p>The reason you can’t invoke <code>plenLength</code> from
  <code>plenLengthTP</code> is complicated, even for this article.  In
  short, <code>plenLength</code> demands evidence that,
  <em>supposing</em> <code>PList</code> had a method taking an
  argument of the element type,
  e.g. <code>def lookAt(x: T): Unit</code>, it could do things like
  <code>xss.lookAt(PList("hi", PNil()))</code>.  In
  <code>plenLengthTP</code>, this hypothetical method could only be
  invoked with empty lists, or lists gotten by inspecting
  <code>xss</code> itself.</p>

  <p>That no such method exists is irrelevant for the purposes of this
  reasoning; we have written the definition of <code>PList</code> in a
  way that scalac assumes that such a method may exist.  You can
  determine the consequences yourself by adding the
  <code>lookAt</code> method to <code>PList</code>, repeating the
  above substitution for <code>PList</code>, and thinking about the
  meaning of the resulting <code>def lookAt(x:
  PList[E] forSome {type E}): Unit</code>.</p>
</div>

<p>Let’s examine the meaning of the type
<code class="language-plaintext highlighter-rouge">PList[PList[E]] forSome {type E}</code>.  It requires a little bit more
mental suspension.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let there be some unknown (abstract)
</span><span class="k">type</span> <span class="kt">E</span>
<span class="c1">// then the structure of the value is
</span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">head</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">],</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span>
<span class="c1">// don't compile this, it's a thought process
</span></code></pre></div></div>

<p>By moving the <code class="language-plaintext highlighter-rouge">forSome</code> <em>existential scope</em> outside the outer <code class="language-plaintext highlighter-rouge">PList</code>,
we also move the existential type variable outside of the whole
structure, substituting <em>the same</em> variable for each place we’re
expanding the type under consideration.  Once the <code class="language-plaintext highlighter-rouge">forSome</code> scope
extends over the whole type, Scala can pick that type as the parameter
to <code class="language-plaintext highlighter-rouge">plenLengthTP</code>.</p>

<p>This isn’t possible in Java at all; <code class="language-plaintext highlighter-rouge">PList&lt;PList&lt;?&gt;&gt;</code> is your only
choice, as <strong><code class="language-plaintext highlighter-rouge">?</code> in Java, like <code class="language-plaintext highlighter-rouge">_</code> in Scala, is always scoped to
exactly one level outside</strong>.  So in Java, you simply can’t write
<code class="language-plaintext highlighter-rouge">plenLengthE</code>’s type.  Luckily, the type-parameter equivalent is
perfectly expressible.</p>

<h2 id="what-happens-when-i-move-the-existential-scope">What happens when I move the existential scope?</h2>

<p>Of course, moving the scope makes the type mean something different,
which you can tell by counting how many <code class="language-plaintext highlighter-rouge">E</code>s there will be in a value.
A <code class="language-plaintext highlighter-rouge">PList[PList[_]]</code> is a list of lists where each list may have a
different, unknown element type, like <code class="language-plaintext highlighter-rouge">elists</code>.  A
<code class="language-plaintext highlighter-rouge">PList[PList[E]] forSome {type E}</code> is a list of lists where you still
don’t know the inner element type, but you know it’s the same for each
sublist.  We can tell that because, in the expansion, there’s only one
<code class="language-plaintext highlighter-rouge">E</code>, whereas the expansion for the former has an <code class="language-plaintext highlighter-rouge">E</code> introduced in
each <code class="language-plaintext highlighter-rouge">head</code> value.</p>

<p>So for the latter it is type-correct to, say, move elements from one
sublist to another; you know that, whichever pair of sublists you
choose to make this trade, they have the same element type.  But you
<em>don’t know that</em> for <code class="language-plaintext highlighter-rouge">PList[PList[_]]</code>.</p>

<p>Similarly, also by substitution, <code class="language-plaintext highlighter-rouge">PList[_] =&gt; Int</code> is a function that
takes <code class="language-plaintext highlighter-rouge">PList</code>s of any element type and returns <code class="language-plaintext highlighter-rouge">Int</code>, like <code class="language-plaintext highlighter-rouge">plengthE</code>.
You can figure this out by substituting for
<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/Function1.scala#L32-L36"><code class="language-plaintext highlighter-rouge">Function1#apply</code></a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">T1</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>But <code class="language-plaintext highlighter-rouge">(PList[E] =&gt; Int) forSome {type E}</code> is a function that takes
<code class="language-plaintext highlighter-rouge">PList</code>s of <em>one specific</em> element type that we don’t know.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let there be some unknown (abstract)
</span><span class="k">type</span> <span class="kt">E</span>
<span class="c1">// then the method is
</span><span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>It’s easy to use existential scoping to create functions that are
impossible to call and other values that are impossible to use besides
functions.  This is almost one of those:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">badlength</span><span class="k">:</span> <span class="o">(</span><span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">}</span> <span class="k">=</span> <span class="n">plengthE</span>
<span class="nf">badlength</span><span class="o">(???</span> <span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>

<span class="nv">TmTp5</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">29</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="n">where</span> <span class="k">type</span> <span class="kt">E</span>
<span class="nf">badlength</span><span class="o">(???</span> <span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
              <span class="o">^</span>
</code></pre></div></div>

<p>But in this case, there is one way we can call this function: with an
empty list.  Whatever the <code class="language-plaintext highlighter-rouge">E</code> is, it will be inferred when we call
<code class="language-plaintext highlighter-rouge">PNil()</code>.  So <code class="language-plaintext highlighter-rouge">badlength(PNil())</code> works.</p>

<p>There is a broader theme here hinted at by the interaction between
<code class="language-plaintext highlighter-rouge">PNil</code> and <code class="language-plaintext highlighter-rouge">badlength</code>: <strong>the most efficient, most easily understood
way to work with values of existential type is with type-parameterized
methods</strong>.  But we’ll get to that later.</p>

<h2 id="back-to-type-members">Back to type members</h2>

<p>Let us translate the working existential variant we discovered above
to the <code class="language-plaintext highlighter-rouge">PList[MList]</code> form of the function, though.  What is the
existential equivalent to <code class="language-plaintext highlighter-rouge">mlenLengthTP</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mlenLengthTP</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">mlength</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="nf">mlenLengthTP</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">mlenLength</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="nf">mlenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>

<span class="nv">TmTp5</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">38</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList.Aux</span><span class="o">[</span><span class="kt">this.T</span><span class="o">]]</span>
  <span class="nf">mlenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>
               <span class="o">^</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">MList</code> is equivalent to <code class="language-plaintext highlighter-rouge">MList {type T = E} forSome {type E}</code>.  We
can prove that directly in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">MList</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">E</span><span class="o">}</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">})]</span>
<span class="n">res0</span><span class="k">:</span> <span class="o">=:=[</span><span class="kt">tmtp.MList</span>,<span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">E</span><span class="o">}</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">E</span> <span class="o">}]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>That’s why we could use <code class="language-plaintext highlighter-rouge">runStSource</code> to infer a type parameter for
the existential <code class="language-plaintext highlighter-rouge">S</code> in
<a href="/blog/2015/07/23/type-projection.html#type-parameters-see-existentially">the last post</a>:
the scope is on the outside, so there’s exactly one type parameter to
infer.  So the scoping problem now looks very similar to the
<code class="language-plaintext highlighter-rouge">PList</code>-in-<code class="language-plaintext highlighter-rouge">PList</code> problem, and we can write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mlenLengthE</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">})</span>
  <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">mlenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="a-triangular-generalization">A triangular generalization</h2>

<p>Once again, <code class="language-plaintext highlighter-rouge">mlenLengthE</code> demands proof that each sublist of <code class="language-plaintext highlighter-rouge">xss</code> has
the same element type, by virtue of the position of its <code class="language-plaintext highlighter-rouge">forSome</code>
scope.  We can’t satisfy that with <code class="language-plaintext highlighter-rouge">elists</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">mlenLengthE</span><span class="o">(</span><span class="n">elists</span><span class="o">)</span>
</code></pre></div></div>

<p>Or, we <em>shouldn’t</em> be able to, anyway.
<a href="https://issues.scala-lang.org/browse/SI-9410">Sometimes, the wrong thing happens.</a>
We get the right error when we try to invoke <code class="language-plaintext highlighter-rouge">mlenLengthTP</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">mlenLengthTP</span><span class="o">(</span><span class="n">elists</span><span class="o">)</span>

<span class="nv">TmTp5</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">43</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList.Aux</span><span class="o">[</span><span class="kt">this.T</span><span class="o">]]</span>
    <span class="o">(</span><span class="n">which</span> <span class="n">expands</span> <span class="n">to</span><span class="o">)</span>  <span class="nv">tmtp</span><span class="o">.</span><span class="py">PList</span><span class="o">[</span><span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">this.T</span><span class="o">}]</span>
<span class="nf">mlenLengthTP</span><span class="o">(</span><span class="n">elists</span><span class="o">)</span>
             <span class="o">^</span>
</code></pre></div></div>

<p>So we have <code class="language-plaintext highlighter-rouge">mlenLengthE</code> $\equiv_m$ <code class="language-plaintext highlighter-rouge">mlenLengthTP</code>.  <code class="language-plaintext highlighter-rouge">mlenLength</code>,
however, is incompatible with both; neither is more general than the
other!  What we really want is a function that is more general than
all three, and subsumes all their definitions.  Here it is, in two
variants: one half-type-parameterized, the other wholly existential.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mlenLengthTP2</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">MList</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">mlength</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="nf">mlenLengthTP2</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">mlenLengthE2</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">MList</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">mlength</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="nf">mlenLengthTP2</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>We’ve woven a tangled web, so here are, restated, the full
relationships for the <code class="language-plaintext highlighter-rouge">MList</code>-in-<code class="language-plaintext highlighter-rouge">PList</code> functions above.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthTP2</code> $\equiv_m$ <code class="language-plaintext highlighter-rouge">mlenLengthE2</code></li>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthTP</code> $\equiv_m$ <code class="language-plaintext highlighter-rouge">mlenLengthE</code></li>
  <li>$\neg($<code class="language-plaintext highlighter-rouge">mlenLength</code> $&lt;:_m$ <code class="language-plaintext highlighter-rouge">mlenLengthE</code>$)$</li>
  <li>$\neg($<code class="language-plaintext highlighter-rouge">mlenLengthE</code> $&lt;:_m$ <code class="language-plaintext highlighter-rouge">mlenLength</code>$)$</li>
  <li>$\neg($<code class="language-plaintext highlighter-rouge">mlenLength</code> $&lt;:_m$ <code class="language-plaintext highlighter-rouge">mlenLengthTP</code>$)$</li>
  <li>$\neg($<code class="language-plaintext highlighter-rouge">mlenLengthTP</code> $&lt;:_m$ <code class="language-plaintext highlighter-rouge">mlenLength</code>$)$</li>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthTP2</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mlenLengthTP</code></li>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthTP2</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mlenLength</code></li>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthTP2</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mlenLengthE</code></li>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthE2</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mlenLengthTP</code></li>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthE2</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mlenLength</code></li>
  <li><code class="language-plaintext highlighter-rouge">mlenLengthE2</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mlenLengthE</code></li>
</ol>

<p>Moreover, the full existential in <code class="language-plaintext highlighter-rouge">mlenLengthE2</code> is shorthand for:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">MList</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">E2</span>
  <span class="o">}</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E2</span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>…a nested existential, though not in the meaning I intend in the title
of this article.  You can prove it with <code class="language-plaintext highlighter-rouge">=:=</code>, as above.</p>

<p>And I say all this simply as a means of saying that <em>this</em> is what
you’re signing up for when you decide to “simplify” your code by using
type members instead of parameters and leaving off the refinements
that make them concrete.</p>

<p>In
<a href="/blog/2015/07/30/values-never-change-types.html">the next part, “Values never change types”</a>,
we’ll get some idea of why working with existential types can be so
full of compiler errors, especially when allowing for mutation and
impure functions.</p>

<p><em>This article was tested with Scala 2.11.7 and Java 1.8.0_45.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 27 Jul 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/07/27/nested-existentials.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/27/nested-existentials.html</guid>
      </item>
    
      <item>
        <title>Type projection isn't that specific</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the fourth of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>In the absence of the <code class="language-plaintext highlighter-rouge">Aux</code> trick presented at the end of
<a href="/blog/2015/07/19/forget-refinement-aux.html#why-t0-what%E2%80%99s-aux">the previous article</a>,
the continuous use of structural refinement to accomplish basic tasks
admittedly imposes a high cognitive load.  That is to say, it’s a lot
of work to say something that ought to be very simple.</p>

<p>Some people go looking for a solution, and find something that almost
seems to make sense:
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#type-projection">type projection</a>,
or <code class="language-plaintext highlighter-rouge">MList#T</code> in terms of
<a href="/blog/2015/07/13/type-members-parameters.html#two-lists-all-alike">our ongoing example</a>.
But <strong>type projection is, in almost all cases, too vague to really
solve problems you have using type members</strong>.</p>

<h2 id="a-good-reason-to-use-type-members">A good reason to use type members</h2>

<p>Let’s see a simple example.  Here’s a sort of “value emitter”, that
operates in the space of some state, emitting a new value with each
step.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="nf">init</span><span class="k">:</span> <span class="kt">S</span>            <span class="c1">// create the initial state
</span>  <span class="k">def</span> <span class="nf">emit</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">S</span><span class="o">)</span> <span class="c1">// emit a value, and update state
</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">StSource</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span><span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">S0</span><span class="o">}</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S0</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">S0</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">S0</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">S0</span><span class="o">))</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S0</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">S0</span>
      <span class="k">def</span> <span class="nf">init</span> <span class="k">=</span> <span class="n">i</span>
      <span class="k">def</span> <span class="nf">emit</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S0</span><span class="o">)</span> <span class="k">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Unlike <code class="language-plaintext highlighter-rouge">MList</code>, there are actually good reasons to use type members
for the “state” in this sort of type definition; i.e. there are
reasonable designs in which you want to use member <code class="language-plaintext highlighter-rouge">S</code> existentially.
Thus, depending on how we intend to use it, it seems to meet our first
rule of thumb about when to use type members, as described in
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">the first article of this series</a>.</p>

<h2 id="a-failed-attempt-at-simplified-emitting">A failed attempt at simplified emitting</h2>

<p>So, under this theory, you’ve got some values of type <code class="language-plaintext highlighter-rouge">StSource[A]</code>
lying around.  And you want a simple function to take a source and its
state, and return the “next” value and the new state.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">runStSource</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ss</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">s</span><span class="k">:</span> <span class="kt">??</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">??</span><span class="o">)</span> <span class="k">=</span> <span class="nv">ss</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</code></pre></div></div>

<p>But what do you put where the <code class="language-plaintext highlighter-rouge">??</code> is?  The surprising guess is often
<code class="language-plaintext highlighter-rouge">StSource[A]#S</code>.  After all, it means “the <code class="language-plaintext highlighter-rouge">StSource</code>’s <code class="language-plaintext highlighter-rouge">S</code>”, and
we’re trying to talk about an <code class="language-plaintext highlighter-rouge">StSource</code>’s <code class="language-plaintext highlighter-rouge">S</code>, right?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">runStSource</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ss</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">s</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="n">S</span><span class="o">)</span>
  <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="nv">ss</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>

<span class="nv">TmTp4</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">22</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">S</span><span class="o">)</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ss.S</span>
  <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="nv">ss</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
                                 <span class="o">^</span>
</code></pre></div></div>

<p>Setting aside that it won’t compile with the above signature—the usual
outcome of experiments with type projection, that the types aren’t
strong enough to be workable without cheating by casting—the reality
<em>sounds</em> so close to the above that it is understandable that type
projection is often confused with something useful.</p>

<div class="side-note">
  There <em>are</em> uses for type projection.  But they are so rare, so
  exotic (they look
  <a href="https://github.com/scalaz/scalaz/blob/bdd6d5653313b10af08efdc6884cbbefe41051a2/core/src/main/scala/scalaz/Unapply.scala#L404-L409">like this</a>),
  and even the legitimate ones better off rewritten to avoid them,
  that the safer assumption is that you’ve gone down the wrong path if
  you’re trying to use them at all.  My suggestion can usually be
  phrased something like “move it to a companion object”.
</div>

<p>In reality, <code class="language-plaintext highlighter-rouge">StSource[A]#S</code> means <em>some</em> <code class="language-plaintext highlighter-rouge">StSource</code>’s <code class="language-plaintext highlighter-rouge">S</code>.  Not the
one you gave, just any particular one.  It’s the supertype of all
possible <code class="language-plaintext highlighter-rouge">S</code> choices.  So, the failure of the above signature is like
the failure of <code class="language-plaintext highlighter-rouge">mdropFirstE</code> from
<a href="/blog/2015/07/16/method-equiv.html#when-are-two-methods-less-alike">the second post of this series</a>:
a failure to relate types strongly enough.  The problem with
<code class="language-plaintext highlighter-rouge">mdropFirstE</code> was failure to relate the result type to argument type,
whereas the problem with <code class="language-plaintext highlighter-rouge">runStSource</code> is to fail to relate the two
arguments’ types to each other.</p>

<h2 id="type-parameters-see-existentially">Type parameters see existentially</h2>

<p>As with <code class="language-plaintext highlighter-rouge">mdropFirstE</code>, one correct solution here is, again, lifting the
member to a method type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">runStSource</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">](</span><span class="n">ss</span><span class="k">:</span> <span class="kt">StSource.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">],</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span> <span class="nv">ss</span><span class="o">.</span><span class="py">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</code></pre></div></div>

<p>The surprising feature of this sort of signature is that it can be
invoked on <code class="language-plaintext highlighter-rouge">ss</code> arguments of type <code class="language-plaintext highlighter-rouge">StSource[A]</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val ss: StSource[Int] = StSource(0){i: Int =&gt; (i, i)}
ss: tmtp4.StSource[Int] = tmtp4.StSource$$anon$1@300b5011

scala&gt; runStSource(ss, ss.init)
res0: (Int, ss.S) = (0,0)
</code></pre></div></div>

<p>In other words, <strong>methods can assign names to unspecified, existential
type members</strong>.  So even though we have a value whose type doesn’t
refine <code class="language-plaintext highlighter-rouge">S</code>, Scala still infers this type as the <code class="language-plaintext highlighter-rouge">S</code> argument to pass
to <code class="language-plaintext highlighter-rouge">runStSource</code>.</p>

<p>By analogy with type parameters, though, this isn’t too surprising.
<a href="/blog/2015/07/16/method-equiv.html">We’ve already seen</a>
that <code class="language-plaintext highlighter-rouge">copyToZeroE</code> inferred its argument’s existential parameter to
pass along to the named parameter to <code class="language-plaintext highlighter-rouge">copyToZeroP</code>, in the second part
of this series.  We even saw it apply directly to type members when
<code class="language-plaintext highlighter-rouge">mdropFirstE</code> was able to invoke <code class="language-plaintext highlighter-rouge">mdropFirstT</code>.  However, for whatever
reason, we’re used to existential parameters being able to do this;
even Java manages the task.  But it just seems <em>odder</em> that merely
calling a method can create a whole refinement <code class="language-plaintext highlighter-rouge">{...}</code> raincloud, from
scratch, filling in the blanks with sensible types along the way.</p>

<p>It’s completely sound, though.  An <code class="language-plaintext highlighter-rouge">StSource</code> [that exists as a value]
<em>must</em> have an <code class="language-plaintext highlighter-rouge">S</code>, even if we existentialized it away.  So, as with
<code class="language-plaintext highlighter-rouge">_</code>s, let’s just give it a name to pass as the inferred type
parameter.  It makes a whole lot more sense than supposing
<code class="language-plaintext highlighter-rouge">StSource[A]#S</code> will just do what I mean.</p>

<p>In a future post, we’ll use this “infer the whole refinement” feature
to demonstrate that some of the most magical-seeming Scala type system
features aren’t really so magical.  But before we get to that, we need
to see just why existentials are anything but “wildcards”, and why it
doesn’t <em>always</em> make sense to be able to lift existentials like <code class="language-plaintext highlighter-rouge">S</code>
to type parameters.  That’s coming in
<a href="/blog/2015/07/27/nested-existentials.html">the next post, “Nested existentials”</a>.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 23 Jul 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/07/23/type-projection.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/23/type-projection.html</guid>
      </item>
    
      <item>
        <title>What happens when I forget a refinement?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the third of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>As I mentioned
<a href="/blog/2015/07/16/method-equiv.html#when-are-two-methods-less-alike">in the previous article</a>,
the error of the <code class="language-plaintext highlighter-rouge">mdropFirstE</code> signature, taking <code class="language-plaintext highlighter-rouge">MList</code> and returning
merely <code class="language-plaintext highlighter-rouge">MList</code>, was to fail to relate the input element type to the
output element type.  This mistake is an easy one to make when failure
is the default behavior.</p>

<p>By contrast, <strong>when we try this with <code class="language-plaintext highlighter-rouge">PList</code>, the compiler helpfully
points out our error</strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pdropFirst</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span><span class="k">:</span> <span class="kt">PList</span> <span class="o">=</span> <span class="o">???</span>

<span class="nv">TmTp3</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">6</span><span class="kt">:</span> <span class="kt">class</span> <span class="kt">PList</span> <span class="kt">takes</span> <span class="k">type</span> <span class="kt">parameters</span>
  <span class="k">def</span> <span class="nf">pdropFirst</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span><span class="k">:</span> <span class="kt">PList</span> <span class="o">=</span> <span class="o">???</span>
                             <span class="o">^</span>
<span class="nv">TmTp3</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">6</span><span class="kt">:</span> <span class="kt">class</span> <span class="kt">PList</span> <span class="kt">takes</span> <span class="k">type</span> <span class="kt">parameters</span>
  <span class="k">def</span> <span class="nf">pdropFirst</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span><span class="k">:</span> <span class="kt">PList</span> <span class="o">=</span> <span class="o">???</span>
                     <span class="o">^</span>
</code></pre></div></div>

<h2 id="what-happens-when-i-misspell-a-refinement">What happens when I misspell a refinement?</h2>

<p>There is another mistake that type members open you up to. I have been
using the very odd type parameter—and member—name <code class="language-plaintext highlighter-rouge">T</code>.
Java developers will find this choice very ordinary, but the name of
choice for the discerning Scala programmer is <code class="language-plaintext highlighter-rouge">A</code>.  So suppose I
attempted to correct <code class="language-plaintext highlighter-rouge">mdropFirstE</code>’s type as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mdropFirstE2</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">})</span> <span class="k">=</span>
  <span class="nv">xs</span><span class="o">.</span><span class="py">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">MNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">c</span><span class="o">.</span><span class="py">tail</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This method compiles, but I cannot invoke it!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nf">mdropFirstE2</span><span class="o">(</span><span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">20</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.MNil</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">?</span><span class="o">}</span>
       <span class="nf">mdropFirstE2</span><span class="o">(</span><span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
                             <span class="o">^</span>

<span class="o">&gt;</span> <span class="nf">mdropFirstE2</span><span class="o">(</span><span class="nc">MCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">20</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.MCons</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">?</span><span class="o">}</span>
       <span class="nf">mdropFirstE2</span><span class="o">(</span><span class="nc">MCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()))</span>
                              <span class="o">^</span>
</code></pre></div></div>

<p>That’s because <code class="language-plaintext highlighter-rouge">MList {type A = T0}</code> is a perfectly reasonable
intersection type: values of this type have <em>both</em> the type <code class="language-plaintext highlighter-rouge">MList</code> in
their supertype tree somewhere, <em>and</em> a type member named <code class="language-plaintext highlighter-rouge">A</code>, which
is bound to <code class="language-plaintext highlighter-rouge">T0</code>.  In terms of subtyping relationships:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span> <span class="k">&lt;:</span> <span class="nc">MList</span>
<span class="c1">// and unrelatedly,
</span><span class="nc">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span> <span class="k">&lt;:</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span>
</code></pre></div></div>

<p>That <code class="language-plaintext highlighter-rouge">MList</code> has no such type member <code class="language-plaintext highlighter-rouge">A</code> is irrelevant to the
intersection and refinement of types in Scala.  This type means “an
instance of the trait <code class="language-plaintext highlighter-rouge">MList</code>, with a type member named <code class="language-plaintext highlighter-rouge">A</code> set
to <code class="language-plaintext highlighter-rouge">T0</code>”.  This type member <code class="language-plaintext highlighter-rouge">A</code> could come from another trait mixed
with <code class="language-plaintext highlighter-rouge">MList</code> or an inline subclass.  Whether such a thing is
impossible to instantiate—due to <code class="language-plaintext highlighter-rouge">sealed</code>, <code class="language-plaintext highlighter-rouge">final</code>, or anything
else—is also irrelevant; <strong>types with no values are meaningful and
useful in both Java and Scala</strong>.</p>

<h2 id="why-t0--whats-aux">Why <code class="language-plaintext highlighter-rouge">T0</code>?  What’s <code class="language-plaintext highlighter-rouge">Aux</code>?</h2>

<p>A few of the methods on <code class="language-plaintext highlighter-rouge">MList</code> we have seen so far take a type
parameter <code class="language-plaintext highlighter-rouge">T0</code> instead of <code class="language-plaintext highlighter-rouge">T</code>.  This is just a mnemonic trick; I’m
saying “I would write <code class="language-plaintext highlighter-rouge">T</code> here if <code class="language-plaintext highlighter-rouge">scalac</code> would let me”, which I have
borrowed from
<a href="https://github.com/scalaz/scalaz/blob/v7.1.3/core/src/main/scala/scalaz/Unapply.scala#L217"><code class="language-plaintext highlighter-rouge">scalaz.Unapply</code></a>.
Let’s try to implement <code class="language-plaintext highlighter-rouge">def MNil</code> taking a <code class="language-plaintext highlighter-rouge">T</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">MNil</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span><span class="k">:</span> <span class="kt">MNil</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T</span><span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MNil</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T</span>
  <span class="o">}</span>

<span class="c1">// Scala complains, though:
</span><span class="nv">TmTp3</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">15</span><span class="kt">:</span> <span class="kt">illegal</span> <span class="kt">cyclic</span> <span class="kt">reference</span> <span class="kt">involving</span> <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="nf">MNil</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span><span class="k">:</span> <span class="kt">MNil</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T</span><span class="o">}</span> <span class="k">=</span>
                                <span class="o">^</span>
</code></pre></div></div>

<p>This is a scoping problem; the refinement type makes the member <code class="language-plaintext highlighter-rouge">T</code>
shadow our method type parameter <code class="language-plaintext highlighter-rouge">T</code>.  We dealt with the problem in
<code class="language-plaintext highlighter-rouge">MList#uncons</code> and <code class="language-plaintext highlighter-rouge">MCons#tail</code> as well, way back in section “Two
lists, all alike” of
<a href="/blog/2015/07/13/type-members-parameters.html#two-lists-all-alike">the first part</a>,
in those cases by outer-scoping the <code class="language-plaintext highlighter-rouge">T</code> as
<code class="language-plaintext highlighter-rouge">self.T</code> instead.</p>

<p><strong>When defining a type with members, you should define an <code class="language-plaintext highlighter-rouge">Aux</code> type
in your companion that converts the member to a type parameter.</strong> The
name <code class="language-plaintext highlighter-rouge">Aux</code> is a convention I have borrowed from
<a href="https://github.com/milessabin/shapeless/blob/shapeless-2.2.4/core/src/main/scala/shapeless/ops/hlists.scala#L1501">Shapeless ops</a>.
This is pretty much boilerplate; in this case, add this to
<code class="language-plaintext highlighter-rouge">object MList</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">T0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span>
</code></pre></div></div>

<p>Now you can write <code class="language-plaintext highlighter-rouge">MList.Aux[Int]</code> instead of <code class="language-plaintext highlighter-rouge">MList {type T = Int}</code>.
Here’s <code class="language-plaintext highlighter-rouge">mdropFirstT</code>’s signature rewritten in this style.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mdropFirstT2</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Furthermore, because the member <code class="language-plaintext highlighter-rouge">T</code> is not in scope for <code class="language-plaintext highlighter-rouge">Aux</code>’s type
parameter position, you can take method type parameters named <code class="language-plaintext highlighter-rouge">T</code> and
sensibly write <code class="language-plaintext highlighter-rouge">MList.Aux[T]</code> without the above error.  You can see
this in the immediately preceding example.  But, stepping back a bit,
this should be considered an advantage for type parameters more
generally; <code class="language-plaintext highlighter-rouge">PList</code> doesn’t have this problem in the first place.</p>

<p><strong>Using <code class="language-plaintext highlighter-rouge">Aux</code> also helps you avoid the errors of forgetting to specify
or misspelling a type member</strong>, as described at the beginning of this
article.  With <code class="language-plaintext highlighter-rouge">Aux</code>, as with ordinary parameterized types, a missing
argument is caught by the compiler, and misspelling the parameter name
is impossible.</p>

<p>In
<a href="/blog/2015/07/23/type-projection.html">the next part, “Type projection isn’t that specific”</a>,
we’ll see why something that, at first glance, seems
like a workable alternative to either refinement or the <code class="language-plaintext highlighter-rouge">Aux</code> trick,
doesn’t work out as well as people wish it would.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 19 Jul 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/07/19/forget-refinement-aux.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/19/forget-refinement-aux.html</guid>
      </item>
    
      <item>
        <title>When are two methods alike?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the second of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p><a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">In the last part</a>,
we just saw two method types that, though different, are effectively
the same: those of <code class="language-plaintext highlighter-rouge">plengthT</code> and <code class="language-plaintext highlighter-rouge">plengthE</code>.  We have rules for
deciding when an existential parameter can be lifted into a method
type parameter—or a method type parameter lowered to an
existential—but there are other pairs of method types I want to
explore that are the same, or very close.  So let’s talk about how we
determine this equivalence.</p>

<p>A method <em>R</em> is more general than or as general as <em>Q</em> if <em>Q</em> may be
implemented by only making a call to <em>R</em>, passing along the arguments.
By more general, we mean <em>R</em> can be invoked in all the situations that
<em>Q</em> can be invoked in, and more besides.  Let us call the result of
this test $R &lt;:_m Q$ (where $&lt;:_m$ is pronounced “party duck”); if
the test of <em>Q</em> making a call to <em>R</em> fails, then $\neg(R &lt;:_m Q)$.</p>

<p>If $Q &lt;:_m R$ and $R &lt;:_m Q$, then the two method types are
<em>equivalent</em>; that is, neither has more expressive power than the
other, since each can be implemented merely by invoking the other and
doing nothing else.  We write this as $Q \equiv_m R$.  Likewise, if
$R &lt;:_m Q$ and $\neg(Q &lt;:_m R)$, that is, <em>Q</em> can be written by
calling <em>R</em>, but not vice versa, then <em>R</em> is <em>strictly more general</em>
than <em>Q</em>, or $R &lt;_m Q$.</p>

<p>What the concrete method—the one actually doing stuff, not invoking
the other one—does is irrelevant, for the purposes of this test,
because this is about types.  That matters because sometimes, in
Scala, as in Java, the body will compile in one of the methods, but
not the other.  Let’s see an example that doesn’t compile.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">def</span> <span class="nf">copyToZero</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="o">+=</span> <span class="nf">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="nv">TmTp2</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">9</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="o">(</span><span class="kt">some</span> <span class="kt">other</span><span class="o">)</span><span class="k">_</span><span class="kt">$1</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">xs</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="k">_</span><span class="kt">$1</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">xs</span><span class="o">)</span>
    <span class="kt">xs</span> <span class="kt">+=</span> <span class="kt">xs</span><span class="o">(</span><span class="err">0</span><span class="o">)</span>
            <span class="kt">^</span>
</code></pre></div></div>

<p>Likewise, the Java version has a similar problem, though the error
message doesn’t give as good a hint as to what’s going on.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">copyToZero</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
<span class="o">}</span>

<span class="nc">TmTp2</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">11</span><span class="o">:</span>  <span class="nl">error:</span> <span class="n">no</span> <span class="n">suitable</span> <span class="n">method</span> <span class="n">found</span> <span class="k">for</span> <span class="nf">add</span><span class="o">(</span><span class="no">CAP</span><span class="err">#</span><span class="mi">1</span><span class="o">)</span>
        <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
          <span class="o">^</span>
</code></pre></div></div>

<p>Luckily, in both Java and Scala, we have an <em>equivalent</em> method type,
from lifting the existential (misleadingly called <em>wildcard</em> in Java
terminology) to a method type parameter.</p>

<p>We can apply this transformation to put the method implementation
somewhere it will compile.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">copyToZeroE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="nf">copyToZeroP</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>

<span class="k">private</span> <span class="k">def</span> <span class="nf">copyToZeroP</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="o">+=</span> <span class="nf">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p>Similarly, in Java,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">copyToZeroE</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">copyToZeroP</span><span class="o">(</span><span class="n">xs</span><span class="o">);</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copyToZeroP</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="no">T</span> <span class="n">zv</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">zv</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The last gives a hint as to what’s going on, both here and in the
compiler errors above: in <code class="language-plaintext highlighter-rouge">copyToZeroP</code>’s body, the list element type
has a name, <code class="language-plaintext highlighter-rouge">T</code>; we can use the name to create variables, and the
compiler can rely on the name as well.  The compiler, ideally,
shouldn’t care about whether the name can be written, but that one of
the above compiles and the other doesn’t is telling.</p>

<p>If you were to define a variable to hold the result of getting the
first element in the list in either version of <code class="language-plaintext highlighter-rouge">copyToZeroE</code>, how
would you do that?  In Java, the reason this doesn’t work is
straightforward: you would have to declare the variable to be of type
<code class="language-plaintext highlighter-rouge">Object</code>, but that type isn’t specific enough to allow the variable to
be used as an argument to <code class="language-plaintext highlighter-rouge">xs.add</code>.</p>

<p>Scala’s type-inferred variables don’t help here; Scala considers the
existential type to be scoped to <code class="language-plaintext highlighter-rouge">xs</code>, and makes the definition of
<code class="language-plaintext highlighter-rouge">zv</code> independent of <code class="language-plaintext highlighter-rouge">xs</code> by breaking the type relationship, and
crushing the inferred type of <code class="language-plaintext highlighter-rouge">zv</code> to <code class="language-plaintext highlighter-rouge">Any</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">copyToZeroE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">zv</span> <span class="k">=</span> <span class="nf">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="n">xs</span> <span class="o">+=</span> <span class="n">zv</span>
<span class="o">}</span>

<span class="nv">TmTp2</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">19</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">zv.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">Any</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="k">_</span><span class="kt">$1</span>
    <span class="n">xs</span> <span class="o">+=</span> <span class="n">zv</span>
          <span class="o">^</span>
</code></pre></div></div>

<p>When we call the type-parameterized variant to implement the
existential variant, with the real implementation residing in the
former, we are just helping the compiler along by using the equivalent
method type; in the simpler case of the former, both <code class="language-plaintext highlighter-rouge">scalac</code> and
<code class="language-plaintext highlighter-rouge">javac</code> manage to infer that the type <code class="language-plaintext highlighter-rouge">T</code> should be the (otherwise
unspeakable) existential.  <strong>Method equivalence and generality make it
possible to write methods, safely, that could not be written
directly.</strong></p>

<h2 id="why-are-existentials-harder-to-think-about">Why are existentials harder to think about?</h2>

<p>I think we, as humans, may have even more difficulty with the lack of
names for existentials than the compilers do.  The name “unspeakable”,
which I have borrowed from Jon Skeet’s <em>C# in Depth</em>, is telling: even
in our heads, our thought processes are shaped by language.  We tame
the mathematics of programming with symbols, with names.  Existentials
and their “unspeakable” names rob us of the tools to talk about them,
to think about them.</p>

<p>Java has done its practitioners two great disservices here.  One: by
calling its existentials “wildcards”.  They are not “wildcards”, in
any commonly or uncommonly understood sense.  If you suppose your
preexisting notions of “wildcards” to apply to these much more exotic
creatures, you will confidently stroll into the darkness until you
trip and fall off a cliff.  They are only <em>superficially</em> “wildcards”.
The effect of this sorry attempt at avoiding new terminology is
chiefly to cheat Java programmers out of learning what’s really going
on.  (We will explore some of this more exotic behavior
<a href="/blog/2015/07/27/nested-existentials.html">in a later post</a>.)</p>

<p>Two: by
<a href="https://docs.oracle.com/javase/tutorial/extra/generics/methods.html">encouraging use of existential signatures</a>
like <code class="language-plaintext highlighter-rouge">mdropFirstE</code> over parameterized versions like <code class="language-plaintext highlighter-rouge">mdropFirstT</code> that
do not require the same kind of mental gymnastics.</p>

<p>For lifting these type parameters is how we can reclaim the power we
lost in the debacle of the unspeakable names.  We name them, and in so
doing can once more talk and think about them without exhausting
ourselves by gesticulating wildly, comforting ourselves with
fairytales of “wildcards”.  Because in parameter lifting, we have
found a <em>true</em> analogy.</p>

<h2 id="when-are-two-methods-less-alike">When are two methods less alike?</h2>

<p>Now, let’s examine another pair of methods, and apply our test to
them.</p>

<p>Let’s say we want to write the equivalent of this method for <code class="language-plaintext highlighter-rouge">MList</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pdropFirst</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">PNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">t</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>According to the <code class="language-plaintext highlighter-rouge">PList</code> ⇔ <code class="language-plaintext highlighter-rouge">MList</code> conversion rules given
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">in the previous article</a>,
section “Why all the <code class="language-plaintext highlighter-rouge">{type T = ...}</code>?”, the equivalent for <code class="language-plaintext highlighter-rouge">MList</code>
should be</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mdropFirstT</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">})</span>
  <span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">}</span> <span class="k">=</span>
  <span class="nv">xs</span><span class="o">.</span><span class="py">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">MNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">c</span><span class="o">.</span><span class="py">tail</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Let us try to drop the refinements.  That seems to compile:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mdropFirstE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span><span class="o">)</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span>
  <span class="nv">xs</span><span class="o">.</span><span class="py">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">MNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">c</span><span class="o">.</span><span class="py">tail</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>It certainly looks nicer.  However, while <code class="language-plaintext highlighter-rouge">mdropFirstE</code> can be
implemented by calling <code class="language-plaintext highlighter-rouge">mdropFirstT</code>, passing the type parameter
<code class="language-plaintext highlighter-rouge">xs.T</code>, the opposite is not true; <code class="language-plaintext highlighter-rouge">mdropFirstT</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mdropFirstE</code>,
or, <code class="language-plaintext highlighter-rouge">mdropFirstT</code> is <em>strictly more general</em>.</p>

<p>In this case, the reason is that <code class="language-plaintext highlighter-rouge">mdropFirstE</code> fails to relate the
argument’s <code class="language-plaintext highlighter-rouge">T</code> to the result’s <code class="language-plaintext highlighter-rouge">T</code>; you could implement <code class="language-plaintext highlighter-rouge">mdropFirstE</code>
as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mdropFirstE</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span><span class="o">)</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span>
  <span class="nc">MCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">())</span>
</code></pre></div></div>

<p>The stronger type of <code class="language-plaintext highlighter-rouge">mdropFirstT</code> forbids such shenanigans.  However,
I can just tell you that largely because I’m already comfortable with
existentials; how could you figure that out if you’re just starting
out with these tools?  You don’t have to; the beauty of the
equivalence test is that you can apply it mechanically.  <strong>Knowing
nothing about the mechanics of the parameterization and existentialism
of the types involved, you can work out with the equivalence test</strong>
that <code class="language-plaintext highlighter-rouge">mdropFirstT</code> $&lt;_m$ <code class="language-plaintext highlighter-rouge">mdropFirstE</code>, and therefore, that you can’t
get away with simply dropping the refinements.</p>

<h2 id="method-likeness-and-subtyping-all-alike">Method likeness and subtyping, all alike</h2>

<p>If you know what the symbol <code class="language-plaintext highlighter-rouge">&lt;:</code> means in Scala, or perhaps you’ve
read
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#relations-between-types">SLS §3.5 “Relations between types”</a>,
you might think, “gosh, method equivalence and generality look awfully
familiar.”</p>

<p>Indeed, the thing we’re talking about is very much like subtyping and
type equality!  In fact, every type-equal pair of methods <em>M</em>₁ and
<em>M</em>₂ also pass our method equivalence test, and every pair of methods
<em>M</em>₃ and <em>M</em>₄ where $M_3 &lt;: M_4$ passes our <em>M</em>₄-calls-<em>M</em>₃ test.
So $M_1 \equiv M_2$ implies $M_1 \equiv_m M_2$, and
$M_3 &lt;: M_4$ implies $M_3 &lt;:_m M_4$.</p>

<p>We even follow many of the same rules as the type relations.  We have
transitivity: if <em>M</em>₁ can call <em>M</em>₂ to implement itself, and <em>M</em>₂ can
call <em>M</em>₃ to implement itself, obviously we can snap the pointer and
have <em>M</em>₁ call <em>M</em>₃ directly.  Likewise, every method type is
equivalent to itself: reflexivity.  Likewise, if a method <em>M</em>₁ is
strictly more general than <em>M</em>₂, obviously <em>M</em>₂ cannot be strictly
more general than <em>M</em>₁: antisymmetricity.  And we even copy the
relationship between ≡ and &lt;: themselves: just as $T_1 \equiv T_2$
implies $T_1 &lt;: T_2$, so $R \equiv_m Q$ implies $R &lt;:_m Q$.</p>

<p>Scala doesn’t understand the notion of method equivalence we’ve
defined above, though.  So you can’t, say, implement an abstract
method in a subclass using an equivalent or more general form, at
least directly; you have to <code class="language-plaintext highlighter-rouge">override</code> the Scala way, and call the
alternative form yourself, if that’s what you want.</p>

<p>I do confess to one oddity in my terminology: <strong>the method that has
more specific type is <em>the more general method</em>.</strong> I hope the example
of <code class="language-plaintext highlighter-rouge">mdropFirstT</code> $&lt;:_m$ <code class="language-plaintext highlighter-rouge">mdropFirstE</code> justifies my choice.
<code class="language-plaintext highlighter-rouge">mdropFirstT</code> has more specific type, and rejects more
implementations, such as the one that returns a list with <code class="language-plaintext highlighter-rouge">42</code> in it
above.  Thus, it has fewer implementations, in the same way that more
specific types have fewer values inhabiting them.  But it can be used
in more circumstances, so it is “more general”.  The generality in
terms of when a method can be used is directly proportional to the
specificity of its type.</p>

<h2 id="javas-edge-of-insanity">Java’s edge of insanity</h2>

<p>Now we have enough power to demonstrate that Scala’s integration with
Java generics is faulty.  Or, more fairly, that Java’s generics are
faulty.</p>

<p>Consider this method type, in Scala:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</code></pre></div></div>

<p>This is a pretty specific method type; there are not too many
implementations.  Of course you can always perform a side effect; we
don’t track that in Scala’s type system.  But what can it return?
Just <code class="language-plaintext highlighter-rouge">t</code>.</p>

<p>Specifically, you can’t return <code class="language-plaintext highlighter-rouge">null</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">TmTp2</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">36</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Null</span><span class="o">(</span><span class="kt">null</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="nf">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="kc">null</span>
                                   <span class="o">^</span>
</code></pre></div></div>

<p>Well now, let’s convert this type to Java:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">holdOnNow</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We got away with that!  And, indeed, we can call <code class="language-plaintext highlighter-rouge">holdOnNow</code> to
implement <code class="language-plaintext highlighter-rouge">goshWhatIsThis</code>, and vice versa; they’re <em>equivalent</em>.  But
the type says we can’t return <code class="language-plaintext highlighter-rouge">null</code>!</p>

<p>The problem is that Java adds an implicit upper bound, because it
assumes generic type parameters can only have class types chosen for
them; in Scala terms, <code class="language-plaintext highlighter-rouge">[T &lt;: AnyRef]</code>.  If we encode this constraint
in Scala, Scala gives us the correct error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">holdOnNow</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nv">TmTp2</span><span class="o">.</span><span class="py">holdOnNow</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nf">holdOnNow</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>

<span class="nv">TmTp2</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">38</span><span class="kt">:</span> <span class="kt">inferred</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
<span class="o">⤹</span> <span class="n">to</span> <span class="n">method</span> <span class="n">holdOnNow</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nf">holdOnNow</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
                                   <span class="o">^</span>
</code></pre></div></div>

<p>This is forgivable on Scala’s part, because it’d be annoying to add
<code class="language-plaintext highlighter-rouge">&lt;: AnyRef</code> to your generic methods just because you called some Java
code and it’s probably going to work out fine.  I blame <code class="language-plaintext highlighter-rouge">null</code>, and
while I’m at it, I blame <code class="language-plaintext highlighter-rouge">Object</code> having any methods at all, too.
We’d be better off without these bad features.</p>

<p>In
<a href="/blog/2015/07/19/forget-refinement-aux.html">the next part, “What happens when I forget a refinement?”</a>,
we’ll talk about what happens when you forget refinements for things
like <code class="language-plaintext highlighter-rouge">MList</code>, and how you can avoid that while simplifying your
type-member-binding code.</p>

<p><em>This article was tested with Scala 2.11.7 and Java 1.8.0_45.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/07/16/method-equiv.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/16/method-equiv.html</guid>
      </item>
    
      <item>
        <title>Type members are [almost] type parameters</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the first of a series of articles on “Type Parameters and Type
Members”.</em></p>

<p>Type members like <code class="language-plaintext highlighter-rouge">Member</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Blah</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Member</span>
<span class="o">}</span>
</code></pre></div></div>

<p>and parameters like <code class="language-plaintext highlighter-rouge">Param</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Blah2</span><span class="o">[</span><span class="kt">Param</span><span class="o">]</span>
</code></pre></div></div>

<p>have more similarities than differences.  The choice of which to use
for a given situation is usually a matter of convenience.  In brief, a
rule of thumb: <strong>a type parameter is usually more convenient and
harder to screw up, but if you intend to use it existentially in most
cases, changing it to a member is probably better</strong>.</p>

<p>Here, and in later posts, we will discuss what on earth that means,
among other things.  In this series of articles on <em>Type Parameters
and Type Members</em>, I want to tackle a variety of Scala types that look
very different, but are really talking about the same thing, or
almost.</p>

<h2 id="two-lists-all-alike">Two lists, all alike</h2>

<p>To illustrate, let’s see two versions of
<a href="http://www.artima.com/pins1ed/working-with-lists.html">the functional list</a>.
Typically, it isn’t used existentially, so the usual choice of
parameter over member fits our rule of thumb above.  It’s instructive
anyway, so let’s see it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MList</span> <span class="o">{</span><span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="nf">uncons</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">MCons</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">self.T</span><span class="o">}]</span>
<span class="o">}</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MNil</span> <span class="k">extends</span> <span class="nc">MList</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">uncons</span> <span class="k">=</span> <span class="nc">None</span>
<span class="o">}</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MCons</span> <span class="k">extends</span> <span class="nc">MList</span> <span class="o">{</span><span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="nv">tail</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">self.T</span><span class="o">}</span>
  <span class="k">def</span> <span class="nf">uncons</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">self</span><span class="k">:</span> <span class="kt">MCons</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">self.T</span><span class="o">})</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We’re not quite done; we’re missing a way to <em>make</em> <code class="language-plaintext highlighter-rouge">MNil</code>s and
<code class="language-plaintext highlighter-rouge">MCons</code>es, which <code class="language-plaintext highlighter-rouge">PNil</code> and <code class="language-plaintext highlighter-rouge">PCons</code> have already provided
for themselves, by virtue of being <code class="language-plaintext highlighter-rouge">case class</code>es.  But it’s already
pretty clear that <em>a type parameter is a more straightforward way to
define this particular data type</em>.</p>

<p>The instance creation takes just a bit more scaffolding for our
examples:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">MNil</span><span class="o">[</span><span class="kt">T0</span><span class="o">]()</span><span class="k">:</span> <span class="kt">MNil</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MNil</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T0</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">MCons</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T0</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">})</span>
  <span class="k">:</span> <span class="kt">MCons</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MCons</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T0</span>
    <span class="k">val</span> <span class="nv">head</span> <span class="k">=</span> <span class="n">hd</span>
    <span class="k">val</span> <span class="nv">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="why-all-the-type-t--">Why all the <code class="language-plaintext highlighter-rouge">{type T = ...}</code>?</h2>

<p>After all, isn’t the virtue of type members that we don’t have to pass
the type around everywhere?</p>

<p>Let’s see what happens when we attempt to apply that theory.  Suppose
we remove only one of the
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#compound-types"><em>refinement</em>s</a>
above, as these <code class="language-plaintext highlighter-rouge">{...}</code> rainclouds at the type level are called.
Let’s remove the one in <code class="language-plaintext highlighter-rouge">val tail</code>, so <code class="language-plaintext highlighter-rouge">class MCons</code> looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MCons</span> <span class="k">extends</span> <span class="nc">MList</span> <span class="o">{</span><span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="nv">tail</span><span class="k">:</span> <span class="kt">MList</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let us put a couple members into the list, and add them together.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MCons</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span>
<span class="n">nums</span><span class="k">:</span> <span class="kt">tmtp.MCons</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span> <span class="k">=</span> <span class="nv">tmtp</span><span class="o">.</span><span class="py">MList$$anon$2</span><span class="k">@</span><span class="mi">3</span><span class="n">c649f69</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">nums</span><span class="o">.</span><span class="py">head</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">nums.T</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="o">+</span> <span class="n">res1</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">nums</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">uncons</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">head</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">nums.tail.T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">res3</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">res2</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">-</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">nums.tail.T</span>
       <span class="nv">res3</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">res2</span><span class="o">)</span>
                  <span class="o">^</span>
</code></pre></div></div>

<p>When we took the refinement off of <code class="language-plaintext highlighter-rouge">tail</code>, we eliminated any evidence
about what its <code class="language-plaintext highlighter-rouge">type T</code> might be.  We only know that <em>it must be some
type</em>.  That’s what <em>existential</em> means.</p>

<p><strong>In terms of type parameters, <code class="language-plaintext highlighter-rouge">MList</code> is like <code class="language-plaintext highlighter-rouge">PList[_]</code>, and <code class="language-plaintext highlighter-rouge">MList
{type T = Int}</code> is like <code class="language-plaintext highlighter-rouge">PList[Int]</code>.</strong>  For the former, we say that
the member, or parameter, is existential.</p>

<h2 id="when-is-existential-ok">When is existential OK?</h2>

<p>Despite the limitation implied by the error above, there <em>are</em> useful
functions that can be written on the existential version.  Here’s one
of the simplest:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mlength</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="nv">xs</span><span class="o">.</span><span class="py">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">mlength</span><span class="o">(</span><span class="nv">c</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>For the type parameter equivalent, the parameter on the argument is
usually carried out or <em>lifted</em> to the function, like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plengthT</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">plengthT</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>By the conversion rules above, though, we should be able to write an
existential equivalent of <code class="language-plaintext highlighter-rouge">mlength</code> for <code class="language-plaintext highlighter-rouge">PList</code>, and indeed we can:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plengthE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">plengthE</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>There’s another simple rule we can follow when determining whether we
can rewrite in an existential manner.</p>

<ol>
  <li>When a type parameter appears only in one argument, and</li>
  <li>appears nowhere in the result type,</li>
</ol>

<p>we should always, ideally, be able to write the function in an
existential manner.  (We will discuss why it’s only “ideally” in
<a href="/blog/2015/07/16/method-equiv.html">the next article</a>.)</p>

<p>You can demonstrate this to yourself by having the parameterized
variant (e.g. <code class="language-plaintext highlighter-rouge">plengthT</code>) call the existential variant
(e.g. <code class="language-plaintext highlighter-rouge">plengthE</code>), and, voilà, it compiles, so it must be right.</p>

<p>This hints at what is usually, though not always, <strong>an advantage for
type parameters: you have to ask for an existential, rather than
silently getting one just because you forgot a refinement</strong>.  We will
discuss
<a href="/blog/2015/07/19/forget-refinement-aux.html">what happens when you forget one in a later post</a>.</p>

<h2 id="equivalence-as-a-learning-tool">Equivalence as a learning tool</h2>

<p>Scala is large enough that very few understand all of it.  Moreover,
there are many aspects of it that are poorly understood in general.</p>

<p>So why focus on how different features are similar?  When we
understand one area of Scala well, but another one poorly, we can form
sensible ideas about the latter by drawing analogies with the former.
This is how we solve problems with computers in general: we create an
informal model in our heads, which we translate to a
mathematical statement that a program can interpret, and it gives back
a result that we can translate back to our informal model.</p>

<p>My guess is that type parameters are much better understood than type
members, but that existentials via type members are better understood
than existentials introduced by <code class="language-plaintext highlighter-rouge">_</code> or <code class="language-plaintext highlighter-rouge">forSome</code>, though I’d wager
that neither form of existential is particularly well understood.</p>

<p>By knowing about equivalences and being able to discover more, you
have a powerful tool for understanding unfamiliar aspects of Scala:
just translate the problem back to what you know and think about what
it means there, because the conclusion will still hold when you
translate it forward.  (Category theorists, eat your hearts out.)</p>

<p>In this vein, we will next generalize the above rule about existential
methods, discovering a simple tool for determining whether two
method types <em>in general</em> are equivalent, whereby things you know
about one easily carry over to the other.  We will also explore
methods that <em>cannot</em> be written in the existential style, at least
under Scala’s restrictions.</p>

<p>That all happens in
<a href="/blog/2015/07/16/method-equiv.html">the next part, “When are two methods alike?”</a>.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/07/13/type-members-parameters.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/13/type-members-parameters.html</guid>
      </item>
    
      <item>
        <title>Existential types are not raw types</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>While this blog is typically strictly for Scala developers interested
in strongly-typed programming, this particular article is of interest
to Java developers as well.  You don’t need to know Scala to follow
along.</em></p>

<p>Scala makes a <em>welcome</em> simplification in its type system:
<a href="http://docs.scala-lang.org/tutorials/tour/generic-classes.html">type arguments</a>
are always required.  That is, in Java, you may (unsafely) leave off
the type arguments for compatibility with pre-1.5 code,
e.g. <code class="language-plaintext highlighter-rouge">java.util.List</code>, forming a
<a href="http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html"><em>raw type</em></a>.
Scala does not permit this, and requires you to pass a type argument.</p>

<p>The most frequent trouble people have with this rule is being unable
to implement some Java method with missing type arguments in its
signature, e.g. one that takes a raw <code class="language-plaintext highlighter-rouge">List</code> as an argument.  Let us
see why they have trouble, and why this is a good thing.</p>

<h2 id="existentials-are-safe-raw-types-are-not">Existentials are safe, raw types are not</h2>

<p>Stripping the type argument list, e.g. going from
<code class="language-plaintext highlighter-rouge">java.util.List&lt;String&gt;</code> to <code class="language-plaintext highlighter-rouge">java.util.List</code> is <em>an unsafe cast</em>.
<a href="http://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html"><em>Wildcarding</em></a>
the same type argument, e.g. going from <code class="language-plaintext highlighter-rouge">java.util.List&lt;String&gt;</code> to
<code class="language-plaintext highlighter-rouge">java.util.List&lt;?&gt;</code>, is <em>safe</em>.  The latter type is written
<code class="language-plaintext highlighter-rouge">java.util.List[_]</code>, or <code class="language-plaintext highlighter-rouge">java.util.List[T] forSome {type T}</code>, in
Scala.  In both Java and Scala, this is an
<a href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.3">existential type</a>.
As compiled with <code class="language-plaintext highlighter-rouge">-Xlint:rawtypes -Xlint:unchecked</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TestEx</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">words</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="s">"there"</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// TestEx.java:17: warning: [rawtypes] found raw type: List</span>
    <span class="c1">//  missing type arguments for generic class List&lt;E&gt;</span>
    <span class="c1">//  where E is a type-variable:</span>
    <span class="c1">//    E extends Object declared in interface List</span>
    <span class="c1">//                  ↓</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">List</span> <span class="n">wordsRaw</span> <span class="o">=</span> <span class="n">words</span><span class="o">();</span>

    <span class="c1">// there is no warning for this</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">wordsET</span> <span class="o">=</span> <span class="n">words</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Also note that there is no warning for the equivalent to <code class="language-plaintext highlighter-rouge">wordsET</code> in
Scala.  Because it, like javac, knows that it’s safe.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">TestEx</span><span class="o">.</span><span class="py">words</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">wordsET</span> <span class="k">=</span> <span class="nv">TestEx</span><span class="o">.</span><span class="py">words</span> <span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
<span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="raw-types-are-bad--stop-using-them">Raw Types are bad.  Stop using them</h2>

<p>The reason that existentials are safe is that the rules in place for
values of existential type are consistent with the rest of the generic
system, whereas raw types contradict those rules, resulting in code
that should not typecheck, and only does for legacy code support.  We
can see this in action with two Java methods.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addThing</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swapAround</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">84</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>These methods are the same, except for the use of raw types versus
existentials.  However, the second does not compile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TestEx.java:26: error: no suitable method found for add(int)
        xs.add(84);
          ^
    method Collection.add(CAP#1) is not applicable
      (argument mismatch; int cannot be converted to CAP#1)
    method List.add(CAP#1) is not applicable
      (argument mismatch; int cannot be converted to CAP#1)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
</code></pre></div></div>

<p>Why forbid adding 42 to the list?  The element type of list is
unknown.  The answer lies in that statement: <em>its unknownness isn’t a
freedom for the body of the method, it’s a restriction</em>.  The rawtype
version treats its lack of knowledge as a freedom, and the caller pays
for it by having its data mangled.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testIt</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">someWords</span> <span class="o">=</span> <span class="n">words</span><span class="o">();</span>
    <span class="n">addThing</span><span class="o">(</span><span class="n">someWords</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Contents of someWords after addThing:"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">someWords</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Well that seems okay, what's the last element?"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">someWords</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">someWords</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And it compiles:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TestEx.java:23: warning: [unchecked] unchecked call to add(E) as a
                         member of the raw type List
        xs.add(42);
              ^
  where E is a type-variable:
    E extends Object declared in interface List
</code></pre></div></div>

<p>But when we try to run it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">TestEx</span><span class="o">.</span><span class="py">testIt</span><span class="o">()</span>
<span class="nc">Contents</span> <span class="n">of</span> <span class="n">someWords</span> <span class="n">after</span> <span class="n">addThing</span><span class="k">:</span>
<span class="err">[</span><span class="kt">hi</span><span class="o">,</span> <span class="n">there</span><span class="o">,</span> <span class="mi">42</span><span class="err">]</span>
<span class="nc">Well</span> <span class="n">that</span> <span class="n">seems</span> <span class="n">okay</span><span class="o">,</span> <span class="n">what</span><span class="ss">'s </span><span class="n">the</span> <span class="n">last</span> <span class="n">element</span><span class="o">?</span>
<span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">ClassCastException</span><span class="k">:</span> <span class="kt">java.lang.Integer</span> <span class="kt">cannot</span> <span class="kt">be</span> <span class="kt">cast</span> <span class="kt">to</span>
                              <span class="nv">java</span><span class="o">.</span><span class="py">lang</span><span class="o">.</span><span class="py">String</span>
  <span class="n">at</span> <span class="nv">rawtypes</span><span class="o">.</span><span class="py">TestEx</span><span class="o">.</span><span class="py">testIt</span><span class="o">(</span><span class="nv">TestEx</span><span class="o">.</span><span class="py">java</span><span class="k">:</span><span class="err">32</span><span class="o">)</span>
  <span class="o">...</span> <span class="mi">43</span> <span class="n">elided</span>
</code></pre></div></div>

<p>It is a mistake to think that just because some code throws
<code class="language-plaintext highlighter-rouge">ClassCastException</code>, it must be to blame for a type error.  This line
is blameless.  It is the fault of the unchecked cast when we called
<code class="language-plaintext highlighter-rouge">addThing</code>, and more specifically, the unsafe assumption about the
<code class="language-plaintext highlighter-rouge">List</code>’s element type that was made in its body.</p>

<h2 id="existentials-are-much-better">Existentials are much better</h2>

<p>When we used the wildcard, we were forbidden from doing the unsafe
thing.  But what kinds of things can we do with the safe, existential
form?  Here’s one:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swapAroundAux</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swapAround</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">swapAroundAux</span><span class="o">(</span><span class="n">xs</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In other words: let <code class="language-plaintext highlighter-rouge">E</code> be the <em>unknown</em> element type of <code class="language-plaintext highlighter-rouge">xs</code>.
<code class="language-plaintext highlighter-rouge">xs.get()</code> has type <code class="language-plaintext highlighter-rouge">E</code>, and <code class="language-plaintext highlighter-rouge">xs.add</code> has argument type <code class="language-plaintext highlighter-rouge">E</code>.  They
line up, so this is okay, no matter what the element type of <code class="language-plaintext highlighter-rouge">xs</code>
turns out to be.  Let’s try a test:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">w</span> <span class="k">=</span> <span class="nv">TestEx</span><span class="o">.</span><span class="py">words</span>
<span class="n">w</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">TestEx</span><span class="o">.</span><span class="py">swapAround</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">w</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="nv">w</span><span class="o">.</span><span class="py">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span>
</code></pre></div></div>

<p>The body of <code class="language-plaintext highlighter-rouge">swapAround</code> is guaranteed not to mangle its argument by
the type checker, so we, as a caller, can safely call it, and know
that our argument’s type integrity is protected.</p>

<p>Scala has more features to let us get away without <code class="language-plaintext highlighter-rouge">swapAroundAux</code>.
This translation uses a lowercase
<a href="http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html#type-parameter-inference-for-constructor-patterns."><em>type variable pattern</em></a>
to name the existential.  To the right of the <code class="language-plaintext highlighter-rouge">=&gt;</code>, we can declare
variables of type <code class="language-plaintext highlighter-rouge">e</code> and use <code class="language-plaintext highlighter-rouge">e</code> to construct more types, while still
referring to the <code class="language-plaintext highlighter-rouge">_</code> in the <code class="language-plaintext highlighter-rouge">xs</code> argument’s type.  But in this case,
we just do the same as <code class="language-plaintext highlighter-rouge">swapAroundAux</code> above.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">swapAround</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">xs2</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nv">xs2</span><span class="o">.</span><span class="py">add</span><span class="o">(</span><span class="nv">xs2</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="crushing-the-existential">Crushing the existential</h2>

<p>Let’s consider the <code class="language-plaintext highlighter-rouge">xs.get()</code> and <code class="language-plaintext highlighter-rouge">xs.add</code> methods, which have return
type and argument type <code class="language-plaintext highlighter-rouge">E</code>, respectively.  As you can’t write the name
of an existential type in Java, what happens when we “crush” it,
choosing the closest safe type we can write the name of?</p>

<p>First, we can simplify by considering every existential to be bounded.
That is, instead of <code class="language-plaintext highlighter-rouge">E</code>, we think about <code class="language-plaintext highlighter-rouge">E extends Object super
Nothing</code>, or <code class="language-plaintext highlighter-rouge">E &lt;: Any &gt;: Nothing</code> in Scala.  While <code class="language-plaintext highlighter-rouge">Object</code> or <code class="language-plaintext highlighter-rouge">Any</code>
is the “top” of the type hierarchy, which <em>every</em> type is a subtype
of, <code class="language-plaintext highlighter-rouge">Nothing</code> is the “bottom”, sadly left out of Java’s type system,
which <em>every</em> type is a <em>supertype</em> of.</p>

<p>For <code class="language-plaintext highlighter-rouge">get</code>, the <code class="language-plaintext highlighter-rouge">E</code> appears in the result type, a <em>covariant</em> position.
So we crush it to the upper bound, <code class="language-plaintext highlighter-rouge">Any</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">wordsET</span><span class="o">.</span><span class="py">get</span> <span class="k">_</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Any</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>However, for <code class="language-plaintext highlighter-rouge">add</code>, the <code class="language-plaintext highlighter-rouge">E</code> appears in the argument type, a
<em>contravariant</em> position.  So if it is to be crushed, it must be
crushed to the lower bound, <code class="language-plaintext highlighter-rouge">Nothing</code>, instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]).</span><span class="py">add</span> <span class="k">_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Any</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="k">_</span><span class="kt">$1</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="n">where</span> <span class="k">type</span> <span class="k">_</span><span class="kt">$1</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span>
              <span class="o">(</span><span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]).</span><span class="py">add</span> <span class="k">_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Any</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">)</span>
                                                 <span class="o">^</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]).</span><span class="py">add</span> <span class="k">_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Nothing</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Each occurrence of an existential in a signature may be crushed
independently.  However, a variable that appears once but may be
distributed to either side, such as in a generic type parameter, is
<em>invariant</em>, and may not be crushed at that point.  That is why the
existential is preserved in the inferred type of <code class="language-plaintext highlighter-rouge">wordsET</code> itself.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">wordsET</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>
</code></pre></div></div>

<p>Herein lies something closer to a formalization of the problem with
raw types: they crush existential occurrences in contravariant and
invariant positions to the upper bound, <code class="language-plaintext highlighter-rouge">Object</code>, when the only safe
positions to crush in this way are the covariant positions.</p>

<h2 id="how-do-list-and-list-relate">How do <code class="language-plaintext highlighter-rouge">List</code> and <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code> relate?</h2>

<p>It is well understood that, in Java, <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code> is not a subtype
of <code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>.  In Scala terms, this is because all type
parameters are <em>invariant</em>, which has exactly the meaning it had in
the previous section.  However, that doesn’t mean it’s impossible to
draw subtyping relationships between different <code class="language-plaintext highlighter-rouge">List</code>s for different
type arguments; they must merely be mediated by existentials, as is
common in the Java standard library.</p>

<p>The basic technique is as follows: we can convert any <code class="language-plaintext highlighter-rouge">T</code> in <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code>
to <code class="language-plaintext highlighter-rouge">? extends T super T</code>.  Following that, we can raise the argument
to <code class="language-plaintext highlighter-rouge">extends</code> and lower the argument to <code class="language-plaintext highlighter-rouge">super</code> as we like.  A <code class="language-plaintext highlighter-rouge">?</code> by
itself, I have described above, is merely the most extreme course of
this formula you can take.  So <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code> for any <code class="language-plaintext highlighter-rouge">T</code> is a subtype of
<code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>.  (This only applies at one level of depth;
e.g. <code class="language-plaintext highlighter-rouge">List&lt;List&lt;T&gt;&gt;</code> is not necessarily a subtype of <code class="language-plaintext highlighter-rouge">List&lt;List&lt;?&gt;&gt;</code>.)</p>

<p>Does this mean that <code class="language-plaintext highlighter-rouge">List</code> is a subtype of <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>?  Well, kind of.
Following the rule for specialization of method signatures in
subclasses, we should be able to override a method that returns
<code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code> with one that returns <code class="language-plaintext highlighter-rouge">List</code>, and override a method that
takes <code class="language-plaintext highlighter-rouge">List</code> as an argument with one that takes <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code> as an
argument.  However, this is like building a house on a foam mattress:
the conversion that got us a raw type wasn’t sound in the first place,
so what soundness value does this relationship have?</p>

<h2 id="the-frequent-java-library-bug">The frequent Java library bug</h2>

<p>Let’s see the specific problem that people usually encounter in Scala.
Suppose <code class="language-plaintext highlighter-rouge">addThing</code>, defined above, is an instance member of <code class="language-plaintext highlighter-rouge">TestEx</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TestEx2</span> <span class="kd">extends</span> <span class="nc">TestEx</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addThing</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or the Scala version:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestEx3</span> <span class="k">extends</span> <span class="nc">TestEx</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">addThing</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">javac</code> gives us this error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TestEx.java:48: error: name clash: addThing(List&lt;?&gt;) in TestEx2 and
                addThing(List) in TestEx have the same erasure, yet
                neither overrides the other
    public void addThing(final List&lt;?&gt; xs) {}
                ^
TestEx.java:47: error: method does not override or implement a method
                from a supertype
    @Override
    ^
</code></pre></div></div>

<p>scalac is forgiving, though.  I’m not sure how forgiving it is.
However, the forgiveness is unsound: it lets us return less specific
types when overriding methods than we got out.</p>

<h2 id="how-to-fix-it">How to fix it</h2>

<ol>
  <li>
    <p>Stop using raw types.</p>
  </li>
  <li>
    <p><strong>If you maintain a Java library with raw types in its API, you are
doing a disservice to your users.  Eliminate them.</strong></p>
  </li>
  <li>
    <p>If you are using such a library, report a bug, or submit a patch,
to eliminate the raw types.  If you add <code class="language-plaintext highlighter-rouge">-Xlint:rawtypes</code> to the
<code class="language-plaintext highlighter-rouge">javac</code> options, the compiler will tell you where you’re using
them.  Fix all the warnings, and you’re definitely not using raw
types anymore.</p>
  </li>
  <li>
    <p>Help Java projects, including your own, avoid introducing raw types
by adding <code class="language-plaintext highlighter-rouge">-Xlint:rawtypes</code> permanently to their <code class="language-plaintext highlighter-rouge">javac</code> options.
<strong><code class="language-plaintext highlighter-rouge">rawtypes</code> is more serious than <code class="language-plaintext highlighter-rouge">unchecked</code></strong>; even if you do not
care about <code class="language-plaintext highlighter-rouge">unchecked</code> warnings, you should still turn on and fix
<code class="language-plaintext highlighter-rouge">rawtypes</code> warnings.</p>
  </li>
</ol>

<p>You may also turn on <code class="language-plaintext highlighter-rouge">-Xlint:cast</code> to point out casts that are no
longer necessary now that your types are cleaner.  If possible, add
<code class="language-plaintext highlighter-rouge">-Werror</code> to your build as well, to convert <code class="language-plaintext highlighter-rouge">rawtypes</code> warnings to
errors.</p>

<h2 id="why-not-just-add-wildcards-automatically">Why not just add wildcards automatically?</h2>

<p>Adding wildcards isn’t a panacea.  For certain raw types, you need to
add a proper type parameter, even adding type parameters to your own
API.  The Internet has no copy and paste solutions to offer you; it
all depends on how to model your specific scenario.  Here are a few
possibilities.</p>

<ol>
  <li>
    <p>Pass a type argument representing what’s actually in the structure.
For example, replace <code class="language-plaintext highlighter-rouge">List</code> with <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code> if that’s what it
is.</p>
  </li>
  <li>
    <p>Pass a wildcard.</p>
  </li>
  <li>
    <p>Propagate the type argument outward.  For example, if you have a
method <code class="language-plaintext highlighter-rouge">List doThis(final List xs)</code>, maybe it should be <code class="language-plaintext highlighter-rouge">&lt;E&gt;
List&lt;E&gt; doThis(final List&lt;E&gt; xs)</code>.  Or if you have a <code class="language-plaintext highlighter-rouge">class
Blah&lt;X&gt;</code> containing a <code class="language-plaintext highlighter-rouge">List</code>, maybe it should be a <code class="language-plaintext highlighter-rouge">class Blah&lt;A,
X&gt;</code> containing a <code class="language-plaintext highlighter-rouge">List&lt;A&gt;</code>.  This is often the most flexible
option, but it can take time to implement.</p>
  </li>
  <li>
    <p>Combine any of these.  For example, in some circumstances, a more
flexible version of #3 would be to define <code class="language-plaintext highlighter-rouge">Blah&lt;A, X&gt;</code> containing a
<code class="language-plaintext highlighter-rouge">List&lt;? extends A&gt;</code>.</p>
  </li>
</ol>

<p>Wildcards and existentials are historically misunderstood in the Java
community; Scala developers have the advantage of more powerful
language tools for talking about them.  So <strong>if you are unsure of how
to eliminate some raw types, consider asking a Scala developer what to
do!</strong> Perhaps they will tell you “use Scala instead”, and maybe that’s
worth considering, but you’re likely to get helpful advice regardless
of how you feel about language advocacy.</p>

<h2 id="the-scala-philosophy">The Scala philosophy</h2>

<p>As you can see, the Java compatibility story in Scala is not as simple
as is advertised.  However, I favor the strong stance against this
unsound legacy feature.  If Scala can bring an end to the scourge of
raw types, it will have been worth the compatibility trouble.</p>

<p><em>This article was tested with Scala 2.11.5 and javac 1.8.0_31.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2015/02/26/rawtypes.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/02/26/rawtypes.html</guid>
      </item>
    
      <item>
        <title>Why is ADT pattern matching allowed?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>One of the rules of
<a href="https://dl.dropboxusercontent.com/u/7810909/talks/parametricity/4985cb8e6d8d9a24e32d98204526c8e3b9319e33/parametricity.pdf">the Scalazzi Safe Scala Subset</a>
is “no type casing”; in other words, testing the type via
<code class="language-plaintext highlighter-rouge">isInstanceOf</code> or type patterns isn’t allowed.  It’s one of the most
important rules therein for preservation of free theorems.  Common
functional programming practice in Scala <em>seems</em> to violate this rule
in a subtle way.  However, as we will see, that practice carves out a
very specific exception to this rule that, morally, isn’t an exception
at all, carrying convenient advantages and none of the drawbacks.</p>

<h2 id="why-forbid-type-tests">Why forbid type tests?</h2>

<p>With the “no type tests” rule, we forbid writing functions like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">revmaybe</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">allInts</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">forall</span><span class="o">{</span><span class="k">case</span> <span class="k">_:</span><span class="kt">Int</span> <span class="o">=&gt;</span> <span class="kc">true</span>
                          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">}</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">allInts</span><span class="o">)</span> <span class="nv">xs</span><span class="o">.</span><span class="py">reverse</span> <span class="k">else</span> <span class="n">xs</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Which violates the
<a href="http://failex.blogspot.com/2013/06/fake-theorems-for-free.html">free theorem</a>
of <code class="language-plaintext highlighter-rouge">revmaybe</code>’s type <code class="language-plaintext highlighter-rouge">revmaybe(xs map f) = revmaybe(xs) map f</code>, as
follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">f</span><span class="o">(</span><span class="n">i</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">revmaybe</span><span class="o">(</span><span class="n">xs</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">revmaybe</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="adts-are-ok-to-go">ADTs are OK to go</h2>

<p>On the other hand, the Scalazzi rules are totally cool with pattern
matching to separate the parts of
<a href="https://www.haskell.org/haskellwiki/Algebraic_data_type">ADTs</a>.  For
example, this is completely fine.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">headOption</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Even more exotic matches, where we bring type information forward into
runtime, are acceptable, as long as they’re in the context of ADTs.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddExpr</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">eval</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">ex</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AddExpr</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="adts-use-type-tests">ADTs use type tests</h2>

<p>Let’s look at the compiled code of the <code class="language-plaintext highlighter-rouge">eval</code> body, specifically, the
<code class="language-plaintext highlighter-rouge">case</code> line.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         <span class="mi">2</span><span class="o">:</span> <span class="n">aload_2</span>       
         <span class="mi">3</span><span class="o">:</span> <span class="n">instanceof</span>    <span class="err">#</span><span class="mi">60</span>                 <span class="c1">// class adts/AddExpr
</span>         <span class="mi">6</span><span class="o">:</span> <span class="n">ifeq</span>          <span class="mi">39</span>
         <span class="mi">9</span><span class="o">:</span> <span class="n">aload_2</span>       
        <span class="mi">10</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="mi">60</span>                 <span class="c1">// class adts/AddExpr
</span>        <span class="mi">13</span><span class="o">:</span> <span class="n">astore_3</span>      
        <span class="mi">14</span><span class="o">:</span> <span class="n">aload_3</span>       
        <span class="mi">15</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">63</span>                 <span class="c1">// Method adts/AddExpr.x:()I
</span>        <span class="mi">18</span><span class="o">:</span> <span class="n">istore</span>        <span class="mi">4</span>
        <span class="mi">20</span><span class="o">:</span> <span class="n">aload_3</span>       
        <span class="mi">21</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">66</span>                 <span class="c1">// Method adts/AddExpr.y:()I
</span>        <span class="mi">24</span><span class="o">:</span> <span class="n">istore</span>        <span class="mi">5</span>
        <span class="mi">26</span><span class="o">:</span> <span class="n">iload</span>         <span class="mi">4</span>
        <span class="mi">28</span><span class="o">:</span> <span class="n">iload</span>         <span class="mi">5</span>
        <span class="mi">30</span><span class="o">:</span> <span class="n">iadd</span>          
</code></pre></div></div>

<p>So, instead of calling <code class="language-plaintext highlighter-rouge">unapply</code> to presumably check whether <code class="language-plaintext highlighter-rouge">AddExpr</code>
matches, scalac checks and casts its argument to <code class="language-plaintext highlighter-rouge">AddExpr</code>.  Why does
it do that?  Let’s see if we could use <code class="language-plaintext highlighter-rouge">AddExpr.unapply</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">AddExpr</span><span class="o">.</span><span class="py">unapply</span> <span class="k">_</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">adts.AddExpr</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>In other words, the <code class="language-plaintext highlighter-rouge">unapply</code> call can’t tell you whether an <code class="language-plaintext highlighter-rouge">Expr</code> is
an <code class="language-plaintext highlighter-rouge">AddExpr</code>; it can’t be called with arbitrary <code class="language-plaintext highlighter-rouge">Expr</code>.</p>

<p>The only actual check here is inserted by scalac as part of compiling
the pattern match expression, and it is a type test, supposedly
verboten under Scalazzi rules.  <code class="language-plaintext highlighter-rouge">headOption</code>, too, is implemented with
type tests and casts, not <code class="language-plaintext highlighter-rouge">unapply</code> calls.</p>

<p>We’ve exhorted Scala users to avoid type tests, but then turn around
and say that type tests are OK!  What’s going on?</p>

<h2 id="an-equivalent-form">An equivalent form</h2>

<p>In every case where we use pattern matching on an ADT, there’s an
equivalent way we could write the expression without pattern matching,
by adding an encoding of the whole ADT as a method on the class or
trait we use as the base type.  Let’s redefine the <code class="language-plaintext highlighter-rouge">Option</code> type with
such a method to see how this is done.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MNothing</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">nothing</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Just</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">get</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="nf">just</span><span class="o">(</span><span class="n">get</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s key to our reasoning that we completely avoid <code class="language-plaintext highlighter-rouge">match</code> in our
implementations; in other words, the <code class="language-plaintext highlighter-rouge">fold</code> is <em>matchless</em>.</p>

<p>With the <code class="language-plaintext highlighter-rouge">fold</code> method, the following two expressions are equivalent,
notwithstanding scalac’s difficulty optimizing the latter, even in the
presence of inlining.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">selector</span><span class="k">:</span> <span class="kt">Maybe</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">MNothing</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"default case"</span>
  <span class="k">case</span> <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">selector</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="s">"default case"</span><span class="o">,</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</code></pre></div></div>

<p>It’s a simple formula: the fold takes as many arguments as there are
cases, always returns the given, sole type parameter, and each
argument is a function that results in that same parameter.  There’s a
free theorem that a <code class="language-plaintext highlighter-rouge">fold</code> implementation on data structures without
recursion, like <code class="language-plaintext highlighter-rouge">Maybe</code>, can only invoke one of these arguments and
return the result directly, just as the pattern match does.</p>

<p>If you prefer the clarity of named cases, just use Scala’s named
arguments.  Here’s that last fold:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">selector</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="n">nothing</span> <span class="k">=</span> <span class="s">"default case"</span><span class="o">,</span>
              <span class="n">just</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="gadt-folds">GADT folds</h2>

<p>Encoding <code class="language-plaintext highlighter-rouge">Expr</code> is a little bit more complicated.  For the full power
of the type, we have to turn to <code class="language-plaintext highlighter-rouge">Leibniz</code> to encode the matchless
<code class="language-plaintext highlighter-rouge">fold</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Leibniz</span><span class="o">,</span> <span class="nc">Leibniz</span><span class="o">.{===,</span> <span class="n">refl</span><span class="o">}</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What does this mean?  The type <code class="language-plaintext highlighter-rouge">Int === T</code>, seen in the <code class="language-plaintext highlighter-rouge">add</code> argument
signature, is inhabited if and only if the type <code class="language-plaintext highlighter-rouge">T</code> <strong>is</strong> the type
<code class="language-plaintext highlighter-rouge">Int</code>.  So an implementation of <code class="language-plaintext highlighter-rouge">fold</code> can only call the <code class="language-plaintext highlighter-rouge">add</code>
function if it can prove that type equality.  There is, of course, one
that can:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddExpr2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span>
  <span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="nf">add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Not only does <code class="language-plaintext highlighter-rouge">AddExpr2</code> know that <code class="language-plaintext highlighter-rouge">Expr2</code>’s type parameter is <code class="language-plaintext highlighter-rouge">Int</code>,
we must make the type substitution when implementing methods from
<code class="language-plaintext highlighter-rouge">Expr2</code>!  At that point it is enough to mention <code class="language-plaintext highlighter-rouge">refl</code>, the evidence
that every type is equal to itself, to satisfy <code class="language-plaintext highlighter-rouge">add</code>’s signature.</p>

<p>This may seem a little magical, but it is no less prosaic than
implementing <code class="language-plaintext highlighter-rouge">java.lang.Comparable</code> by making this substitution.  So
you can do this sort of thing every day even in Java.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyData</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">MyData</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">MyData</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// note T is replaced by MyData</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If only Java had higher kinds, you could go the rest of the way and
actually implement
<a href="https://www.haskell.org/haskellwiki/Generalised_algebraic_datatype#Motivating_example">GADTs</a>.</p>

<p>Moving on, let’s see another case for <code class="language-plaintext highlighter-rouge">Expr2</code>, and finally to tie it
all together, <code class="language-plaintext highlighter-rouge">eval2</code> with some extra constant data in for good
measure.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ConcatExpr2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span>
  <span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="nf">concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">eval2</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Expr2</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="nv">ex</span><span class="o">.</span><span class="py">fold</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">intIsT</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">intIsT</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">),</span>
          <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">strIsT</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">strIsT</span><span class="o">(</span><span class="s">"one"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>Using the <code class="language-plaintext highlighter-rouge">Leibniz</code> proof is, unfortunately, more involved than
producing it in the fold implementations.  See my previous posts,
<a href="/blog/2014/07/02/type_equality_to_leibniz.html">“A function from type equality to Leibniz”</a>
and
<a href="/blog/2014/09/20/higher_leibniz.html">“Higher Leibniz”</a>,
for many
details on applying <code class="language-plaintext highlighter-rouge">Leibniz</code> proof to make type transformations.</p>

<p>While the pattern matching <code class="language-plaintext highlighter-rouge">eval</code> didn’t have to explicitly apply type
equality evidence – it <em>just knew</em> that <code class="language-plaintext highlighter-rouge">Int</code> was <code class="language-plaintext highlighter-rouge">T</code> when the
<code class="language-plaintext highlighter-rouge">IntExpr</code> pattern matched – Scala has holes in its implementation,
discussed in the aforementioned posts on <code class="language-plaintext highlighter-rouge">Leibniz</code>, that sometimes
make the above implementation strategy an attractive choice even
though pattern matching is available.</p>

<h2 id="we-could-but-thats-good-enough-so-we-wont">We could, but that’s good enough, so we won’t</h2>

<p>You might have noticed that adding another case to <code class="language-plaintext highlighter-rouge">Expr</code> caused us
not only to implement an extra <code class="language-plaintext highlighter-rouge">fold</code>, but to add another argument to
the base <code class="language-plaintext highlighter-rouge">fold</code> to represent the new case, and then go through every
implementation to add that argument.  This isn’t so bad for just two
cases, but indeed has quadratic growth, to the point that adding a new
case to a large datatype is a majorly annoying project all by itself.</p>

<p>There is an interesting property of <code class="language-plaintext highlighter-rouge">fold</code>, though: the strategy isn’t
available for our first function, <code class="language-plaintext highlighter-rouge">revmaybe</code>, to discriminate
arguments of arbitrary type!  To do that, we would have to add a
signature like this to <code class="language-plaintext highlighter-rouge">Any</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">any</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="nf">any</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
<span class="c1">// and, in the body of class Int
</span><span class="k">override</span> <span class="k">def</span> <span class="nf">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">any</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="nf">int</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</code></pre></div></div>

<p>Obviously, you cannot do this.</p>

<p>You can only add <code class="language-plaintext highlighter-rouge">fold</code> methods to types you know; I can only call
<code class="language-plaintext highlighter-rouge">fold</code> in <code class="language-plaintext highlighter-rouge">expr2</code> by virtue of the fact that I know that the argument
has type <code class="language-plaintext highlighter-rouge">Expr2[T]</code> for some <code class="language-plaintext highlighter-rouge">T</code>.  If the argument was just <code class="language-plaintext highlighter-rouge">T</code>, I
wouldn’t have enough static type information to call <code class="language-plaintext highlighter-rouge">fold</code>.  So the
use of <code class="language-plaintext highlighter-rouge">fold</code>s doesn’t break parametricity.  Equivalently, <strong>a pattern
match that could be implemented using a matchless fold also does not
break parametricity</strong>.</p>

<p>As we have seen, it is unfortunately inconvenient to actually go
through the bother of writing <code class="language-plaintext highlighter-rouge">fold</code> methods, when pattern matching is
there.  But it is enough to reason that <em>we could</em> write a matchless
<code class="language-plaintext highlighter-rouge">fold</code> and replace the pattern matching with it, to prove that the
pattern matching is safe, no matter how many underlying type tests
scalac might use to implement it.</p>

<p>A simple test follows: <strong>if you could write a matchless fold, and use
that instead, the pattern match is type-safe</strong>.</p>

<h2 id="a-selector-subtlety">A selector subtlety</h2>

<p>Here’s a pattern match that violates parametricity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">selector</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">MNothing</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"default case"</span>
  <span class="k">case</span> <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Wait, but didn’t we rewrite that using a <code class="language-plaintext highlighter-rouge">fold</code> earlier?  Not quite.
Oh, I didn’t mention?  The type of <code class="language-plaintext highlighter-rouge">selector</code> is <code class="language-plaintext highlighter-rouge">T</code>, because we’re in
a function like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">notIdentity</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">selector</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
  <span class="c1">// match expression above goes here
</span></code></pre></div></div>

<p>Scala will permit this pattern match to go forward.  It doesn’t
require us to prove that the selector is of the ADT root type we
happened to define; that’s an arbitrary point as far as Scala’s
subtyping system is concerned.  All that is required is that the
static type of <code class="language-plaintext highlighter-rouge">selector</code> be a supertype of each of <code class="language-plaintext highlighter-rouge">MNothing[_]</code> and
<code class="language-plaintext highlighter-rouge">Just[_]</code>, which <code class="language-plaintext highlighter-rouge">T</code> is, not being known to be more refined than
<code class="language-plaintext highlighter-rouge">Any</code>.</p>

<p>The test works here, though!  What is ambiguous to scalac is a bright
line in our reasoning. We can’t define a matchless <code class="language-plaintext highlighter-rouge">fold</code> that can be
invoked on this <code class="language-plaintext highlighter-rouge">selector</code>, so we reach the correct conclusion, that
the match violates parametricity.</p>

<h2 id="the-rule-revisited">The rule revisited</h2>

<p>So we’ve carved out a clear “exception” to the “no type tests”
Scalazzi rule, and seen that it isn’t an exception at all.  There’s a
straightforward test you can apply to your pattern matches,</p>

<p><strong>If and only if I could, hypothetically, write a matchless fold, or
use an existing one, and rewrite this in its terms, this pattern
match is safe.</strong></p>

<p>but beware the subtle case where the match’s selector has a wider type
than you anticipated.</p>

<p>Finally, this is a rule specifically about expressions that don’t
violate our ability to reason about code.  This doesn’t hold for
arbitrary type-unsafe rewrites: that you could write a program safely
means you <em>should</em> write it safely.  Unlike arbitrary rewrites into
nonfunctional code, the pattern match uses no
non-referentially-transparent and no genuinely non-parametric
expressions.</p>

<p><em>This article was tested with Scala 2.11.4 and Scalaz 7.1.0.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 10 Nov 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/11/10/why_is_adt_pattern_matching_allowed.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/11/10/why_is_adt_pattern_matching_allowed.html</guid>
      </item>
    
      <item>
        <title>Higher Leibniz</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>We’ve previously seen
<a href="/blog/2014/07/02/type_equality_to_leibniz.html">the basic implementation and motivation for <code class="language-plaintext highlighter-rouge">scalaz.Leibniz</code></a>.
But there’s still quite a bit more to this traditionally esoteric
member of the Scalaz collection of well-typed stuff.</p>

<h2 id="strictly-necessarily-strict">Strictly necessarily strict</h2>

<p>The word “witness” implies that <code class="language-plaintext highlighter-rouge">Leibniz</code> is a passive bystander in
your function; sitting back and telling you that some type is equal to
another type, otherwise content to let the <em>real</em> code do the real
work.  The fact that <code class="language-plaintext highlighter-rouge">Leibniz</code> lifts into functions (which are a
member of the <em>everything</em> set, you’ll agree) might reinforce the
notion that <code class="language-plaintext highlighter-rouge">Leibniz</code> is spooky action at a distance.</p>

<p>But one of the nice things about <code class="language-plaintext highlighter-rouge">Leibniz</code> is that there’s really no
cheating: the value with its shiny new type is dependent on the
<code class="language-plaintext highlighter-rouge">Leibniz</code> actually existing, and its <code class="language-plaintext highlighter-rouge">subst</code>, however much a glorified
identity function it might be, completing successfully.</p>

<p>To see this in action, let’s check in with the bastion of not
evaluating stuff, Haskell.</p>

<h2 id="the-haskell-implementation">The Haskell implementation</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE RankNTypes, PolyKinds #-}</span>
<span class="kr">module</span> <span class="nn">Leib</span>
  <span class="p">(</span> <span class="kt">Leib</span><span class="p">()</span>
  <span class="p">,</span> <span class="nf">subst</span>
  <span class="p">,</span> <span class="nf">lift</span>
  <span class="p">,</span> <span class="nf">symm</span>
  <span class="p">,</span> <span class="nf">compose</span>
  <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Functor</span>

<span class="kr">data</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="p">{</span>
  <span class="n">subst</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">}</span>

<span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">a</span>
<span class="n">refl</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="n">id</span>

<span class="n">lift</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="n">lift</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">runOn</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">ab</span> <span class="o">.</span> <span class="kt">On</span> <span class="o">$</span> <span class="n">refl</span>

<span class="kr">newtype</span> <span class="kt">On</span> <span class="n">c</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">On</span> <span class="p">{</span>
  <span class="n">runOn</span> <span class="o">::</span> <span class="n">c</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">symm</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">b</span> <span class="n">a</span>
<span class="n">symm</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">runDual</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">ab</span> <span class="o">.</span> <span class="kt">Dual</span> <span class="o">$</span> <span class="n">refl</span>

<span class="kr">newtype</span> <span class="kt">Dual</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Dual</span> <span class="p">{</span>
  <span class="n">runDual</span> <span class="o">::</span> <span class="n">c</span> <span class="n">b</span> <span class="n">a</span>
<span class="p">}</span>

<span class="n">compose</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">b</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">c</span>
<span class="n">compose</span> <span class="o">=</span> <span class="n">subst</span>
</code></pre></div></div>

<p>We use <a href="http://www.haskell.org/haskellwiki/Newtype">newtypes</a> in place
of type lambdas, and a value instead of a method, but the
implementation is otherwise identical.</p>

<h2 id="its-really-there">It’s really there</h2>

<p>OK.  Let’s try to make a fake <code class="language-plaintext highlighter-rouge">Leib</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">badForce</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="o">$</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">error</span> <span class="s">"sorry for fibbing"</span>
</code></pre></div></div>

<p>The following code will signal an error only if forcing the <em>head
cons</em> of the <code class="language-plaintext highlighter-rouge">subst</code>ed list signals such an error.  We never give
Haskell the chance to force anything else.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
</code></pre></div></div>

<p>Oh well, let’s try to bury it behind combinators.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">symm</span> <span class="o">.</span> <span class="n">symm</span> <span class="o">$</span> <span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">compose</span> <span class="n">refl</span> <span class="o">$</span> <span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
</code></pre></div></div>

<p>Hmm.  We have two properties:</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">id</code> from <code class="language-plaintext highlighter-rouge">refl</code>?  The type-substituted data actually goes
through that function.  The same goes for the <code class="language-plaintext highlighter-rouge">subst</code> method in
Scala.</li>
  <li>When using <code class="language-plaintext highlighter-rouge">Leibniz</code> combinators, the strictness forms a chain to
all underlying <code class="language-plaintext highlighter-rouge">Leibniz</code> evidence.  If there are any missing
values, the transform will also fail.</li>
</ol>

<h2 id="higher-kinded-leibniz">Higher kinded <code class="language-plaintext highlighter-rouge">Leibniz</code></h2>

<p>Let’s try a variant on <code class="language-plaintext highlighter-rouge">Leib</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">LeibF</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This reads “<code class="language-plaintext highlighter-rouge">LeibF[G, H]</code> can replace <code class="language-plaintext highlighter-rouge">G</code> with <code class="language-plaintext highlighter-rouge">H</code> in <strong>any</strong> type
function”.  But, whereas the
<a href="https://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">kind</a>
of the types that Leib discusses is <code class="language-plaintext highlighter-rouge">*</code>, for <code class="language-plaintext highlighter-rouge">LeibF</code> it’s <code class="language-plaintext highlighter-rouge">*-&gt;*</code>.  So,
<code class="language-plaintext highlighter-rouge">LeibF[List, List]</code> exhibits that the <em>type constructors</em> <code class="language-plaintext highlighter-rouge">List</code> and
<code class="language-plaintext highlighter-rouge">List</code> are equal.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">refl</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LeibF</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">G</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Interestingly, except for the kinds of type parameters, these
definitions are exactly the same as for <code class="language-plaintext highlighter-rouge">Leib</code>.  Does that hold for
lift?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> , <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">ab</span><span class="o">.</span><span class="py">subst</span><span class="o">[</span><span class="kt">Lambda</span><span class="o">[</span><span class="kt">x</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">x</span>, <span class="kt">?</span><span class="o">]]]](</span><span class="nv">LeibF</span><span class="o">.</span><span class="py">refl</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]])</span>
</code></pre></div></div>

<p>Despite that we are positively buried in type lambdas (yet moderated
by <a href="https://github.com/non/kind-projector">Kind Projector</a>) now,
absolutely!</p>

<p>As an exercise, adapt your <code class="language-plaintext highlighter-rouge">symm</code> and <code class="language-plaintext highlighter-rouge">compose</code> methods from the last
part for <code class="language-plaintext highlighter-rouge">LeibF</code>, by only changing type parameters and switching any
<code class="language-plaintext highlighter-rouge">refl</code> references.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">symm</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">compose</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bc</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<p>You can write a <code class="language-plaintext highlighter-rouge">Leibniz</code> and associated combinators for types of
<em>any</em> kind; the principles and implementation techniques outlined
above for types of kind <code class="language-plaintext highlighter-rouge">*-&gt;*</code> apply to all kinds.</p>

<h2 id="whence-polykinds">Whence <code class="language-plaintext highlighter-rouge">PolyKinds</code>?</h2>

<p>You have to define a new <code class="language-plaintext highlighter-rouge">Leib</code> variant and set of combinators for
each kind you wish to support.  There is no need to do this in
Haskell, though.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Leib</span> <span class="kt">[]</span>
<span class="kt">Leib</span> <span class="kt">[]</span> <span class="o">::</span> <span class="p">(</span><span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">*</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span>
<span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">lift</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span>
<span class="n">lift</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="p">(</span><span class="n">f</span> <span class="kt">[]</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">[]</span><span class="p">)</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">compose</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span>
<span class="n">compose</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="kt">[]</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="kt">[]</span>
</code></pre></div></div>

<p>In Haskell, we can take advantage of the fact that the actual
implementations are kind-agnostic, by having those definitions be
applicable to all kinds via
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/kind-polymorphism.html">the <code class="language-plaintext highlighter-rouge">PolyKinds</code> language extension</a>,
mentioned at the top of the Haskell code above.  No such luck in
Scala.</p>

<h2 id="better-gadts">Better GADTs</h2>

<p><a href="http://d.hatena.ne.jp/xuwei/20140706/1404612620">In a post from a couple months ago</a>,
Kenji Yoshida outlines an interesting way to simulate the missing
type-evidence features of Scala’s GADT support with <code class="language-plaintext highlighter-rouge">Leibniz</code>.  This
works in Haskell, too, in case you are comfortable with turning on
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/other-type-extensions.html#universal-quantification"><code class="language-plaintext highlighter-rouge">RankNTypes</code></a>
but not
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/data-type-extensions.html#gadt"><code class="language-plaintext highlighter-rouge">GADTs</code></a>
somehow.</p>

<p>Let’s examine Kenji’s GADT.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>For completeness, let’s also see the Haskell version, including the
function that demands so much hoop-jumping in Scala, but just works in
Haskell.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE GADTs #-}</span>
<span class="kr">module</span> <span class="nn">FooXY</span> <span class="kr">where</span>

<span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kt">X</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">a</span>
  <span class="kt">Y</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">hoge</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="n">c</span>
<span class="n">hoge</span> <span class="kt">X</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">bar</span>
</code></pre></div></div>

<p>Note that the Haskell type system understands that when <code class="language-plaintext highlighter-rouge">hoge</code>’s first
argument’s data constructor is <code class="language-plaintext highlighter-rouge">X</code>, the type variables <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>
must be the same type, and therefore by implication the argument of
type <code class="language-plaintext highlighter-rouge">f a c</code> must also be of type <code class="language-plaintext highlighter-rouge">f b c</code>.  This is what we’re trying
to get Scala to understand.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hoge1</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">X</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">bar</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This transliteration of the above Haskell <code class="language-plaintext highlighter-rouge">hoge</code> function fails to
compile, as Kenji notes, with the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">…</span><span class="o">/</span><span class="nv">LeibnizArticle</span><span class="o">.</span><span class="py">scala</span><span class="k">:</span><span class="err">39</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">bar.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">C</span><span class="o">])</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>,<span class="kt">C</span><span class="o">]</span>
      <span class="k">case</span> <span class="nf">X</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">bar</span>
                  <span class="o">^</span>
</code></pre></div></div>

<h2 id="the-overridden-cata-method">The overridden <code class="language-plaintext highlighter-rouge">cata</code> method</h2>

<p>Kenji introduces a <code class="language-plaintext highlighter-rouge">cata</code> method on <code class="language-plaintext highlighter-rouge">Foo</code> to constrain use of the
<code class="language-plaintext highlighter-rouge">Leibniz.force</code> hack, while still providing external code with usable
<code class="language-plaintext highlighter-rouge">Leibniz</code> evidence that can be lifted to implement <code class="language-plaintext highlighter-rouge">hoge</code>.  However,
by implementing the method in a slightly different way, we can use
<code class="language-plaintext highlighter-rouge">refl</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">x</span><span class="o">(</span><span class="nv">Leib</span><span class="o">.</span><span class="py">refl</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span> <span class="k">=</span>
    <span class="nf">y</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can replace the pattern match (and all other such pattern
matches) with an equivalent <code class="language-plaintext highlighter-rouge">cata</code> invocation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hoge2</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">foo</span><span class="o">.</span><span class="py">cata</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">?</span>, <span class="kt">C</span><span class="o">]](</span><span class="n">bar</span><span class="o">),</span>
           <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sys</span> <span class="n">error</span> <span class="s">"nonexhaustive"</span><span class="o">)</span>
</code></pre></div></div>

<p>So why can we get away with <code class="language-plaintext highlighter-rouge">Leib.refl</code>, whereas the function version
Kenji presents cannot?  Compare the <code class="language-plaintext highlighter-rouge">cata</code> signature in <code class="language-plaintext highlighter-rouge">Foo</code> versus
<code class="language-plaintext highlighter-rouge">X</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
  <span class="k">def</span> <span class="nf">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</code></pre></div></div>

<p>We supplied <code class="language-plaintext highlighter-rouge">A</code> for both the <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> type parameters in our
<code class="language-plaintext highlighter-rouge">extends</code> clause, so that substitution also applies in all methods
from <code class="language-plaintext highlighter-rouge">Foo</code> that we’re implementing, including <code class="language-plaintext highlighter-rouge">cata</code>.  At that point
it’s obvious to the compiler that <code class="language-plaintext highlighter-rouge">refl</code> implements the requested
<code class="language-plaintext highlighter-rouge">Leib</code>.</p>

<p>Incidentally, a similar style of substitution underlies the definition
of <code class="language-plaintext highlighter-rouge">refl</code>.</p>

<h2 id="the-leib-member">The <code class="language-plaintext highlighter-rouge">Leib</code> member</h2>

<p>What if we don’t want to write or maintain an overriding-style <code class="language-plaintext highlighter-rouge">cata</code>?
After all, that’s an n² commitment.  Instead, we can incorporate a
<code class="language-plaintext highlighter-rouge">Leib</code> value in the GADT.  First, let’s see what the equivalent
Haskell is, without the <code class="language-plaintext highlighter-rouge">GADTs</code> extension:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">X</span> <span class="p">(</span><span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Y</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">hoge</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="n">c</span>
<span class="n">hoge</span> <span class="p">(</span><span class="kt">X</span> <span class="n">leib</span><span class="p">)</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">runDual</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">leib</span> <span class="o">.</span> <span class="kt">Dual</span> <span class="o">$</span> <span class="n">bar</span>
</code></pre></div></div>

<p>We needed <code class="language-plaintext highlighter-rouge">RankNTypes</code> to implement <code class="language-plaintext highlighter-rouge">Leib</code>, of course, but perhaps
that’s acceptable.  It’s useful in
<a href="https://ermine-language.github.io/">Ermine</a>, which supports rank-N
types but not GADTs as of this writing.</p>

<p>The above is simple enough to port to Scala, though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">leib</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">hoge3</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">X</span><span class="o">(</span><span class="n">leib</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">leib</span><span class="o">.</span><span class="py">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">?</span>, <span class="kt">C</span><span class="o">]](</span><span class="n">bar</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>It feels a little weird that <code class="language-plaintext highlighter-rouge">X</code> now must retain <code class="language-plaintext highlighter-rouge">Foo</code>’s
type-system-level separation of the two type parameters.  But this
style may more naturally integrate in your ADTs, and it is much closer
to the original non-working <code class="language-plaintext highlighter-rouge">hoge1</code> implementation.</p>

<p>It also feels a little weird that you have to waste a slot carting
around this evidence of type equality.  As demonstrated in section
“It’s really there” above, though, <em>it matters that the instance
exists</em>.</p>

<p>You can play games with this definition to make it easier to supply
the wholly mechanical <code class="language-plaintext highlighter-rouge">leib</code> argument to <code class="language-plaintext highlighter-rouge">X</code>, e.g. adding it as an
<code class="language-plaintext highlighter-rouge">implicit val</code> in the second parameter list so it can be imported and
implicitly supplied on <code class="language-plaintext highlighter-rouge">X</code> construction.  The basic technique is
exactly the same as above, though.</p>

<h2 id="leibniz-mastery"><code class="language-plaintext highlighter-rouge">Leibniz</code> mastery</h2>

<p>This time we talked about</p>

<ul>
  <li>Why it matters that <code class="language-plaintext highlighter-rouge">subst</code> always executes to use a type equality,</li>
  <li>the Haskell implementation,</li>
  <li>higher-kinded type equalities and their <code class="language-plaintext highlighter-rouge">Leibniz</code>es,</li>
  <li>simulating GADTs with <code class="language-plaintext highlighter-rouge">Leibniz</code> members of data constructors.</li>
</ul>

<p><em>This article was tested with Scala 2.11.2,
<a href="https://github.com/non/kind-projector">Kind Projector</a> 0.5.2, and
<a href="http://www.haskell.org/platform/">GHC</a> 7.8.3.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/09/20/higher_leibniz.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/09/20/higher_leibniz.html</guid>
      </item>
    
      <item>
        <title>Typelevel Scala and the future of the Scala ecosystem</title>
        
          <dc:creator>milessabin</dc:creator>
                
        <description><![CDATA[<p><strong>tl;dr</strong> Typelevel is forking Scala; we call on all stakeholders in the Scala ecosystem to collaborate on the creation of an independent, non-profit, open source foundation to safeguard the interests of the entire Scala community.</p>

<p>Last week I tweeted the following question:</p>

<div>
  <blockquote><p>How much interest would there be in a community sponsored fork of the <a href="https://twitter.com/hashtag/Scala?src=hash">#Scala</a> toolchain? RTs and fav's please.</p>&mdash; Miles Sabin (@milessabin) <a href="https://twitter.com/milessabin/status/503929023635161088">August 25, 2014</a></blockquote>
</div>

<p>It generated a lively response, both on Twitter and privately. The responses were sometimes perplexed, but typically excited and invariably positive. What I want to do here is provide some background to the question and sketch out the directions that positive answers lead.</p>

<p>As the Scala community has matured, a number of different strands of development of the language have emerged,</p>

<ul>
  <li>The Typesafe Scala compiler is focused on stability and compatibility with Java.</li>
  <li>The LAMP/EPFL Dotty compiler is focused on providing a practical implementation of the DOT calculus.</li>
  <li>The Scala.js compiler is focused on targeting JavaScript as a backend platform.</li>
  <li>The Scala Virtualized compiler is focused on language virtualization and staging.</li>
  <li>The Scala.Meta system aims to provide portable metaprogramming facilities across a variety of Scala compilers.</li>
  <li>There are several research and private variants of the Scala compiler in development and use by a variety of academic and commercial organizations.</li>
  <li>The IDEs provide their own Scala variants which more or less accurately approximate Typesafe Scala.</li>
</ul>

<p>Of these, the only compiler targeting the JVM which is generally suitable for use by the Scala community at large in the near term is the Typesafe Scala compiler. The current roadmap for the 2.12 release of this compiler, due in early 2016, has very modest goals, consistent with Typesafe’s focus. Beyond that, the Next Steps roadmap mentions many things of interest, however it is clear that these are all a long way out – it will be 2017 at the earliest before any of this sees the light of day.</p>

<p>Typesafe’s motivation for focusing on stability and Java 8 compatibility is very easy to understand. Typesafe is a commercial entity with products to sell in the JVM-based enterprise middleware space. Its primary software offerings, Akka and Play, are probably the most Java-friendly Scala projects of any significance, and simple arithmetic should tell you that a very large proportion (probably a large majority) of the potential customers for these (and the associated consultancy, training and support) are mainly Java enterprises with wholly or largely Java codebases and development teams. In this context it should be easy to see that for them an emphasis on Scala as a complement to Java, rather as its successor, is paramount.</p>

<p>Whilst this is entirely reasonable, and meets the needs of many, there is nevertheless a significant constituency at the core of the Scala community whose needs are not being fully met. This constituency is the segment of the Scala community which puts greater emphasis on typeful functional programming styles and which has a strong interest in current developments in functional programming in the wider world beyond Scala. The projects gathered here under the Typelevel umbrella are prime examples of that constituency.</p>

<p>As the producers and consumers of these and other projects we continually find ourselves running up against limitations of current Scala. Sometimes these limitations are minor and amenable to simple workarounds, many of which have passed into Scala folklore. Other limitations are more serious and can only be worked around with cumbersome encodings or otherwise elaborate and confusing hacks. These have the unfortunate consequence that elegant solutions to important problems are obscured by layers of cruft which exist only to sidestep quirks of the current compiler.</p>

<p>What makes this all the more frustrating is that many of these limitations are comparatively easy to remove. Fixes for some of them are purely syntactic – for instance type constructor partial application, of huge importance to Scalaz and its users, has a clunky encoding (“type lambdas”) which could be given first class syntactic support without any impact on Scala’s semantics and in a completely binary compatible way. Similarly, syntactic support for singleton types for literal values (see SIP-23) would be of enormous value to shapeless and Spire and their users. And the addition of literals for Bytes and Shorts would be welcomed by Spire, Scodec and many others. Other fixes, whilst affecting semantics, would do so only in a conservative way – programs which are valid when compiled with the Typesafe Scala compiler would have the same meaning and binary representation when compiled with the fixes in place.</p>

<p>With this in mind, we intend to create a new Scala distribution, as a conservative fork of the Typesafe Scala compiler, with a focus on meeting the needs of the part of the Scala community which has coalesced around the Typelevel stack. As a conservative fork, our aim is to be merge compatible from the Typesafe Scala compiler, and a key objective is to feed pull requests (many of which will resolve long standing Scala bugs or feature requests) back to the Typesafe Scala compiler. Our goal is to have a language which continues to evolve at the pace we saw until a couple of years ago, but with the difference that this will now be an opt-in process and the priorities will be set by the community.</p>

<p>Of course the devil is in the details. Forking a compiler is only a small part of the story – in many ways more important is the surrounding ecosystem of libraries. As part of this initiative we intend to publish compatible builds of at least the Typelevel libraries – taking our lead from the Typesafe community build (which attempts to track ecosystem coherence over time by building a selection of community libraries against the development Scala compiler as it evolves) and Scala.js (which has ported a selection of important community libraries to its compiler).</p>

<p>We welcome the participation of all other parties, individuals or organizations, who share our general goals – both those who want to contribute to the development of the compiler and those who would like their libraries and frameworks to be part of a Typelevel community build. It’s early days, but we hope that with enough enthusiastic participation we will be able to produce useful binaries well before the end of the year.</p>

<p>We anticipate a number of objections to this initiative,</p>

<ul>
  <li>
    <p>That it will split the community and fragment the language.</p>

    <p>As I observed earlier, there are already several variants of the language in existence and it has been clear for a long time that different sections of the community have different interests. We shouldn’t be afraid of acknowledging this fact – attempting to ignore it will be (arguably is already) counterproductive. Instead we should embrace diversity as a sign of a healthy and vigorous platform and community.</p>
  </li>
  <li>
    <p>That we don’t have the resources or the expertise to pull this off.</p>

    <p>We disagree – the community around the Typelevel projects contains many of the most able Scala programmers on the planet. Between us we have a deep understanding of Scala’s type system and other semantics (both as specified and as implemented), of compiler construction in general and of Typesafe Scala compiler internals in particular. We are intimately familiar with the Scala toolchain, which many of us have been using at scale for years in our day jobs. We are also intimately familiar with the issues that we seek to address – they are ones we face daily.</p>

    <p>We also have the existence proof of the other Scala compiler variants. The number of full-time-equivalent people working on these projects is really very small – we believe that in practice this can be matched or exceeded by an open, inclusive and enthusiastic open source project.</p>
  </li>
  <li>
    <p>That we underestimate the difficulty of maintaining binary and/or merge compatibility.</p>

    <p>No, we really don’t. We fully expect this to be the most challenging part of the whole exercise. That said, we have the benefit of years of experience of Scala binary compatibility issues, and we know now that a combination of a community-build style model along with effective use of the Migration Manager (already a component of the Typelevel SBT plugin) is enormously helpful in keeping on top of the issue.</p>

    <p>There is a real risk here, and care will be needed. One thing is for sure though – if we don’t try, we’ll never know if it’s possible.</p>
  </li>
  <li>
    <p>That the fork is too conservative.</p>

    <p>It’s certainly true that restricting ourselves to only changes which are merge compatible with the Typesafe Scala compiler puts fairly strict limits on what we can do. Many highly desirable changes fall well beyond, and some people want to explore those possibilities.</p>

    <p>We think that this is completely reasonable, and we don’t think the two are mutually exclusive – a merge compatible Typelevel compiler meets many of our immediate needs, but we want to enable people to push further just as is being done by Scala.Meta, Scala Virtualized and Dotty.</p>

    <p>We believe that the same infrastructure (community builds, MiMa) that will help the merge-compatible Typelevel compiler stay close to the Typesafe compiler will also be of great assistance to people who want to experiment with more radical changes. At a minimum, community build infrastructure will enable people to work with not just a bare compiler with but a core set of compatible libraries as well. We believe that such infrastructure would also benefit Scala Virtualized, Scala.Meta and Dotty.</p>
  </li>
</ul>

<p>This brings me to the final part of this message. It has become clear to us that there are many distinct stakeholders in the Scala ecosystem with a mixture of shared and divergent interests. This is a good thing and is something we should jointly strive to support. To that end, we believe that it is time for the formation of an independent, non-profit, open source foundation to safeguard the interests of the entire Scala community – we call on all organizations and individuals who want to see a flourishing Scala ecosystem to join with us in that project.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 02 Sep 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/09/02/typelevel-scala.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/09/02/typelevel-scala.html</guid>
      </item>
    
      <item>
        <title>The singleton instance trick is unsafe</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>Also, the “fake covariance” trick.</em></p>

<p>Sometimes, Scala programmers notice a nice optimization they can use
in the case of a class that has an invariant type parameter, but in
which that type parameter
<a href="/blog/2014/03/09/liskov_lifting.html">appears in variant or phantom position in the actual data involved</a>.
<a href="http://www.scala-lang.org/api/2.11.1/scala/Predef$$$eq$colon$eq.html"><code class="language-plaintext highlighter-rouge">=:=</code></a>
is an
<a href="https://github.com/scala/scala/blob/v2.11.1/src/library/scala/Predef.scala#L398">example of the phantom case</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">=:=</span><span class="o">[</span><span class="kt">From</span>, <span class="kt">To</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">From</span> <span class="k">=&gt;</span> <span class="nc">To</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Serializable</span>
</code></pre></div></div>

<p><a href="http://www.scala-lang.org/api/2.11.1/scala/collection/immutable/Set.html"><code class="language-plaintext highlighter-rouge">scala.collection.immutable.Set</code></a>
is an example of the covariant case.</p>

<p>Here is the optimization, which is very similar to
<a href="/blog/2014/03/09/liskov_lifting.html">the <code class="language-plaintext highlighter-rouge">Liskov</code>-lifting previously discussed</a>:
a “safe” cast of the invariant type
parameter can be made, because all operations on the casted result
remain sound.
<a href="https://github.com/scala/scala/blob/9fc098dd0dcf1825ec55501716b4f2a0a6d197ae/src/library/scala/collection/immutable/HashSet.scala#L170">Here it is for Set</a>,
an example of the “fake covariance” trick:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">def</span> <span class="nf">toSet</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span>
</code></pre></div></div>

<p>And
<a href="https://github.com/scala/scala/blob/v2.11.1/src/library/scala/Predef.scala#L399-L402">here it is for <code class="language-plaintext highlighter-rouge">=:=</code></a>,
an example of the “singleton instance” trick.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">final</span> <span class="k">val</span> <span class="nv">singleton_=:=</span> <span class="k">=</span> <span class="k">new</span> <span class="o">=:=[</span><span class="kt">Any</span>,<span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">=:=</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">tpEquals</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=:=</span> <span class="n">A</span> <span class="k">=</span> <span class="nv">singleton_=:=</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Unless you are using
<a href="https://dl.dropboxusercontent.com/u/7810909/talks/parametricity/4985cb8e6d8d9a24e32d98204526c8e3b9319e33/parametricity.pdf">the Scalazzi safe Scala subset</a>,
which forbids referentially nontransparent and nonparametric
operations, <em>these tricks are unsafe</em>.</p>

<h2 id="types-are-erased">Types are erased</h2>

<p>Many people are confused that they cannot write functions like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">addone</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
  <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Being given an error as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">A</span>
         <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
                             <span class="o">^</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">A</span>
         <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                          <span class="o">^</span>
</code></pre></div></div>

<p>Let’s consider only one case, the first. In the right-hand side (RHS)
of this case, you have not proved that <code class="language-plaintext highlighter-rouge">A</code> is <code class="language-plaintext highlighter-rouge">String</code> at all! You
have only proved that, in addition to definitely having type <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">x</code>
also definitely has type <code class="language-plaintext highlighter-rouge">String</code>. In type relationship language,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">x</span><span class="o">.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="n">A</span>
<span class="nv">x</span><span class="o">.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">String</span>
</code></pre></div></div>

<p>All elephants are grey and are also animals, but it does not follow
that all grey things are animals or vice versa. If you use a cast to
“fix” this, you have produced type-incorrect code, period.</p>

<h2 id="type-recovery">Type recovery</h2>

<p>Under special circumstances, however, information about a type
parameter can be recovered, safe and sound. Take this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">SBox</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">IBox</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">addone2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">Box</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">b</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">SBox</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
  <span class="k">case</span> <span class="nc">IBox</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This compiles, and I don’t even have to have data in the box to get at
the type information that <code class="language-plaintext highlighter-rouge">A ~ String</code> or <code class="language-plaintext highlighter-rouge">A ~ Int</code>.  Consider the
first case.  On the RHS, I have</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">b</span><span class="o">.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">SBox</span> <span class="k">&lt;:</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="nv">b</span><span class="o">.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>In addition, <strong><code>A</code> is invariant</strong>, so after going up to
<code class="language-plaintext highlighter-rouge">Box[String]</code>, <code class="language-plaintext highlighter-rouge">b</code> couldn’t have widened that type parameter, or
changed it in any way, without an unsafe cast.  Additionally, our
supertype tree cannot contain <code class="language-plaintext highlighter-rouge">Box</code> twice with different parameters.
So we have proved that <code class="language-plaintext highlighter-rouge">A</code> is <code class="language-plaintext highlighter-rouge">String</code>, because we proved that
<code class="language-plaintext highlighter-rouge">Box[A]</code> is <code class="language-plaintext highlighter-rouge">Box[String]</code>.</p>

<p>This is very useful when defining
<a href="http://www.haskell.org/haskellwiki/GADTs_for_dummies">GADTs</a>.</p>

<h2 id="partial-type-recovery">Partial type recovery</h2>

<p>Let’s consider a similar ADT with the type parameter marked variant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CovBox</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">CovSBox</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">CovBox</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">addone3</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">CovBox</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">b</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">CovSBox</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This works too, because in the RHS of the case, we proved that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">b</span><span class="o">.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">CovSBox</span> <span class="k">&lt;:</span> <span class="nc">CovBox</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">&lt;:</span> <span class="nc">CovBox</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">String</span> <span class="k">&lt;:</span> <span class="n">A</span>
</code></pre></div></div>

<p>The only transform in type <code class="language-plaintext highlighter-rouge">A</code> could have possibly undergone is a
widening, which <em>must</em> have begun at <code class="language-plaintext highlighter-rouge">String</code>. A similar example can
be derived for contravariance.</p>

<h2 id="singleton-surety">Singleton surety</h2>

<p>In our first example, there is one type that we know must be a subtype
of <code class="language-plaintext highlighter-rouge">A</code>, no matter what!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">addone</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span><span class="k">:</span> <span class="kt">x.type</span>
</code></pre></div></div>

<p>(Scala doesn’t like it when we talk about singleton types without an
<code class="language-plaintext highlighter-rouge">AnyRef</code> upper bound at least.  But the underlying principle holds for
all value types.)</p>

<p>Where <code class="language-plaintext highlighter-rouge">x</code> is an <code class="language-plaintext highlighter-rouge">A</code> of stable type, <code class="language-plaintext highlighter-rouge">x.type &lt;: A</code> for all possible <code class="language-plaintext highlighter-rouge">A</code>
types.  You might say, “that’s uninteresting; obviously <code class="language-plaintext highlighter-rouge">x</code> is an <code class="language-plaintext highlighter-rouge">A</code>
in this code.”  But that isn’t what we’re talking about; our premise
is that <strong>any</strong> value of type <code class="language-plaintext highlighter-rouge">x.type</code> is also an <code class="language-plaintext highlighter-rouge">A</code>!</p>

<p>So if we could prove that something else had the singleton type
<code class="language-plaintext highlighter-rouge">x.type</code>, we would also prove that it shared all of <code class="language-plaintext highlighter-rouge">x</code>’s types!  We
can do that with a singleton type pattern, which is implemented
(soundly in 2.11) with a reference comparison.  Scala lets us use
<em>some</em> of the resulting implications.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">InvBox</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">maybeeq</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">InvBox</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">InvBox</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">y</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">x.</span><span class="k">type</span> <span class="o">=&gt;</span> <span class="nv">y</span><span class="o">.</span><span class="py">b</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="unsafety">Unsafety</h2>

<p>To which you might protest, “there’s only one value of any singleton
type!”  Well, yes.  And here’s where our seemingly innocent
optimization turns nasty.  If you’ll recall, it depends upon treating
a value with multiple types via an unsafe cast.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">unsafeCoerce</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">A</span><span class="o">]</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">B</span> <span class="kt">=:=</span> <span class="kt">B</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">a.</span><span class="k">type</span> <span class="o">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">unsafeCoerce2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]()</span>
  <span class="k">val</span> <span class="nv">b</span> <span class="k">=</span> <span class="nv">n</span><span class="o">.</span><span class="py">toSet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="nv">n</span><span class="o">.</span><span class="py">toSet</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">b.</span><span class="k">type</span> <span class="o">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Both of these compile to what is in essence an identity function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">unsafeCoerce</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">](</span><span class="s">"hi"</span><span class="o">))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">unsafeCoerce2</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">](</span><span class="s">"hi"</span><span class="o">))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span>
</code></pre></div></div>

<p>In our invariant <code class="language-plaintext highlighter-rouge">Box</code> example we decided that, as it was impossible
to change the type parameter without an unsafe cast, we could use that
knowledge in the consequent types. In <code class="language-plaintext highlighter-rouge">unsafeCoerce</code>, where <code class="language-plaintext highlighter-rouge">?</code>
represents the value before the match keyword:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nv">a</span><span class="o">.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="o">(</span><span class="n">A</span> <span class="o">=:=</span> <span class="n">A</span><span class="o">)</span>
<span class="o">?.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="o">(</span><span class="n">B</span> <span class="o">=:=</span> <span class="n">B</span><span class="o">)</span>
<span class="n">A</span> <span class="o">~</span> <span class="n">B</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">unsafeCoerce2</code>,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nv">b</span><span class="o">.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">?.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="n">A</span> <span class="o">~</span> <span class="n">B</span>
</code></pre></div></div>

<p><strong>There is nothing wrong with Scala making this logical inference. The
“optimization” of that cast is not safe.</strong></p>

<p>Let me reiterate: <strong>Scala’s type inference surrounding pattern
matching should not be “fixed” to make unsafe casts “safer” and steal
our GADTs. Unsafe code is unsafe.</strong></p>

<h2 id="scalazzi-safe-scala-subset-saves-us">Scalazzi safe Scala subset saves us</h2>

<p>For types like these, it is not possible to exploit this unsafety
without a reference check, which is what a singleton type pattern
compiles to.  As the Scalazzi safe subset forbids referentially
nontransparent operations, if you follow its rules, these
optimizations become safe again.</p>

<p>This is just yet another of countless ways in which following the
Scalazzi rules makes your code safer and easier to reason about.</p>

<p>That isn’t to say it’s impossible to derive a situation where the
optimization exposes an <code class="language-plaintext highlighter-rouge">unsafeCoerce</code> in Scalazzi code.  However, you
must specially craft a type in order to do so.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Oops</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">widen</span><span class="o">[</span><span class="kt">B</span><span class="k">&gt;:</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Oops</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">Oops</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Bot</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">Oops</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">unsafeCoerce3</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="nc">Bot</span><span class="o">()</span>
  <span class="nv">x</span><span class="o">.</span><span class="py">widen</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Bot</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The implication being</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">Bot</span> <span class="k">&lt;:</span> <span class="nc">Oops</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
<span class="o">?.</span><span class="py">type</span> <span class="k">&lt;:</span> <span class="nc">Oops</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">Nothing</span> <span class="o">~</span> <span class="n">A</span>
</code></pre></div></div>

<p>Scalaz
<a href="https://github.com/scalaz/scalaz/blob/v7.0.6/core/src/main/scala/scalaz/IList.scala#L436-L437">uses the optimization under consideration in <code class="language-plaintext highlighter-rouge">scalaz.IList</code></a>.
So would generalized <code class="language-plaintext highlighter-rouge">Functor</code>-based <code class="language-plaintext highlighter-rouge">Liskov</code>-lifting, as discussed at
the end of <a href="/blog/2014/03/09/liskov_lifting.html">“When can Liskov be lifted?”</a>,
were it to be implemented.  However, these cases do not fit the bill
for exploitation from Scalazzi-safe code.</p>

<p>On the other hand, the singleton type pattern approach may be used in
<em>all</em> cases where the optimization may be invoked by a caller,
including standard library code where some well-meaning contributor
might add such a harmless-seeming avoidance of memory allocation
without your knowledge.  Purity pays, and often in very nonobvious
ways.</p>

<p><em>This article was tested with Scala 2.11.1.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 06 Jul 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/07/06/singleton_instance_trick_unsafe.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/07/06/singleton_instance_trick_unsafe.html</guid>
      </item>
    
      <item>
        <title>A function from type equality to Leibniz</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>The Scala standard library provides evidence of two types being equal
at the data level: a value of type
<a href="http://www.scala-lang.org/api/2.11.1/scala/Predef$$$eq$colon$eq.html"><code class="language-plaintext highlighter-rouge">(A =:= B)</code></a>
witnesses that <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are the same type. Accordingly, it provides
an implicit conversion from <code class="language-plaintext highlighter-rouge">A</code> to <code class="language-plaintext highlighter-rouge">B</code>. So you can write <code class="language-plaintext highlighter-rouge">Int</code>-summing
functions on your generic foldable types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=:=</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="nv">xs</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That works because <code class="language-plaintext highlighter-rouge">ev</code> is inserted as an implicit conversion over
that lambda’s second parameter.</p>

<h2 id="fragility">Fragility</h2>

<p>That’s not really what we want, though. In particular, flipping <code class="language-plaintext highlighter-rouge">A</code>
and <code class="language-plaintext highlighter-rouge">Int</code> in the <code class="language-plaintext highlighter-rouge">ev</code> type declaration will break it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>….scala:5: overloaded method value + with alternatives:
  (x: Int)Int &lt;and&gt;
  (x: Char)Int &lt;and&gt;
  (x: Short)Int &lt;and&gt;
  (x: Byte)Int
 cannot be applied to (A)
    xs.foldLeft(0)(_ + _)
                     ^
</code></pre></div></div>

<p>That doesn’t make sense, though. Type equality is symmetric: Scala
knows it goes both ways, so why is this finicky?</p>

<p>Additionally, we apply the conversion for each <code class="language-plaintext highlighter-rouge">Int</code>. It is a logical
implication that, if <code class="language-plaintext highlighter-rouge">A</code> is <code class="language-plaintext highlighter-rouge">B</code>, then <code class="language-plaintext highlighter-rouge">List[A]</code> must be <code class="language-plaintext highlighter-rouge">List[B]</code> as
well. But we can’t get that cheap, single conversion without a cast.</p>

<h2 id="substitution">Substitution</h2>

<p>Scalaz instead provides
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/scalaz/Leibniz.html"><code class="language-plaintext highlighter-rouge">Leibniz</code></a>,
a more perfect type equality. A simplified version follows, which we
will use for the remainder.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This reads “<code class="language-plaintext highlighter-rouge">Leib[A, B]</code> can replace <code class="language-plaintext highlighter-rouge">A</code> with <code class="language-plaintext highlighter-rouge">B</code> in <strong>any</strong> type
function”. That “any” is pretty important: it gives us both the
theorem that we want, and a tremendous consequent power that gives us
most of what we can get in Scala from value-level type equality, by
choosing the right <code class="language-plaintext highlighter-rouge">F</code> type parameter to <code class="language-plaintext highlighter-rouge">subst</code>.</p>

<h2 id="what-could-it-be">What could it be?</h2>

<p>Following the Scalazzi rules, where no <code class="language-plaintext highlighter-rouge">null</code>, type testing or
casting, or <code class="language-plaintext highlighter-rouge">AnyRef</code>-defined functions are permitted, what might go in
the body of that function? Even if you know what <code class="language-plaintext highlighter-rouge">A</code> is, as a <code class="language-plaintext highlighter-rouge">Leib</code>
implementer, it’s hidden behind the unknown <code class="language-plaintext highlighter-rouge">F</code>. Even if you know that
<code class="language-plaintext highlighter-rouge">B</code> is a supertype of <code class="language-plaintext highlighter-rouge">A</code>, you don’t know that <code class="language-plaintext highlighter-rouge">F</code> is covariant,
<a href="/blog/2014/03/09/liskov_lifting.html">by scalac or otherwise</a>.
Even if you know that <code class="language-plaintext highlighter-rouge">A</code> is <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">B</code> is <code class="language-plaintext highlighter-rouge">Double</code>, what are you
going to do with that information?</p>

<p>So there’s only one thing this <code class="language-plaintext highlighter-rouge">Leib</code> could be, because you <strong>do</strong>
have an <code class="language-plaintext highlighter-rouge">F</code> of <em>something</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">refl</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Every type is equal to itself. Every well-formed <code class="language-plaintext highlighter-rouge">Leib</code> instance
starts out this way, in this function.</p>

<h2 id="recovery">Recovery</h2>

<p>So, it’s great that <em>we</em> know the implication of the <code class="language-plaintext highlighter-rouge">subst</code> method’s
generality. But that’s not good enough; we had that with <code class="language-plaintext highlighter-rouge">=:=</code>
already. We want to write well-typed operations that represent all the
implications of the <code class="language-plaintext highlighter-rouge">Leib</code> type equality as <em>new</em> <code class="language-plaintext highlighter-rouge">Leib</code>s representing
<em>those</em> type equalities.</p>

<p>First, let’s solve the original problem, using infix type application
to show the similarity to <code class="language-plaintext highlighter-rouge">=:=</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum2</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="nv">ev</span><span class="o">.</span><span class="py">subst</span><span class="o">[</span><span class="kt">List</span><span class="o">](</span><span class="n">xs</span><span class="o">).</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>There is no more implicit conversion, the result of <code class="language-plaintext highlighter-rouge">subst</code> is the same
object as the argument, and <code class="language-plaintext highlighter-rouge">[List]</code> would be inferred, but I have
merely specified it for clarity in this example.</p>

<p>This doesn’t compose, though. What if, having <code class="language-plaintext highlighter-rouge">subst</code>ed <code class="language-plaintext highlighter-rouge">Int</code> into
that <code class="language-plaintext highlighter-rouge">List</code> type, I now want to <code class="language-plaintext highlighter-rouge">subst</code> <code class="language-plaintext highlighter-rouge">List[A]</code> for <code class="language-plaintext highlighter-rouge">List[Int]</code> in
some type function? Specifically, what about a <code class="language-plaintext highlighter-rouge">Leib</code> that represents
that type equality? To handle that, we can <code class="language-plaintext highlighter-rouge">subst</code> into <code class="language-plaintext highlighter-rouge">Leib</code> itself!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">ab</span><span class="o">.</span><span class="py">subst</span><span class="o">[</span><span class="kt">Lambda</span><span class="o">[</span><span class="kt">X</span> <span class="k">=&gt;</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]]]](</span><span class="nv">Leib</span><span class="o">.</span><span class="py">refl</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<p>Again, the final <code class="language-plaintext highlighter-rouge">[F[A]]</code> could be inferred.</p>

<p>As an exercise, define the <code class="language-plaintext highlighter-rouge">symm</code> and <code class="language-plaintext highlighter-rouge">compose</code> operations, which
represent that <code class="language-plaintext highlighter-rouge">Leib</code> is symmetric and transitive as well. Hints: the
<code class="language-plaintext highlighter-rouge">symm</code> body is the same except for the type parameters given, and
<code class="language-plaintext highlighter-rouge">compose</code> doesn’t use <code class="language-plaintext highlighter-rouge">refl</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">symm</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">compose</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bc</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="leib-power">Leib power</h2>

<p>In Scalaz, <code class="language-plaintext highlighter-rouge">Leibniz</code> is already defined, and
<a href="https://github.com/scalaz/scalaz/blob/v7.0.6/core/src/main/scala/scalaz/syntax/TraverseSyntax.scala#L22-L26">used in a few places</a>.
Though their <code class="language-plaintext highlighter-rouge">subst</code> definitions are completely incompatible at the
scalac level, they have a weird equivalence due to the awesome power
of <code class="language-plaintext highlighter-rouge">subst</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Leibniz</span><span class="o">,</span> <span class="nc">Leibniz</span><span class="o">.===</span>

<span class="k">def</span> <span class="nf">toScalaz</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">===</span> <span class="n">B</span> <span class="k">=</span>
  <span class="nv">ab</span><span class="o">.</span><span class="py">subst</span><span class="o">[</span><span class="kt">A</span> <span class="kt">===</span> <span class="kt">?</span><span class="o">](</span><span class="nv">Leibniz</span><span class="o">.</span><span class="py">refl</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">toLeib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">A</span> <span class="o">===</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span> <span class="o">=</span>
  <span class="nv">ab</span><span class="o">.</span><span class="py">subst</span><span class="o">[</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">?</span><span class="o">](</span><span class="nv">Leib</span><span class="o">.</span><span class="py">refl</span><span class="o">)</span>
</code></pre></div></div>

<p>…where <code class="language-plaintext highlighter-rouge">?</code> is to type-lambdas as <code class="language-plaintext highlighter-rouge">_</code> is to Scala lambdas, thanks to
<a href="https://github.com/non/kind-projector#kind-projector">the Kind Projector plugin</a>.</p>

<p>And so it would be with any pair of <code class="language-plaintext highlighter-rouge">Leibniz</code> representations with such
<code class="language-plaintext highlighter-rouge">subst</code> methods that you might define. Unfortunately, <code class="language-plaintext highlighter-rouge">=:=</code> cannot
participate in this universe of isomorphisms; it lacks the <code class="language-plaintext highlighter-rouge">subst</code>
method that serves as the <code class="language-plaintext highlighter-rouge">Leibniz</code> certificate of authenticity. You can
get a <code class="language-plaintext highlighter-rouge">=:=</code> from a <code class="language-plaintext highlighter-rouge">Leibniz</code>, but not vice versa.</p>

<p>Why would you want that weak sauce anyway?</p>

<h2 id="looking-up">Looking up</h2>

<p>These are just the basics.  Above:</p>

<ul>
  <li>The weakness of Scala’s own <code class="language-plaintext highlighter-rouge">=:=</code>,</li>
  <li>the sole primitive <code class="language-plaintext highlighter-rouge">Leibniz</code> operator <code class="language-plaintext highlighter-rouge">subst</code>,</li>
  <li>how to logically derive other type equalities,</li>
  <li>the isomorphism between each <code class="language-plaintext highlighter-rouge">Leibniz</code> representation and all
others.</li>
</ul>

<p><a href="/blog/2014/09/20/higher_leibniz.html">In the next part</a>, we’ll
look at:</p>

<ul>
  <li>Why it matters that <code class="language-plaintext highlighter-rouge">subst</code> always executes to use a type equality,</li>
  <li>the Haskell implementation,</li>
  <li>higher-kinded type equalities and their <code class="language-plaintext highlighter-rouge">Leibniz</code>es,</li>
  <li>why
<a href="https://github.com/scala/scala/blob/v2.11.1/src/library/scala/Predef.scala#L399-L402">the <code class="language-plaintext highlighter-rouge">=:=</code> singleton trick</a>
is unsafe,</li>
  <li>simulating GADTs with <code class="language-plaintext highlighter-rouge">Leibniz</code> members of data constructors.</li>
</ul>

<p><em>This article was tested with Scala 2.11.1, Scalaz 7.0.6, and Kind
Projector 0.5.2.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 02 Jul 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/07/02/type_equality_to_leibniz.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/07/02/type_equality_to_leibniz.html</guid>
      </item>
    
      <item>
        <title>How can we map a Set?</title>
        
          <dc:creator>puffnfresh</dc:creator>
                
        <description><![CDATA[<p>Scalaz used to have a <code class="language-plaintext highlighter-rouge">scalaz.Functor</code> for <code class="language-plaintext highlighter-rouge">scala.collection.Set</code> but
it was <a href="https://github.com/scalaz/scalaz/pull/276">eventually removed</a>
because it relied on
<a href="http://www.scala-lang.org/api/2.10.3/index.html#scala.Any">Any’s == method</a>. You
can read more about why <code class="language-plaintext highlighter-rouge">Functor[Set]</code> is a bad idea at
<a href="http://failex.blogspot.jp/2013/06/fake-theorems-for-free.html">Fake Theorems for Free</a>.</p>

<p>If <code class="language-plaintext highlighter-rouge">Set</code> had been truly parametric, we wouldn’t have been able to
define a <code class="language-plaintext highlighter-rouge">Functor</code> in the first place. Luckily, a truly parametric Set
has recently been added to Scalaz as <code class="language-plaintext highlighter-rouge">scalaz.ISet</code>, with preliminary
benchmarks also showing some nice performance improvements. I highly
recommend using <code class="language-plaintext highlighter-rouge">ISet</code> whenever you can!</p>

<p>Now we can see the problem more clearly; the type of <code class="language-plaintext highlighter-rouge">map</code> on <code class="language-plaintext highlighter-rouge">ISet</code>
is too restrictive to be used inside of a <code class="language-plaintext highlighter-rouge">Functor</code> because of the
<code class="language-plaintext highlighter-rouge">scalaz.Order</code> constraint:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">ISet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>And it might seem like we’ve lost something useful by not having a
<code class="language-plaintext highlighter-rouge">Functor</code> available. For example, we can’t write the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">nes</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">(</span><span class="s">"2014-05-01"</span><span class="o">,</span> <span class="nv">ISet</span><span class="o">.</span><span class="py">fromList</span><span class="o">(</span><span class="s">"2014-06-01"</span> <span class="o">::</span> <span class="s">"2014-06-22"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span> <span class="c1">// a non-empty Set
</span><span class="k">val</span> <span class="nv">OneAnd</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=</span> <span class="nv">nes</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">parseDate</span><span class="o">)</span>
</code></pre></div></div>

<p>Which is because the <code class="language-plaintext highlighter-rouge">map</code> function on <code class="language-plaintext highlighter-rouge">scalaz.OneAnd</code> requires a
<code class="language-plaintext highlighter-rouge">scalaz.Functor</code> for the <code class="language-plaintext highlighter-rouge">F[_]</code> type parameter, which is <code class="language-plaintext highlighter-rouge">ISet</code> in the
above example.</p>

<p>But we have a solution! It’s called
<a href="http://docs.typelevel.org/api/scalaz/nightly/#scalaz.Coyoneda">Coyoneda</a>
(also known as the Free Functor) and it’ll hopefully be able to
demonstrate why not having <code class="language-plaintext highlighter-rouge">Functor[ISet]</code> available has no
fundamental, practical consequences.</p>

<p>Coyoneda
<a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">can be defined in Scala</a>
like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">I</span>
  <span class="k">def</span> <span class="nf">k</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
  <span class="k">def</span> <span class="nf">fi</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>There are just three parts to it:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">I</code> - an existential type</li>
  <li><code class="language-plaintext highlighter-rouge">k</code> - a mapping from <code class="language-plaintext highlighter-rouge">I</code> to <code class="language-plaintext highlighter-rouge">A</code></li>
  <li><code class="language-plaintext highlighter-rouge">fi</code> - a value of <code class="language-plaintext highlighter-rouge">F[I]</code></li>
</ol>

<p>We can create a couple of functions to help with constructing a
Coyoneda value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="nc">_k</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span> <span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span>
    <span class="k">val</span> <span class="nv">k</span> <span class="k">=</span> <span class="nc">_k</span>
    <span class="k">val</span> <span class="nv">fi</span> <span class="k">=</span> <span class="n">fa</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">identity</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>The constructors allow any type constructor to become a Coyoneda value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">s</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">ISet</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Coyoneda</span><span class="o">.</span><span class="py">lift</span><span class="o">(</span><span class="nv">ISet</span><span class="o">.</span><span class="py">fromList</span><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
</code></pre></div></div>

<p>Now here’s the special part; we can define a <code class="language-plaintext highlighter-rouge">Functor</code> for all
Coyoneda values:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">coyonedaFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ya</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">(</span><span class="nv">ya</span><span class="o">.</span><span class="py">fi</span><span class="o">)(</span><span class="n">f</span> <span class="n">compose</span> <span class="nv">ya</span><span class="o">.</span><span class="py">k</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>What’s interesting is that the <code class="language-plaintext highlighter-rouge">F[_]</code> type does <em>not</em> have to have a
<code class="language-plaintext highlighter-rouge">Functor</code> defined for the Coyoneda to be mapped!</p>

<p>Let’s use this to try out our original example. We’ll define a type
alias to make things a bit cleaner:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">ISetF</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">ISet</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>And we can use this new type instead of a plain <code class="language-plaintext highlighter-rouge">ISet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Scala has a really hard time with inference here, so we have to help it out.
</span><span class="k">val</span> <span class="nv">functor</span> <span class="k">=</span> <span class="nv">OneAnd</span><span class="o">.</span><span class="py">oneAndFunctor</span><span class="o">[</span><span class="kt">ISetF</span><span class="o">](</span><span class="nv">Coyoneda</span><span class="o">.</span><span class="py">coyonedaFunctor</span><span class="o">[</span><span class="kt">ISet</span><span class="o">])</span>
<span class="k">import</span> <span class="nn">functor.functorSyntax._</span>

<span class="k">val</span> <span class="nv">nes</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">[</span><span class="kt">ISetF</span>, <span class="kt">String</span><span class="o">](</span><span class="s">"2014-05-01"</span><span class="o">,</span> <span class="nv">Coyoneda</span><span class="o">.</span><span class="py">lift</span><span class="o">(</span><span class="nv">ISet</span><span class="o">.</span><span class="py">fromList</span><span class="o">(</span><span class="s">"2014-06-01"</span> <span class="o">::</span> <span class="s">"2014-06-22"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span>
<span class="k">val</span> <span class="nv">OneAnd</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=</span> <span class="nv">nes</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">parseDate</span><span class="o">)</span>
</code></pre></div></div>

<p>So we’ve been able to map the Coyoneda! But how do we do something
useful with it?</p>

<p>We couldn’t define a <code class="language-plaintext highlighter-rouge">Functor</code> because it needs <code class="language-plaintext highlighter-rouge">scalaz.Order</code> on the
output type, but we can use the <code class="language-plaintext highlighter-rouge">map</code> method directly on <code class="language-plaintext highlighter-rouge">ISet</code>. We
can use that function by running the Coyoneda like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Converts ISetF back to an ISet, using ISet#map with the Order constraint
</span><span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">t</span><span class="o">.</span><span class="py">fi</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">t</span><span class="o">.</span><span class="py">k</span><span class="o">).</span><span class="py">insert</span><span class="o">(</span><span class="n">h</span><span class="o">)</span>
</code></pre></div></div>

<p>And we’re done!</p>

<p>We’ve been able to use Coyoneda to treat an <code class="language-plaintext highlighter-rouge">ISet</code> as a <code class="language-plaintext highlighter-rouge">Functor</code>,
even though its map function is too constrained to have one defined
directly. This same technique applies to <code class="language-plaintext highlighter-rouge">scala.collection.Set</code> and
any other type-constructor which would otherwise require a
<a href="http://okmij.org/ftp/Haskell/types.html#restricted-datatypes">restricted <code class="language-plaintext highlighter-rouge">Functor</code></a>. I
hope this has demonstrated that <code class="language-plaintext highlighter-rouge">Functor[Set]</code> not existing has no
practical consequences, other than scalac not being as good at
type-inference.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 22 Jun 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/06/22/mapping-sets.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/06/22/mapping-sets.html</guid>
      </item>
    
      <item>
        <title>Primitive recursion with fix and Mu</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>Consider the simple cons-list datatype.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Equal</span><span class="o">,</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">std</span><span class="o">.</span><span class="py">option</span><span class="o">.</span><span class="py">_</span><span class="o">,</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">syntax</span><span class="o">.</span><span class="py">std</span><span class="o">.</span><span class="py">option</span><span class="o">.</span><span class="py">_</span><span class="o">,</span>
       <span class="nv">scalaz</span><span class="o">.</span><span class="py">std</span><span class="o">.</span><span class="py">anyVal</span><span class="o">.</span><span class="py">_</span><span class="o">,</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">std</span><span class="o">.</span><span class="py">function</span><span class="o">.</span><span class="py">_</span><span class="o">,</span>
       <span class="nv">scala</span><span class="o">.</span><span class="py">reflect</span><span class="o">.</span><span class="py">runtime</span><span class="o">.</span><span class="py">universe</span><span class="o">.</span><span class="py">reify</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XNil</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>And a simple function over this structure.  Say, a simple summing
function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="nf">sum</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And that seems to work out alright.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">nums</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">XNil</span><span class="o">()))))</span>
<span class="n">nums</span><span class="k">:</span> <span class="kt">XCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="nc">XNil</span><span class="o">()))))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">sum</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div></div>

<p>Has it ever struck you as curious that, though its own value was
required to construct a value like <code class="language-plaintext highlighter-rouge">sum</code>, the system has no problem
with that?</p>

<p>Oh, well, that’s just a recursive function, you say.  Well, what’s so
special about recursive functions?  Why do they get special treatment
so that they can define themselves with themselves?</p>

<h2 id="induction-and-termination">Induction and termination</h2>

<p>First, let’s be clear: there’s a limit to how much of <code class="language-plaintext highlighter-rouge">sum</code> can be
used in its own definition.</p>

<p>Let us consider the moral equivalent of the statement “this function
gives the sum of a list of integers because it is the function that
gives the sum of a list of integers.”</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">sum2</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
</code></pre></div></div>

<p>scalac will compile this definition; it is well-typed.  However, it
will be nonsensical at runtime, because it is nonsense; it will either
throw some exception or loop forever.</p>

<p>Let us consider a similar case: the infinite list of 42s.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">fortyTwos</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mi">42</span> <span class="o">#::</span> <span class="n">fortyTwos</span>
<span class="n">fortyTwos</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fortyTwos</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">toList</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>The definition of <code class="language-plaintext highlighter-rouge">fortyTwos</code> is like that of <code class="language-plaintext highlighter-rouge">sum</code>; it uses its own
value while constructing said value.  A similar definition to <code class="language-plaintext highlighter-rouge">sum2</code>
is, likewise, nonsense, though scalac can catch this particular case:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">fortyTwos2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fortyTwos2</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">fortyTwos2</span> <span class="kt">does</span> <span class="kt">nothing</span> <span class="kt">other</span> <span class="kt">than</span> <span class="kt">call</span> <span class="kt">itself</span> <span class="kt">recursively</span>
       <span class="k">val</span> <span class="nv">fortyTwos2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fortyTwos2</span>
                                     <span class="o">^</span>
</code></pre></div></div>

<p>Obviously, functions <em>aren’t</em> special; non-function values, like
functions, can be defined using their own values.  But how can we
characterize the difference between the good, terminating definitions,
and the bad, nonterminating definitions?</p>

<p>Proof systems like Coq and Agda perform a strong check on recursive
definitions; for definitions like <code class="language-plaintext highlighter-rouge">sum</code>, they require the recursion
match the structure of the data type, just as ours does, so that each
recursive call is known to operate over smaller data.  For definitions
like <code class="language-plaintext highlighter-rouge">fortyTwos</code>, they apply other strategies.  In Scala, we have to
make do with informality.</p>

<p>I like to think of it this way: <strong>a recursive definition must always
perform at least one inductive step</strong>.  <code class="language-plaintext highlighter-rouge">sum</code> does so because, in the
recursive case, it gives “supposing I have the sum of <code class="language-plaintext highlighter-rouge">tail</code>, the sum
is the <code class="language-plaintext highlighter-rouge">head</code> plus that.”  <code class="language-plaintext highlighter-rouge">fortyTwos</code> does because it says “the value
<code class="language-plaintext highlighter-rouge">fortyTwos</code> is <code class="language-plaintext highlighter-rouge">42</code> consed onto the value <code class="language-plaintext highlighter-rouge">fortyTwos</code>.”  It is, at
least, the start of a systematic way of thinking about terminating
recursive definitions.</p>

<h2 id="abstracting-the-recursion">Abstracting the recursion</h2>

<p>Now that we have a framework for thinking about what is required in a
recursive definition, we can start abstracting over it.</p>

<p>The above recursive definitions were accomplished with special
language support: the right-hand side of any term definition, <code class="language-plaintext highlighter-rouge">val</code> or
<code class="language-plaintext highlighter-rouge">def</code>, can refer to the thing being so defined.  Scalaz provides
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/scalaz/std/function$.html">the <code class="language-plaintext highlighter-rouge">fix</code> function</a>,
which, if it were provided intrinsically, would eliminate the need for
this language support.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fix</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(=&gt;</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="n">a</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In this definition, the value returned by <code class="language-plaintext highlighter-rouge">f</code> <em>is</em> the value given to
it as an argument.  It’s a by-name argument because that’s how we
enforce the requirement: <code class="language-plaintext highlighter-rouge">f</code> must perform at least one inductive step
in the definition of its result, though it can refer to that result by
its argument, which we enforce by requiring it to return a value
<em>before</em> evaluating that argument.</p>

<p>Let’s redefine <code class="language-plaintext highlighter-rouge">sum</code> with <code class="language-plaintext highlighter-rouge">fix</code>, after importing it from
<code class="language-plaintext highlighter-rouge">scalaz.std.function</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">sum3</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">fix</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kt">Int</span><span class="o">](</span><span class="n">rec</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="nv">rec</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">})</span>
</code></pre></div></div>

<p>And Scala thinks that’s alright.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">sum3</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div></div>

<p>The interesting thing here is that <code class="language-plaintext highlighter-rouge">sum3</code>’s definition doesn’t refer
to the name <code class="language-plaintext highlighter-rouge">sum3</code>; the recursion is entirely inside the <code class="language-plaintext highlighter-rouge">fix</code>
argument.  So one advantage of <code class="language-plaintext highlighter-rouge">fix</code> is that it’s easy to write
recursive values as expressions without giving them a name.</p>

<p>For example, there’s the definition of <code class="language-plaintext highlighter-rouge">fortyTwos</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fix</span><span class="o">[</span><span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="mi">42</span> <span class="o">#::</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">toList</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="for-special-data-structures">For special data structures</h2>

<p>It can be inconvenient to avoid evaluating the argument when providing
an induction step.  Fortunately, the requirement that <code class="language-plaintext highlighter-rouge">f</code> be nonstrict
in its argument is too strong to characterize the space of values that
can be defined with <code class="language-plaintext highlighter-rouge">fix</code>-style recursion.</p>

<p>For a given data type, there’s often a way to abstract out the
nonstrictness.  For example, here’s an <code class="language-plaintext highlighter-rouge">Equal</code> instance combinator
that is fully evaluated, but doesn’t force the argument until after
the (equivalent) result has been produced.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lazyEqual</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">A</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">equal</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">A</span> <span class="nf">equal</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">equalIsNatural</span> <span class="k">=</span> <span class="nv">A</span><span class="o">.</span><span class="py">equalIsNatural</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Given that, we can produce a <code class="language-plaintext highlighter-rouge">fix</code> variant for <code class="language-plaintext highlighter-rouge">Equal</code> that passes the
<code class="language-plaintext highlighter-rouge">Equal</code> argument strictly.  You’re simply not allowed to invoke any of
the typeclass’s methods.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fixEq</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">fix</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="nf">lazyEqual</span><span class="o">(</span><span class="n">A</span><span class="o">)))</span>
</code></pre></div></div>

<p>And now, we have the machinery to build a fully derived <code class="language-plaintext highlighter-rouge">Equal</code>
instance for <code class="language-plaintext highlighter-rouge">XList</code>, without function recursion, by defining the base
case and inductive step!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">`</span><span class="n">list</span> <span class="n">equal</span><span class="o">`[</span><span class="kt">A:</span> <span class="kt">Equal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">fixEq</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">rec</span> <span class="k">=&gt;</span>
    <span class="nv">Equal</span><span class="o">.</span><span class="py">equalBy</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])]]{</span>
      <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
      <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
    <span class="o">})</span>
</code></pre></div></div>

<p>That works out to interesting compiled output.  Note especially the
last line, and its (strict) use of <code class="language-plaintext highlighter-rouge">rec</code> towards the end.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">reify</span><span class="o">(</span><span class="n">fixEq</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">rec</span> <span class="k">=&gt;</span>
     <span class="o">|</span>     <span class="nv">Equal</span><span class="o">.</span><span class="py">equalBy</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])]]{</span>
     <span class="o">|</span>       <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
     <span class="o">|</span>       <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
     <span class="o">|</span>     <span class="o">}))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Expr</span><span class="o">[</span><span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> <span class="k">=</span> 
<span class="nc">Expr</span><span class="o">[</span><span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]](</span><span class="nv">$read</span><span class="o">.</span><span class="py">fixEq</span><span class="o">[</span><span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](((</span><span class="k">implicit</span> <span class="n">rec</span><span class="o">)</span> <span class="k">=&gt;</span>
 <span class="nv">Equal</span><span class="o">.</span><span class="py">equalBy</span><span class="o">[</span><span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">Tuple2</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]]</span>
 <span class="o">(((</span><span class="n">x0$1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x0$1</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nv">$read</span><span class="o">.</span><span class="py">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="nv">$read</span><span class="o">.</span><span class="py">XCons</span><span class="o">((</span><span class="n">x</span> <span class="k">@</span> <span class="k">_</span><span class="o">),</span> <span class="o">(</span><span class="n">xs</span> <span class="k">@</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nv">Some</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="nv">Tuple2</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
<span class="o">}))(</span><span class="nv">option</span><span class="o">.</span><span class="py">optionEqual</span><span class="o">(</span><span class="nv">tuple</span><span class="o">.</span><span class="py">tuple2Equal</span><span class="o">(</span><span class="nv">anyVal</span><span class="o">.</span><span class="py">intInstance</span><span class="o">,</span> <span class="n">rec</span><span class="o">))))))</span>
</code></pre></div></div>

<p>f0, a binary serialization library,
<a href="https://github.com/joshcough/f0/blob/v1.1.1/src/main/scala/f0/Readers.scala#L216-L222">uses a similar technique</a>
to help define codecs on recursive data structures.</p>

<h2 id="what-about-xlist">What about <code class="language-plaintext highlighter-rouge">XList</code>?</h2>

<p>If we can abstract out the idea of recursive value definitions, what
about recursive type definitions?  Well, thanks to higher kinds, sure!
Scalaz doesn’t provide it, but it is commonly called <code class="language-plaintext highlighter-rouge">Mu</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]])</span>
</code></pre></div></div>

<p>We have to put a class in the middle of it so that we don’t have an
infinite type; Haskell has a similar restriction.  But the principle
is the same as with <code class="language-plaintext highlighter-rouge">fix</code>: feed one datatype induction step <code class="language-plaintext highlighter-rouge">F</code> to the
higher-order type <code class="language-plaintext highlighter-rouge">Mu</code> and it will feed <code class="language-plaintext highlighter-rouge">F</code>’s result back to itself.</p>

<p>For example, here is the equivalent definition of <code class="language-plaintext highlighter-rouge">XList</code> with <code class="language-plaintext highlighter-rouge">Mu</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">α</span><span class="o">)]}</span>
<span class="k">type</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span>
</code></pre></div></div>

<p>Note the typelambda’s similarity to the second type argument to
<code class="language-plaintext highlighter-rouge">#equalBy</code> above.  And for demonstration, the isomorphism with
<code class="language-plaintext highlighter-rouge">XList</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">onetotwo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="nf">onetotwo</span><span class="o">(</span><span class="n">xs</span><span class="o">))))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">twotoone</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">xs</span><span class="o">.</span><span class="py">value</span> <span class="nf">cata</span> <span class="o">({</span><span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nf">twotoone</span><span class="o">(</span><span class="n">xs</span><span class="o">))},</span> <span class="nc">XNil</span><span class="o">())</span>
</code></pre></div></div>

<p>Of course, <code class="language-plaintext highlighter-rouge">fix</code> lends itself to both of these definitions; I have
left its use off here.  But let’s check those functions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">3</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">4</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">42</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">None</span><span class="o">)))))))))))))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">twotoone</span><span class="o">(</span><span class="n">res11</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="nc">XNil</span><span class="o">()))))</span>
</code></pre></div></div>

<h2 id="fix-over-mu"><code class="language-plaintext highlighter-rouge">fix</code> over <code class="language-plaintext highlighter-rouge">Mu</code></h2>

<p>And, finally, the associated general <code class="language-plaintext highlighter-rouge">Equal</code> definition for <code class="language-plaintext highlighter-rouge">Mu</code>.  The
<code class="language-plaintext highlighter-rouge">contramap</code> step is just noise to deal with the fact that the <code class="language-plaintext highlighter-rouge">Mu</code>
structure has to actually exist; you can ignore it for the most part.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">equalMu</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">fixEq</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]](</span><span class="n">emf</span> <span class="k">=&gt;</span> <span class="nf">fa</span><span class="o">(</span><span class="n">emf</span><span class="o">)</span> <span class="nf">contramap</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">value</span><span class="o">))</span>
</code></pre></div></div>

<p>The evidence we really want is <code class="language-plaintext highlighter-rouge">forall a. Equal[a] =&gt; Equal[F[a]]</code>,
but that’s too hard to express in Scala, so this does it in a pinch.
All we’re interested in is that we can derive <code class="language-plaintext highlighter-rouge">F</code>’s equality given the
equality of any type argument given to it.  Let’s prove that we have
such an <code class="language-plaintext highlighter-rouge">Equal</code>-lifter:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// redefined because Tuple2Equal scalaz is strict on equalIsNatural
</span><span class="k">class</span> <span class="nc">Tuple2Equal</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">](</span><span class="n">_1</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A1</span><span class="o">],</span> <span class="n">_2</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A2</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">Equal</span><span class="o">[(</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">)]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">equal</span><span class="o">(</span><span class="n">f1</span><span class="k">:</span> <span class="o">(</span><span class="kt">A1</span><span class="o">,</span> <span class="kt">A2</span><span class="o">),</span> <span class="n">f2</span><span class="k">:</span> <span class="o">(</span><span class="kt">A1</span><span class="o">,</span> <span class="kt">A2</span><span class="o">))</span> <span class="k">=</span>
    <span class="nv">_1</span><span class="o">.</span><span class="py">equal</span><span class="o">(</span><span class="nv">f1</span><span class="o">.</span><span class="py">_1</span><span class="o">,</span> <span class="nv">f2</span><span class="o">.</span><span class="py">_1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="nv">_2</span><span class="o">.</span><span class="py">equal</span><span class="o">(</span><span class="nv">f1</span><span class="o">.</span><span class="py">_2</span><span class="o">,</span> <span class="nv">f2</span><span class="o">.</span><span class="py">_2</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">equalIsNatural</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nv">_1</span><span class="o">.</span><span class="py">equalIsNatural</span> <span class="o">&amp;&amp;</span> <span class="nv">_2</span><span class="o">.</span><span class="py">equalIsNatural</span>
<span class="o">}</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nf">tup2eq</span><span class="o">[</span><span class="kt">A1:</span> <span class="kt">Equal</span>, <span class="kt">A2:</span> <span class="kt">Equal</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Tuple2Equal</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">](</span><span class="n">implicitly</span><span class="o">,</span> <span class="n">implicitly</span><span class="o">)</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Blah</span> <span class="c1">// just a placeholder
</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="o">{</span><span class="k">implicit</span> <span class="n">X</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]]]}</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">Equal</span><span class="o">[</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Blah</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>And now that we have <code class="language-plaintext highlighter-rouge">F</code> equality, we’re done, because <code class="language-plaintext highlighter-rouge">Mu</code> is <code class="language-plaintext highlighter-rouge">F</code>s
all the way down.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">equalMu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="k">implicit</span> <span class="n">fa</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">α</span><span class="o">)]]]</span> <span class="k">=</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">Equal$$anon$2</span><span class="nd">@de52bcf</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span> <span class="nf">equal</span> <span class="o">(</span><span class="nf">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">),</span> <span class="nf">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">))</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span> <span class="nf">equal</span> <span class="o">(</span><span class="nf">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">),</span> <span class="nf">onetotwo</span><span class="o">(</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="n">nums</span><span class="o">)))</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre></div></div>

<p><em>This article was tested with Scala 2.10.4 &amp; Scalaz 7.0.6.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 14 Apr 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/04/14/fix.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/04/14/fix.html</guid>
      </item>
    
      <item>
        <title>When can Liskov be lifted?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>Scalaz avoids
<a href="http://docs.scala-lang.org/tutorials/tour/variances.html">variance in the sense of the Scala type parameter annotation</a>,
with its associated higher-kind implications, except where it has
historically featured variance; even here, variance is vanishing as
<a href="https://github.com/scalaz/scalaz/pull/630">unsoundness in its released implementations is discovered</a>.</p>

<p>There is a deeply related concept in Scalaz’s typeclasses, though:
<em>covariant and contravariant
functors</em>. <a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Functor"><code class="language-plaintext highlighter-rouge">Functor</code></a>
is traditional shorthand for covariant functor, whereas
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Contravariant"><code class="language-plaintext highlighter-rouge">Contravariant</code></a>
represents contravariant functors.</p>

<p>These concepts are related, but neither subsumes the other. A
<code class="language-plaintext highlighter-rouge">Functor</code> instance does not require its parameter to be
Scala-covariant. A type can be Scala-covariant over a parameter
without having a legal <code class="language-plaintext highlighter-rouge">Functor</code> instance.</p>

<h2 id="liskov"><code class="language-plaintext highlighter-rouge">Liskov</code></h2>

<p><a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Liskov"><code class="language-plaintext highlighter-rouge">Liskov</code></a>,
also known as <code class="language-plaintext highlighter-rouge">&lt;~&lt;</code> and very close to Scala’s own
<a href="http://www.scala-lang.org/api/current/#scala.Predef$$$less$colon$less"><code class="language-plaintext highlighter-rouge">&lt;:&lt;</code></a>,
represents a subtyping relationship, and is defined by the ability to
lift it into Scala-covariant and Scala-contravariant parameter
positions, like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">liftCo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">+</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="k">def</span> <span class="nf">liftCt</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">-</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>As <code class="language-plaintext highlighter-rouge">Liskov</code> is, soundly, Scala-variant, this can be implemented
without a cast. However, it can only be called with Scala-covariant
<code class="language-plaintext highlighter-rouge">F</code>.</p>

<p>By definition, applying an <code class="language-plaintext highlighter-rouge">A &lt;~&lt; B</code> to a value of type <code class="language-plaintext highlighter-rouge">A</code> should
yield a value of type <code class="language-plaintext highlighter-rouge">B</code>, but must also do nothing but return the
value; in other words, it is an <em>operational identity</em>. Despite the
limitation of <code class="language-plaintext highlighter-rouge">liftCo</code>, for functorial values that are <em>parametrically
sound</em>, even for Scala-invariant <code class="language-plaintext highlighter-rouge">F</code>, it is operationally sound to
lift <code class="language-plaintext highlighter-rouge">Liskov</code>, though impossible to implement without exploiting Scala
soundness holes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">liftCvf</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>For example,
<a href="https://github.com/scalaz/scalaz/blob/v7.1.0-M5/core/src/main/scala/scalaz/IList.scala#L434-L437">this is sound for <code class="language-plaintext highlighter-rouge">scalaz.IList</code></a>.</p>

<h2 id="but-ilistint-isnt-a-subtype-of-ilistany">But <code class="language-plaintext highlighter-rouge">IList[Int]</code> isn’t a subtype of <code class="language-plaintext highlighter-rouge">IList[Any]</code>!</h2>

<p>Sure, as far as Scala is concerned.  But <code class="language-plaintext highlighter-rouge">Liskov</code> is all about making
claims that can’t directly be proven due to the language’s
limitations.  Haskell allows you to constrain functions with type
equalities, which is very important when working with type families;
Scala doesn’t, so we get
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Leibniz"><code class="language-plaintext highlighter-rouge">Leibniz</code></a>
instead.</p>

<p>A type is a set of values.  Where <em>Y</em> is a supertype of <em>X</em>, every
value in <em>X</em> is in <em>Y</em>.  Since <code class="language-plaintext highlighter-rouge">IList[String]("hi", "there")</code> has the
same representation as <code class="language-plaintext highlighter-rouge">IList[Any]("hi", "there")</code>, they are the same
value.  This is true for <em>all</em> <code class="language-plaintext highlighter-rouge">IList[String]</code>s, but the opposite is
not true; therefore, <code class="language-plaintext highlighter-rouge">IList[Any]</code> is an <code class="language-plaintext highlighter-rouge">IList[String]</code> supertype,
regardless of what Scala knows.</p>

<p>So doing a casting <code class="language-plaintext highlighter-rouge">Liskov</code> lift, like that into <code class="language-plaintext highlighter-rouge">IList</code>, is
essentially “admitted” in a proof system sense.  You are saying, “I
can’t prove that this subtype relationship holds, but it does, so
assume it.”</p>

<p><strong>To decide whether an admitted <code class="language-plaintext highlighter-rouge">A &lt;~&lt; B</code> is sound</strong>: suppose that the
compiler admits that subtyping relationship.  Can it then draw
incorrect conclusions, about the sets of values, derived from that
assumption?  This is the cardinal rule.</p>

<p>By extension, <strong>to decide whether an <code class="language-plaintext highlighter-rouge">F</code> permits Liskov lifting</strong>:
does the above rule pass given <code class="language-plaintext highlighter-rouge">F[A] &lt;~&lt; F[B]</code> <em>for all</em> <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code>
where <code class="language-plaintext highlighter-rouge">B</code> is a supertype of <code class="language-plaintext highlighter-rouge">A</code>?</p>

<h2 id="parametrically-sound-covariance">Parametrically sound covariance</h2>

<p>Because a <code class="language-plaintext highlighter-rouge">Liskov</code> must be an operational identity, it is essential
that, given any value of <code class="language-plaintext highlighter-rouge">F[A]</code>, for all supertypes <code class="language-plaintext highlighter-rouge">B</code> of <code class="language-plaintext highlighter-rouge">A</code>, the
representation of <code class="language-plaintext highlighter-rouge">F[B]</code> must be identical.  You can determine this by
analyzing the subclasses of <code class="language-plaintext highlighter-rouge">F</code> as an algebraic data type, where the
key test is to ensure that <code class="language-plaintext highlighter-rouge">A</code> <em>never</em> appears in the primitive
contravariant position: as the parameter to a function.  This test is
not quite enough to prove that <code class="language-plaintext highlighter-rouge">Liskov</code> lifting is sound, but it gets
us most of the way.</p>

<p>For example, an <code class="language-plaintext highlighter-rouge">IList</code> of <code class="language-plaintext highlighter-rouge">"hi"</code> and <code class="language-plaintext highlighter-rouge">"there"</code> has exactly the same
representation whether you instantiated the <code class="language-plaintext highlighter-rouge">IList</code> with <code class="language-plaintext highlighter-rouge">String</code> or
with <code class="language-plaintext highlighter-rouge">Any</code>. So that is a good first test. If a class changes its
construction behavior based on manifest type information, or its basic
data construction functions violate
<a href="http://failex.blogspot.com/2013/06/fake-theorems-for-free.html">the rules of parametricity</a>,
that is a good sign that the data type cannot follow these rules.</p>

<p>This data type analysis is recursive: a data type being variant in a
parametrically sound way over a parameter requires that all
appearances of that parameter in elements of your data type are also
parametrically sound in that way. For example, if your <code class="language-plaintext highlighter-rouge">F[A]</code> contains
an <code class="language-plaintext highlighter-rouge">IList[A]</code> in its representation, you may rely on <code class="language-plaintext highlighter-rouge">IList</code>’s
parametrically sound covariance when considering <code class="language-plaintext highlighter-rouge">F</code>’s.</p>

<p>Any <code class="language-plaintext highlighter-rouge">var</code>, or <code class="language-plaintext highlighter-rouge">var</code>-like thing such as an <code class="language-plaintext highlighter-rouge">Array</code>, places its
parameter in an invariant position, because it features a getter
(return type) and setter (parameter type). So its presence in the data
model invalidates <code class="language-plaintext highlighter-rouge">Liskov</code> lifting if the type parameter appears
within it.</p>

<p>Obviously, runtime evidence of a type parameter’s value eliminates the
possibility of lifting <code class="language-plaintext highlighter-rouge">Liskov</code> over that parameter.</p>

<p>You cannot perform this representation analysis without considering
all subclasses of a class under consideration. For example,
considering only
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.HashSet"><code class="language-plaintext highlighter-rouge">HashSet</code></a>,
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.Set"><code class="language-plaintext highlighter-rouge">collection.immutable.Set</code></a>
appears to allow <code class="language-plaintext highlighter-rouge">Liskov</code> lifting. However,
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.TreeSet"><code class="language-plaintext highlighter-rouge">TreeSet</code></a>,
a subclass of <code class="language-plaintext highlighter-rouge">Set</code>, contains a function <code class="language-plaintext highlighter-rouge">(A, A) =&gt; Ordering</code>. If
<em>any</em> representation contains a contradiction like this, <code class="language-plaintext highlighter-rouge">Liskov</code>
lifting is unsafe. You cannot constrain <code class="language-plaintext highlighter-rouge">Liskov</code> application by a
runtime test.</p>

<p>If you permit open subclassing, you must either declare the
requirement to preserve parametric covariance, or accept that it will
be violated, and so forbid <code class="language-plaintext highlighter-rouge">Liskov</code> lifting.</p>

<p>Data that doesn’t use a type parameter doesn’t affect its parametric
soundness.  For example, here <code class="language-plaintext highlighter-rouge">A</code> is invariant, but <code class="language-plaintext highlighter-rouge">B</code> is covariant:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">VA</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</code></pre></div></div>

<h2 id="gadts">GADTs</h2>

<p>Some features of Scala resist simple ADT analysis, so must be
considered separately from the above.  Despite their sound covariance
considering only the representational rules in the previous section,
they still break the cardinal rule by allowing the compiler to make
invalid assumptions about the sets of values.  A “recoverable phantom”
implies a type relationship that forbids <code class="language-plaintext highlighter-rouge">Liskov</code>-lifting, for
example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">GimmeI</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>In pattern matching, given a <code class="language-plaintext highlighter-rouge">Gimme[A]</code> over unknown <code class="language-plaintext highlighter-rouge">A</code>, matching
<code class="language-plaintext highlighter-rouge">GimmeI</code> successfully recovers the type equality <code class="language-plaintext highlighter-rouge">A ~ Int</code>; therefore,
<code class="language-plaintext highlighter-rouge">Liskov</code>-lifting is unsound for <code class="language-plaintext highlighter-rouge">Gimme</code>.  For example, lifting
<code class="language-plaintext highlighter-rouge">Int &lt;~&lt; Any</code>, applying to <code class="language-plaintext highlighter-rouge">GimmeI</code>, and matching, gives us
<code class="language-plaintext highlighter-rouge">Any ~ Int</code>, which is nonsense.</p>

<p>We can reason about this type equality as a value member of <code class="language-plaintext highlighter-rouge">GimmeI</code>
of type <code class="language-plaintext highlighter-rouge">Leibniz[⊥, ⊤, A, Int]</code>, which places <code class="language-plaintext highlighter-rouge">A</code> in a
representationally invariant position.</p>

<p>Some other GADTs invalidate covariance. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">P</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">PP</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="n">P</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>The pattern match of a <code class="language-plaintext highlighter-rouge">P[A]</code> to <code class="language-plaintext highlighter-rouge">PP[_,_]</code> can theoretically determine
<code class="language-plaintext highlighter-rouge">A ~ (x, y) forSome {type x; type y}</code>, so <code class="language-plaintext highlighter-rouge">Liskov</code> cannot be lifted
into <code class="language-plaintext highlighter-rouge">P</code>.</p>

<p>However, not all GADTs invalidate <code class="language-plaintext highlighter-rouge">Liskov</code>-lifting:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">AM</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">FAM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">AM</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AM</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>Matching <code class="language-plaintext highlighter-rouge">AM[A]</code> to <code class="language-plaintext highlighter-rouge">FAM[_,_]</code> reveals nothing about <code class="language-plaintext highlighter-rouge">A</code>; its use of
GADTs only introduces a new existential unrelated to <code class="language-plaintext highlighter-rouge">A</code>.  Considering
only <code class="language-plaintext highlighter-rouge">B</code>, as the <code class="language-plaintext highlighter-rouge">A</code> parameter is called in <code class="language-plaintext highlighter-rouge">FAM</code>, its covariance is
sound in <code class="language-plaintext highlighter-rouge">FAM</code>, so <code class="language-plaintext highlighter-rouge">Liskov</code>s can be lifted into <code class="language-plaintext highlighter-rouge">AM</code>.</p>

<h2 id="contravariance">Contravariance</h2>

<p><code class="language-plaintext highlighter-rouge">Liskov</code>s can also be lifted into parametrically sound contravariant
positions.  This looks a bit like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">liftCtf</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Contravariant</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Analysis of parametrically sound contravariance is essentially the
same as that for covariance.  The only difference is that, for <code class="language-plaintext highlighter-rouge">F[A]</code>,
<code class="language-plaintext highlighter-rouge">A</code> can <em>only</em> appear in the primitive contravariant position: the
function parameter type.</p>

<p>With regard to recursion, the “flipping” behavior of
Scala-contravariance applies.  For example, this data type is soundly
contravariant over <code class="language-plaintext highlighter-rouge">A</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">IOf</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">IList</code> is soundly covariant over <code class="language-plaintext highlighter-rouge">A</code>, and <code class="language-plaintext highlighter-rouge">IList[A]</code> appears in
soundly contravariant position, making <code class="language-plaintext highlighter-rouge">A</code> contravariant.  Meanwhile,
<code class="language-plaintext highlighter-rouge">A</code> is soundly <em>co</em>variant in this data type built upon <code class="language-plaintext highlighter-rouge">IOf</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">IOf2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">IOf</span><span class="o">[</span><span class="kt">IOf</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<h2 id="some-surprises">Some surprises</h2>

<p>Despite the unsoundness of <code class="language-plaintext highlighter-rouge">Liskov</code>-lifting into <code class="language-plaintext highlighter-rouge">Gimme</code> earlier, it
may seem surprising that Scala allows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">GimmeC</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">GimmeCI</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>Moreover, this isn’t a bug; it’s perfectly sound.  That is because,
while matching <code class="language-plaintext highlighter-rouge">GimmeI</code> causes Scala to infer <code class="language-plaintext highlighter-rouge">A ~ Int</code>, it won’t do
that for <code class="language-plaintext highlighter-rouge">GimmeCI</code>!  Scala can soundly determine that <code class="language-plaintext highlighter-rouge">A ⊇ Int</code> when
it matches <code class="language-plaintext highlighter-rouge">GimmeCI</code>, but I do not think it even goes so far as to do
that as of this writing.  We can’t blame Scala for this difference;
Scala has declared up front that its type system encodes what it
believes, and is <em>our</em> responsibility to follow the cardinal rule of
not violating its assumptions if we lift <code class="language-plaintext highlighter-rouge">Liskov</code> into <code class="language-plaintext highlighter-rouge">Gimme</code>.</p>

<p>As stated earlier, <code class="language-plaintext highlighter-rouge">Liskov</code> cannot be lifted into
<code class="language-plaintext highlighter-rouge">collection.immutable.Set</code>; <code class="language-plaintext highlighter-rouge">TreeSet</code> exists to trivially demonstrate
the problem, but even if <code class="language-plaintext highlighter-rouge">TreeSet</code> was not there, we would not be able
to honestly do it because <code class="language-plaintext highlighter-rouge">c.i.Set</code> is open to new subclasses that
could perform similar violations.  However, despite lacking a
<code class="language-plaintext highlighter-rouge">Functor</code>, <code class="language-plaintext highlighter-rouge">scalaz.ISet</code> <em>does</em> allow <code class="language-plaintext highlighter-rouge">Liskov</code>-lifting.
<a href="https://github.com/scalaz/scalaz/blob/ac8c4684ef89f1b950e71237819d78f573e552ea/core/src/main/scala/scalaz/ISet.scala#L552-L561">Do the ADT analysis yourself, if you like.</a>
Well, so, once you convert your <code class="language-plaintext highlighter-rouge">ISet[Int]</code> to <code class="language-plaintext highlighter-rouge">ISet[Any]</code>, you can’t
do many operations on it, but that’s neither here nor there.</p>

<h2 id="should-this-function-exist">Should this function exist?</h2>

<p>The Scalaz community has settled on a definition of
covariant-functoriality that conforms with the principle of parametric
soundness. The rejection of <code class="language-plaintext highlighter-rouge">Functor</code> instances
<a href="https://github.com/scalaz/scalaz/pull/307">for the <code class="language-plaintext highlighter-rouge">scala.collection.*</code> classes</a>,
which have subclasses with mutable values over their parameters, and
<a href="https://github.com/scalaz/scalaz/pull/276">for <code class="language-plaintext highlighter-rouge">collection.immutable.Set</code></a>,
which has the <code class="language-plaintext highlighter-rouge">TreeSet</code> case stated above and violates parametricity
in the construction of <code class="language-plaintext highlighter-rouge">HashSet</code>s, speak to this. As far as I know,
Scalaz contains no <code class="language-plaintext highlighter-rouge">Functor</code>s that are both Scala-invariant and
violate the rules delineated above.</p>

<p>So how do you feel about the provision of a combinator of the type of
<code class="language-plaintext highlighter-rouge">liftCvf</code> for Scalaz’s <code class="language-plaintext highlighter-rouge">Functor</code>?</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 09 Mar 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/03/09/liskov_lifting.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/03/09/liskov_lifting.html</guid>
      </item>
    
      <item>
        <title>How do I error handle thee?</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>Scala has several ways to deal with error handling, and often times people
get confused as to when to use what. This post hopes to address that.</p>

<p><em>Let me count the ways.</em></p>

<h2 id="option"><code class="language-plaintext highlighter-rouge">Option</code></h2>

<p>People coming to Scala from Java-like languages are often told <code class="language-plaintext highlighter-rouge">Option</code> is
a replacement for <code class="language-plaintext highlighter-rouge">null</code> or exception throwing. Say we have a function that
creates some sort of interval, but only allows intervals where the lower bound
comes first.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Interval</span><span class="o">(</span><span class="k">val</span> <span class="nv">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="nv">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Lower bound must be smaller than upper bound!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here we want to create an <code class="language-plaintext highlighter-rouge">Interval</code>, but we want to ensure that the lower bound
is smaller than the upper bound. If it isn’t, we throw an exception. The idea here
is to have some sort of “guarantee” that if at any point I’m given an <code class="language-plaintext highlighter-rouge">Interval</code>,
the lower bound is smaller than the upper bound (otherwise an exception would have
been thrown).</p>

<p>However, throwing exceptions breaks our ability to reason about a function/program.
Control is handed off to the call site, and we hope the call site catches it – if not,
it propagates further up until at some point something catches it, or our program
crashes. We’d like something a bit cleaner than that.</p>

<p>Enter <code class="language-plaintext highlighter-rouge">Option</code> – given our <code class="language-plaintext highlighter-rouge">Interval</code> constructor, construction may or may not succeed.
Put another way, after we enter the constructor, we may or may not have a valid
<code class="language-plaintext highlighter-rouge">Interval</code>. <code class="language-plaintext highlighter-rouge">Option</code> is a type that represents a value that may or may not be there;
it can either be <code class="language-plaintext highlighter-rouge">Some</code> or <code class="language-plaintext highlighter-rouge">None</code>. Let’s use what’s called a <em>smart constructor</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">Interval</span> <span class="nf">private</span><span class="o">(</span><span class="k">val</span> <span class="nv">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="nv">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Interval</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Interval</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="k">new</span> <span class="nc">Interval</span><span class="o">(</span><span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">))</span>
    <span class="k">else</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We make our class <code class="language-plaintext highlighter-rouge">final</code> so nothing can inherit from it, and we make our constructor
private so nobody can create an instance of <code class="language-plaintext highlighter-rouge">Interval</code> without going through our own
smart constructor function, <code class="language-plaintext highlighter-rouge">Interval.apply</code>. Our <code class="language-plaintext highlighter-rouge">apply</code> function takes some relevant
parameters, and returns an <code class="language-plaintext highlighter-rouge">Option[Interval]</code> that may or may not contain our constructed
<code class="language-plaintext highlighter-rouge">Interval</code>. Our function does not arbitrarily kick control back to the call site due
to an exception and we can reason about it much more easily.</p>

<h2 id="either-and-scalaz"><code class="language-plaintext highlighter-rouge">Either</code> and <code class="language-plaintext highlighter-rouge">scalaz.\/</code></h2>

<p>So, <code class="language-plaintext highlighter-rouge">Option</code> gives us <code class="language-plaintext highlighter-rouge">Some</code> or <code class="language-plaintext highlighter-rouge">None</code>, which is all we need if there is only one thing
that could go wrong. For instance, the standard library’s <code class="language-plaintext highlighter-rouge">Map[K, V]</code> has a function <code class="language-plaintext highlighter-rouge">get</code>
that given a key of type <code class="language-plaintext highlighter-rouge">K</code>, returns <code class="language-plaintext highlighter-rouge">Option[V]</code> – clearly if the key exists, the associated
value is returned (wrapped in a <code class="language-plaintext highlighter-rouge">Some</code>). If the key does not exist, it returns a <code class="language-plaintext highlighter-rouge">None</code>.</p>

<p>But sometimes one of several things can go wrong. Let’s say we have some wonky type that
wants a string that is exactly of length 5 and another string that is a palindrome.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="nf">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Wonky</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">five</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="nv">palindrome</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="nv">w</span> <span class="k">=</span> <span class="nv">Wonky</span><span class="o">.</span><span class="py">validate</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="c1">// say this returns None
</span></code></pre></div></div>

<p>Clearly something went wrong here, but we don’t know what. If the strings were sent over
from some front end via JSON or something, when we send an error back hopefully we have
something more descriptive than “Something went wrong.” What we want is instead of <code class="language-plaintext highlighter-rouge">None</code>,
we want something more descriptive. We can look into <code class="language-plaintext highlighter-rouge">Either</code> for this, where we use
<code class="language-plaintext highlighter-rouge">Left</code> to hold some sort of error value (similar to <code class="language-plaintext highlighter-rouge">None</code>), and <code class="language-plaintext highlighter-rouge">Right</code> to hold a successful
one (similar to <code class="language-plaintext highlighter-rouge">Some</code>).</p>

<p>To manipulate such values that may or may not exist (presumably obtained from functions that may or may not
fail), we use monadic functions such as <code class="language-plaintext highlighter-rouge">flatMap</code>, often in the form of monad comprehensions, or
for comprehensions as Scala calls them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="nv">y</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="nf">foo</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="nf">bar</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="n">c</span> <span class="k">&lt;-</span> <span class="nf">baz</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
  <span class="n">d</span> <span class="k">&lt;-</span> <span class="nf">quux</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">d</span>
</code></pre></div></div>

<p>In the case of <code class="language-plaintext highlighter-rouge">Option</code>, if any of <code class="language-plaintext highlighter-rouge">foo/bar/baz/quux</code> returns a <code class="language-plaintext highlighter-rouge">None</code>, that <code class="language-plaintext highlighter-rouge">None</code> simply
gets threaded through the rest of the computation – no <code class="language-plaintext highlighter-rouge">try/catch</code> statements marching off
the right side of the screen!</p>

<p>For comprehensions in Scala require the type we’re working with to have <code class="language-plaintext highlighter-rouge">flatMap</code> and
<code class="language-plaintext highlighter-rouge">map</code>. <code class="language-plaintext highlighter-rouge">flatMap</code>, along with <code class="language-plaintext highlighter-rouge">pure</code> and some laws, are the requisite functions needed
to form a monad – <code class="language-plaintext highlighter-rouge">map</code> can be defined in terms of <code class="language-plaintext highlighter-rouge">flatMap</code> and <code class="language-plaintext highlighter-rouge">pure</code>.
With <code class="language-plaintext highlighter-rouge">scala.util.Either</code> however, we don’t have those – we have
to use an explicit conversion via <code class="language-plaintext highlighter-rouge">Either#right</code> or <code class="language-plaintext highlighter-rouge">Either#left</code> to get a
<code class="language-plaintext highlighter-rouge">RightProjection</code> or <code class="language-plaintext highlighter-rouge">LeftProjection</code> (respectively), which specifies in what direction we bias
the <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code> calls. The convention however, is that the right side is the “correct”
(or “right”, if you will) side and the left represents the failure case, but it is tedious to
continously call <code class="language-plaintext highlighter-rouge">Either#right</code> on values of type <code class="language-plaintext highlighter-rouge">Either</code> to achieve this.</p>

<p>Thankfully, we have an alternative in the Scalaz library via
<code class="language-plaintext highlighter-rouge">scalaz.\/</code> (I just pronounce this “either” – some say disjoint union or just “or”), a right-biased
version of <code class="language-plaintext highlighter-rouge">scala.util.Either</code> – that is, calling <code class="language-plaintext highlighter-rouge">\/#map</code> maps over the value if it’s in
a “right” (<code class="language-plaintext highlighter-rouge">scalaz.\/-</code>), otherwise if it’s “left” (<code class="language-plaintext highlighter-rouge">scalaz.-\/</code>) it just threads it through
without touching it, much like how <code class="language-plaintext highlighter-rouge">Option</code> behaves. We can therefore alter the earlier function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="nf">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">WonkyError</span> <span class="kt">\/</span> <span class="kt">Wonky</span> <span class="o">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">five</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">))</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="nv">palindrome</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">\/-(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="nv">w</span> <span class="k">=</span> <span class="nv">Wonky</span><span class="o">.</span><span class="py">validate</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">scalaz.\/</code> also has several useful methods not found on <code class="language-plaintext highlighter-rouge">Either</code>.</p>

<h2 id="try"><code class="language-plaintext highlighter-rouge">Try</code></h2>

<p>As of Scala 2.10, we have <code class="language-plaintext highlighter-rouge">scala.util.Try</code> which is essentially an either, with the left type
fixed as <code class="language-plaintext highlighter-rouge">Throwable</code>. There are two problems (that I can think of at this moment) with this:</p>

<ol>
  <li>We want to avoid exceptions where we can.</li>
  <li>It violates the monad laws.</li>
</ol>

<p>A big factor in our ability to deal with all these error handling types nicely
is using their monadic properties in for comprehensions.</p>

<p>For an explanation of the monad laws, there is a nice post
<a href="http://eed3si9n.com/learning-scalaz/Monad+laws.html">here</a> describing them (using Scala). <code class="language-plaintext highlighter-rouge">Try</code>
violates the left identity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"oops"</span><span class="o">)</span>

<span class="nf">foo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// exception is thrown
</span>
<span class="nc">Try</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">foo</span><span class="o">)</span> <span class="c1">// scala.util.Failure
</span></code></pre></div></div>

<p>This can cause unexpected behavior when used, perhaps in a monad/for comprehension. Furthermore,
<code class="language-plaintext highlighter-rouge">Try</code> encourages the use of <code class="language-plaintext highlighter-rouge">Throwable</code>s which breaks control flow and parametricity.
While it certainly may be convenient to be able to wrap an arbitrarily code block with the <code class="language-plaintext highlighter-rouge">Try</code> constructor
and let it catch any exception that may be thrown, we still recommend using an algebraic data type
describing the errors and using <code class="language-plaintext highlighter-rouge">YourErrorType \/ YourReturnType</code>.</p>

<h2 id="scalazvalidation"><code class="language-plaintext highlighter-rouge">scalaz.Validation</code></h2>

<p>Going back to our previous example with validating wonky strings, we see an improvement that
could be made.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="nf">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">WonkyError</span> <span class="kt">\/</span> <span class="kt">Wonky</span> <span class="o">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">five</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">))</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="nv">palindrome</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">\/-(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="nv">w</span> <span class="k">=</span> <span class="nv">Wonky</span><span class="o">.</span><span class="py">validate</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span> <span class="c1">// -\/(MustHaveLengthFive("foo"))
</span></code></pre></div></div>

<p>The fact that one string must have a length of 5 can be checked and reported separately from the other 
being palindromic. Note that in the above example <code class="language-plaintext highlighter-rouge">"foo"</code> does not satisfy the length requirement,
and <code class="language-plaintext highlighter-rouge">"bar"</code> does not satisfy the palindromic requirement, yet only <code class="language-plaintext highlighter-rouge">"foo"</code>’s error is reported
due to how <code class="language-plaintext highlighter-rouge">\/</code> works. What if we want to report any and all errors that could be reported
(“foo” does not have a length of 5 and “bar” is not palindromic)?</p>

<p>If we want to validate several properties at once, and return any and all validation errors,
we can turn to <code class="language-plaintext highlighter-rouge">scalaz.Validation</code>. The modified function would look something like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="nf">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">checkFive</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nv">five</span><span class="o">.</span><span class="py">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">).</span><span class="py">failNel</span>
    <span class="k">else</span> <span class="nv">five</span><span class="o">.</span><span class="py">success</span>

  <span class="k">def</span> <span class="nf">checkPalindrome</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nv">p</span><span class="o">.</span><span class="py">reverse</span><span class="o">)</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="py">failNel</span>
    <span class="k">else</span> <span class="nv">p</span><span class="o">.</span><span class="py">success</span>

  <span class="k">def</span> <span class="nf">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">Wonky</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="nf">checkFive</span><span class="o">(</span><span class="n">five</span><span class="o">)</span> <span class="o">|@|</span> <span class="nf">checkPalindrome</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span> <span class="o">{</span> <span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="c1">// Failure(NonEmptyList(MustHaveLengthFive("foo"), MustBePalindromic("bar")))
</span><span class="nv">Wonky</span><span class="o">.</span><span class="py">validate</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>

<span class="c1">// Failure(NonEmptyList(MustBePalindromic("bar")))
</span><span class="nv">Wonky</span><span class="o">.</span><span class="py">validate</span><span class="o">(</span><span class="s">"monad"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>

<span class="c1">// Success(Wonky("monad", "radar"))
</span><span class="nv">Wonky</span><span class="o">.</span><span class="py">validate</span><span class="o">(</span><span class="s">"monad"</span><span class="o">,</span> <span class="s">"radar"</span><span class="o">)</span>
</code></pre></div></div>

<p>Awesome! However, there is one caveat – we cannot in good conscience use
<code class="language-plaintext highlighter-rouge">scalaz.Validation</code> in a for comprehension. Why? Because there is no valid
monad for it. <code class="language-plaintext highlighter-rouge">Validation</code>’s accumulative nature works via its <code class="language-plaintext highlighter-rouge">Applicative</code>
instance, but due to how the instance works, there is no consistent monad
(every monad is an applicative functor, where monadic bind is consistent with
applicative apply). However, you can use the <code class="language-plaintext highlighter-rouge">Validation#disjunction</code> function to
convert it to a <code class="language-plaintext highlighter-rouge">scalaz.\/</code>, which can then be used in a for comprehension.</p>

<p>One more thing to note: in the above code snippet I used
<code class="language-plaintext highlighter-rouge">ValidationNel</code>, which is just a type alias.
<code class="language-plaintext highlighter-rouge">ValidationNel[E, A]</code> stands for for 
<code class="language-plaintext highlighter-rouge">Validation[NonEmptyList[E], A]</code> – the actual <code class="language-plaintext highlighter-rouge">Validation</code> will take
anything on the left side that is a <code class="language-plaintext highlighter-rouge">Semigroup</code>, and <code class="language-plaintext highlighter-rouge">ValidationNel</code> is
provided as a convenience as often times you may want a non-empty
list of errors describing the various errors that happened in a function.
However, you can do several interesting things with other semigroups.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 21 Feb 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/02/21/error-handling.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/02/21/error-handling.html</guid>
      </item>
    
      <item>
        <title>When implicitly isn't specific enough</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>When working with implicit-encoded dependent function types, such as
<code class="language-plaintext highlighter-rouge">scalaz.Unapply</code> and numerous Shapeless operations, you’d frequently
like to acquire instances of those functions to see what types get
calculated for them.</p>

<p>For example, <code class="language-plaintext highlighter-rouge">++</code> on Shapeless <code class="language-plaintext highlighter-rouge">HList</code>s is driven by <code class="language-plaintext highlighter-rouge">Prepend</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">++</span><span class="o">[</span><span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">suffix</span> <span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prepend</span> <span class="k">:</span> <span class="kt">Prepend</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">S</span><span class="o">])</span>
  <span class="k">:</span> <span class="kt">prepend.Out</span> <span class="o">=</span> <span class="nf">prepend</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span>
</code></pre></div></div>

<p>So given some <code class="language-plaintext highlighter-rouge">HList</code>s, we can expect to be able to combine them in a
couple ways.  First, by using the syntax function above, and then by
acquiring a value of <code class="language-plaintext highlighter-rouge">prepend</code>’s type directly and invoking it, just
as in the body of the above function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span><span class="o">,</span> <span class="nv">ops</span><span class="o">.</span><span class="py">hlist</span><span class="o">.</span><span class="py">_</span>
<span class="k">import</span> <span class="nn">scalaz._</span><span class="o">,</span> <span class="nv">std</span><span class="o">.</span><span class="py">string</span><span class="o">.</span><span class="py">_</span><span class="o">,</span> <span class="nv">std</span><span class="o">.</span><span class="py">tuple</span><span class="o">.</span><span class="py">_</span><span class="o">,</span> <span class="nv">syntax</span><span class="o">.</span><span class="py">applicative</span><span class="o">.</span><span class="py">_</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">ohi</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="s">"hi"</span> <span class="o">::</span> <span class="nc">HNil</span>
<span class="n">ohi</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]</span><span class="err">]</span>
        <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohi</span> <span class="o">++</span> <span class="n">ohi</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span><span class="err">]</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">ohipohi</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
  <span class="k">=</span> <span class="nv">shapeless</span><span class="o">.</span><span class="py">ops</span><span class="o">.</span><span class="py">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mi">13399</span><span class="n">e98</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">ohipohi</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">ohipohi.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Back over in Scalaz, for purposes of an <code class="language-plaintext highlighter-rouge">Applicative</code> instance,
<code class="language-plaintext highlighter-rouge">(String, Int)</code> selects its second type parameter.  Just as the
<code class="language-plaintext highlighter-rouge">To*OpsUnapply</code> functions acquire <code class="language-plaintext highlighter-rouge">Unapply</code> instances to do their
work:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">ToApplicativeOpsUnapply</span><span class="o">[</span><span class="kt">FA</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">FA</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F0</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">FA</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">ApplicativeOps</span><span class="o">[</span><span class="kt">F0.M</span>,<span class="kt">F0.A</span><span class="o">](</span><span class="nf">F0</span><span class="o">(</span><span class="n">v</span><span class="o">))(</span><span class="nv">F0</span><span class="o">.</span><span class="py">TC</span><span class="o">)</span>
</code></pre></div></div>

<p>We can acquire an instance and use it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">t2ap</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]]</span>
<span class="n">t2ap</span><span class="k">:</span> <span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Applicative</span>,<span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span>
<span class="nv">scalaz</span><span class="o">.</span><span class="py">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">18214797</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">t2ap</span><span class="o">.</span><span class="py">TC</span><span class="o">.</span><span class="py">point</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="s">""</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="the-mysterious-result">The mysterious result</h2>

<p>Now let’s get that first element out of that tuple we got by calling
<code class="language-plaintext highlighter-rouge">point</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">res5</span><span class="o">.</span><span class="py">_1</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">31</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="k">_</span><span class="err">1</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
              <span class="nv">res5</span><span class="o">.</span><span class="py">_1</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>Uh, huh?  Let’s try adding the <code class="language-plaintext highlighter-rouge">HList</code>s we got from <code class="language-plaintext highlighter-rouge">ohipohi</code> before.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cala</span><span class="o">&gt;</span> <span class="n">res3</span> <span class="o">++</span> <span class="n">res3</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">32</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
              <span class="n">prepend</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span><span class="kt">ohipohi.Out</span>,<span class="kt">ohipohi.Out</span><span class="o">]</span>
              <span class="n">res3</span> <span class="o">++</span> <span class="n">res3</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>The clue is in the type report in the above: path-dependent type
members of <code class="language-plaintext highlighter-rouge">t2ap</code> and <code class="language-plaintext highlighter-rouge">ohipohi</code> appear.  That wouldn’t be a problem,
normally, as we know what they are, but <strong>they’re existential</strong> to
Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">30</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">=:=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Int</span><span class="o">).</span>
              <span class="n">implicitly</span><span class="o">[</span><span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
                        <span class="o">^</span>
</code></pre></div></div>

<h2 id="implicitly-only-gives-what-you-ask-for"><code class="language-plaintext highlighter-rouge">implicitly</code> only gives what you ask for</h2>

<p>The explanation lies with the <code class="language-plaintext highlighter-rouge">implicitly</code> calls we made to acquire
the specific dependent functions we wanted to use.  Let’s look at the
definition of <code class="language-plaintext highlighter-rouge">implicitly</code> and see if it can enlighten:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">implicitly</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</code></pre></div></div>

<p>In other words, <code class="language-plaintext highlighter-rouge">implicitly</code> returns exactly what you asked for,
type-wise.  Recall the inferred type of <code class="language-plaintext highlighter-rouge">ohipohi</code> when it was defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ohipohi</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
</code></pre></div></div>

<p>Not coincidentally, <em>this is the exact type we gave as a type
parameter to <code class="language-plaintext highlighter-rouge">implicitly</code></em>.  What’s important is that <code class="language-plaintext highlighter-rouge">Out</code>, the type
member of <code class="language-plaintext highlighter-rouge">Prepend</code> that determines its result type, is existential in
both cases.</p>

<p>In other words, the rule of <code class="language-plaintext highlighter-rouge">implicitly</code> is “you asked for it, you got
it”.</p>

<h2 id="a-more-specific-implicitly">A more specific <code class="language-plaintext highlighter-rouge">implicitly</code></h2>

<p>The answer here is to simulate the weird way in which dependent method
types, like <code class="language-plaintext highlighter-rouge">++</code> and <code class="language-plaintext highlighter-rouge">ToApplicativeOpsUnapply</code>, can pass through extra
type information about their implicit parameters that would otherwise
be lost.  We do this by reinventing <code class="language-plaintext highlighter-rouge">implicitly</code>.</p>

<p>The first try is obvious: follow the comment in the <code class="language-plaintext highlighter-rouge">Predef.scala</code>
source and give <code class="language-plaintext highlighter-rouge">implicitly</code> a singleton type result.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">implicitly2</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="kt">with</span> <span class="kt">e.</span><span class="k">type</span> <span class="o">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">ohipohi2</span> <span class="k">=</span> <span class="n">implicitly2</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi2</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
     <span class="k">with</span> <span class="nv">e</span><span class="o">.</span><span class="py">type</span> <span class="k">=</span> <span class="nv">shapeless</span><span class="o">.</span><span class="py">ops</span><span class="o">.</span><span class="py">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mi">4</span><span class="n">abe65da</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">ohipohi2</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">ohipohi2.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res9</span> <span class="o">++</span> <span class="n">res9</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">33</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
              <span class="n">prepend</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span><span class="kt">ohipohi2.Out</span>,<span class="kt">ohipohi2.Out</span><span class="o">]</span>
              <span class="n">res9</span> <span class="o">++</span> <span class="n">res9</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>Not quite good enough.</p>

<h2 id="an-even-more-albeit-less-specific-implicitly">An even more, albeit less, specific <code class="language-plaintext highlighter-rouge">implicitly</code></h2>

<p>I think it’s strange that the above doesn’t work, but we can deal with
it by being a little more specific.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">implicitlyDepFn</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">DepFn2</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">T</span> <span class="o">{</span><span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="kt">e.Out</span><span class="o">}</span> <span class="k">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">ohipohi3</span> <span class="k">=</span> <span class="n">implicitlyDepFn</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi3</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]{</span>
                <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">shapeless</span><span class="o">.::[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
                            <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]]</span>
          <span class="o">}</span> <span class="k">=</span> <span class="nv">shapeless</span><span class="o">.</span><span class="py">ops</span><span class="o">.</span><span class="py">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mf">7306572f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">ohipohi3</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">ohipohi3.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res11</span> <span class="o">++</span> <span class="n">res11</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
       <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
       <span class="kt">shapeless.HNil</span><span class="o">]]]]]]]</span><span class="err">]</span>
   <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Now that’s more like it.  The trick is in the return type of
<code class="language-plaintext highlighter-rouge">implicitlyDepFn</code>, which includes the structural refinement <code class="language-plaintext highlighter-rouge">{type Out
= e.Out}</code>.</p>

<p>Again, it’s weird that this structural refinement isn’t subsumed by
the return type <code class="language-plaintext highlighter-rouge">e.type</code> from <code class="language-plaintext highlighter-rouge">implicitly2</code>’s definition, but I’m not
sure it’s wrong, either, given the ephemeral nature of type stability.</p>

<p>Thankfully, most of the evidence for dependent function types in
Shapeless extends from the <code class="language-plaintext highlighter-rouge">DepFn*</code> traits, so you only need one of
these special <code class="language-plaintext highlighter-rouge">implicitly</code> variants for each, rather than one for each
individual dependent function type you wish to acquire instances of in
this way.</p>

<h2 id="and-likewise-with-unapply">And likewise with <code class="language-plaintext highlighter-rouge">Unapply</code></h2>

<p>We can similarly acquire instances of <code class="language-plaintext highlighter-rouge">scalaz.Unapply</code> conveniently.
I believe this function will be supplied with Scalaz 7.0.6, and it is
<a href="https://github.com/scalaz/scalaz/pull/621">already included in the 7.1 development branch</a>,
so you will be able to write <code class="language-plaintext highlighter-rouge">Unapply[TC, type]</code> to get instances as
with plain typeclass lookup in Scalaz, but it’s easy enough to define
yourself.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">unap</span><span class="o">[</span><span class="kt">TC</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">MA</span><span class="o">](</span><span class="k">implicit</span> <span class="n">U</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">TC</span>, <span class="kt">MA</span><span class="o">])</span><span class="k">:</span> <span class="kt">U.</span><span class="k">type</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=</span> <span class="nv">U</span><span class="o">.</span><span class="py">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">U</span><span class="o">.</span><span class="py">A</span>
<span class="o">}</span> <span class="k">=</span> <span class="n">U</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">t2ap2</span> <span class="k">=</span> <span class="n">unap</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
<span class="n">t2ap2</span><span class="k">:</span> <span class="kt">U.</span><span class="k">type</span><span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="n">A</span><span class="o">);</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">Int</span><span class="o">}</span> 
  <span class="k">=</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">3</span><span class="n">adb9933</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">t2ap2</span><span class="o">.</span><span class="py">TC</span><span class="o">.</span><span class="py">point</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">""</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">res13</span><span class="o">.</span><span class="py">_1</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
</code></pre></div></div>

<p><em>This article was tested with Scala 2.10.3, Scalaz 7.0.5, and
Shapeless 2.0.0-M1.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 18 Jan 2014 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2014/01/18/implicitly_existential.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/01/18/implicitly_existential.html</guid>
      </item>
    
      <item>
        <title>Towards Scalaz (Part 2)</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>A lot of people see Scalaz as a hard fringe, ivory tower,
not suited for real-world applications library, which is
unfortunate. The goal of this blog post series is to introduce
various components of Scalaz, and hopefully through this
allow folks to gain an understanding towards the power of
Scalaz.</p>

<p>As a prerequisite, I assume knowledge of type classes as they
are implemented and used in Scala, higher kinded types,
and sum types (e.g. <code class="language-plaintext highlighter-rouge">Option/Some/None</code>, <code class="language-plaintext highlighter-rouge">Either/Left/Right</code>).</p>

<p>For a tutorial/review on (higher) kinds, I recommend the following resources:</p>

<ul>
  <li><a href="http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">Scala: Types of a higher kind</a></li>
  <li><a href="http://adriaanm.github.io/files/higher.pdf">Generics of a Higher Kind</a></li>
  <li><a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala">SO: What is a higher kinded type in Scala?</a></li>
</ul>

<h2 id="part-2-summations-of-a-higher-kind">Part 2: Summations of a Higher Kind</h2>

<p><a href="/blog/2013/10/13/towards-scalaz-1.html">Last time</a> we left off after
writing our own generic <code class="language-plaintext highlighter-rouge">sum</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Monoid</span>

<span class="k">def</span> <span class="nf">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">l</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">zero</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">A</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>This allowed us to sum a list not only of numeric types like
<code class="language-plaintext highlighter-rouge">Int</code>, but also others that could be added and had a “zero” such as
<code class="language-plaintext highlighter-rouge">String</code> via string concatenation and the empty string, as well as
<code class="language-plaintext highlighter-rouge">List[A]</code> via list concatenation and the empty list.</p>

<p>But, we can do better! Why limit ourselves to <code class="language-plaintext highlighter-rouge">List</code>? What if we want
to sum over a <code class="language-plaintext highlighter-rouge">Vector</code>, or even a tree? We <em>could</em> use <code class="language-plaintext highlighter-rouge">Seq</code> and that
would allow us to pass in <code class="language-plaintext highlighter-rouge">List</code> or <code class="language-plaintext highlighter-rouge">Vector</code>, but it still brings up
the problem of trees, and any other data structure that may not fit
the <code class="language-plaintext highlighter-rouge">Seq</code> bill.</p>

<h3 id="what-do-we-want-folds">What do we want? Folds!</h3>
<p>Recall when we “came up with” <code class="language-plaintext highlighter-rouge">Semigroup</code> and <code class="language-plaintext highlighter-rouge">Monoid</code> last time -
what did we do? We simply looked at what operations we needed
(<code class="language-plaintext highlighter-rouge">add/append</code> and <code class="language-plaintext highlighter-rouge">zero</code>) and factored it out into a type class.
Let’s try doing the same this time.</p>

<p>So what are we doing with <code class="language-plaintext highlighter-rouge">List</code> in our implementation? Nothing much
really, we’re just folding over it. If we think about it, we could
“fold” over say, a tree as well. Let’s take this operation out into
a type class, and aptly name it <code class="language-plaintext highlighter-rouge">Foldable</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// Instead of requiring the contents to be monoidal, let's
</span>  <span class="c1">// make it flexible by allowing a fold as long as we can convert
</span>  <span class="c1">// the contents to a type that has a `Monoid`.
</span>  <span class="k">def</span> <span class="nf">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And let’s implement instances of this type class for <code class="language-plaintext highlighter-rouge">List</code> and our own
<code class="language-plaintext highlighter-rouge">Tree</code>.</p>

<p>Our tree definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>and our instances:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Foldable</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">listIsFoldable</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
        <span class="nv">fa</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nv">B</span><span class="o">.</span><span class="py">zero</span><span class="o">)((</span><span class="n">acc</span><span class="o">,</span> <span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">B</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="nf">f</span><span class="o">(</span><span class="n">elem</span><span class="o">)))</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">treeIsFoldable</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
        <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Leaf</span><span class="o">()</span> <span class="k">=&gt;</span>
            <span class="nv">B</span><span class="o">.</span><span class="py">zero</span>
          <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nv">B</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="nf">f</span><span class="o">(</span><span class="n">value</span><span class="o">),</span> <span class="nv">B</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="nf">foldMap</span><span class="o">(</span><span class="n">left</span><span class="o">)(</span><span class="n">f</span><span class="o">),</span> <span class="nf">foldMap</span><span class="o">(</span><span class="n">right</span><span class="o">)(</span><span class="n">f</span><span class="o">)))</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>and finally, our new summing function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumGeneric</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">fa</span><span class="o">.</span><span class="py">foldMap</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="scalaz-to-the-rescue">Scalaz to the rescue</h3>
<p>As with last time, Scalaz defines the <code class="language-plaintext highlighter-rouge">Foldable</code> type class for us. However,
to really be “foldable”, not only should you define <code class="language-plaintext highlighter-rouge">foldMap</code>, but <code class="language-plaintext highlighter-rouge">foldRight</code>
as well. Some of you may be wondering why <code class="language-plaintext highlighter-rouge">foldRight</code> and not <code class="language-plaintext highlighter-rouge">foldLeft</code>, or both?
The reasons for this decision are that</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">foldLeft</code> can be defined in terms of <code class="language-plaintext highlighter-rouge">foldRight</code> (a fun exercise is to try this for yourself)</li>
  <li><code class="language-plaintext highlighter-rouge">foldLeft</code> fails on infinite lists (think <code class="language-plaintext highlighter-rouge">Stream</code> in Scala)</li>
</ul>

<p>That being said, Scalaz defines instances of <code class="language-plaintext highlighter-rouge">Foldable</code> for many of the standard
Scala types (<code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Vector</code>, <code class="language-plaintext highlighter-rouge">Stream</code>, <code class="language-plaintext highlighter-rouge">Option</code>), as well as its own (<code class="language-plaintext highlighter-rouge">Tree</code>, <code class="language-plaintext highlighter-rouge">EphemeralStream</code>).
The methods available on the type class not only include <code class="language-plaintext highlighter-rouge">foldMap</code> and <code class="language-plaintext highlighter-rouge">foldRight</code> which
are required to be implemented, but several derived ones as well including <code class="language-plaintext highlighter-rouge">fold</code> (<code class="language-plaintext highlighter-rouge">foldMap</code> with
<code class="language-plaintext highlighter-rouge">identity</code>), <code class="language-plaintext highlighter-rouge">foldLeft</code>, <code class="language-plaintext highlighter-rouge">toList/IndexedSeq/Stream</code>, among others.</p>

<p>So our code with <code class="language-plaintext highlighter-rouge">scalaz.Foldable</code> now looks like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.</span><span class="o">{</span> <span class="nc">Foldable</span><span class="o">,</span> <span class="nc">Monoid</span> <span class="o">}</span>

<span class="c1">// Note that this is equivalent to scalaz.Foldable#fold
</span><span class="k">def</span> <span class="nf">sumGeneric</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">fa</span><span class="o">.</span><span class="py">fold</span>
</code></pre></div></div>

<p>Note that the implementation of the function is rather plain, but that’s a good thing!
This shows the level of genericity type classes, folds,  and Scalaz is capable of. If you ever
find yourself needing to fold something down, look at the methods available on
<code class="language-plaintext highlighter-rouge">scalaz.Foldable</code>. By simply adding an instance of <code class="language-plaintext highlighter-rouge">Foldable</code> to your <code class="language-plaintext highlighter-rouge">F[_]</code> by implementing
the two methods above, you get “for free” a bunch of
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Foldable">derived ones</a>!</p>

<h3 id="an-aside-taming-the-elephant">An Aside: Taming the Elephant</h3>
<p>In recent days, the word “Hadoop” has become synonymous with “big data.” The MapReduce
system made popular by <a href="http://research.google.com/archive/mapreduce.html">Google</a>
has made it’s way into several companies looking to glean information from their data.</p>

<p>Why am I mentioning this in a typelevel.scala blog post? Well, think about the reduce phase –
what is really happening? For a particular key, we’re given a list of values emitted
for that key, and we want to reduce those values into a single value. Sound familiar?
Sounds a bit like <code class="language-plaintext highlighter-rouge">fold</code>, doesn’t it? Note that not all reductions in MapReduce have to follow
monoid laws, but a surprising amount do as demonstrated by Twitter’s
<a href="https://github.com/twitter/algebird">Algebird</a> project.</p>

<p>Going back to <code class="language-plaintext highlighter-rouge">fold</code>, recall that in order to just <code class="language-plaintext highlighter-rouge">fold</code> we need to have something
<code class="language-plaintext highlighter-rouge">Foldable</code> that contains something that already has a <code class="language-plaintext highlighter-rouge">Monoid</code> instance. A more general
approach, as taken by <code class="language-plaintext highlighter-rouge">scalaz.Foldable</code>, is to also provide a <code class="language-plaintext highlighter-rouge">foldMap</code> function which
lets us also pass in a function <em>map</em>ping each element of the <code class="language-plaintext highlighter-rouge">Foldable</code> to something
that is a <code class="language-plaintext highlighter-rouge">Monoid</code>, and reduce over that instead.</p>

<p>So. Given something, say a <code class="language-plaintext highlighter-rouge">List[A]</code>, we want to <em>Map</em> each element of the list to
an element of a type that has a <code class="language-plaintext highlighter-rouge">Monoid</code> instance, and then we want to <em>Reduce</em> the
list down to a single value. What is this? All together now: MapReduce!</p>

<p>Unfortunately, Hadoop MapReduce by itself does not give you anything like a <code class="language-plaintext highlighter-rouge">List</code>.
Fortunately, our good friends at <a href="http://www.nicta.com.au/">NICTA</a> have developed
and open sourced the wonderful <a href="https://github.com/nicta/scoobi">Scoobi</a> project,
which abstracts over Hadoop MapReduce by providing a <code class="language-plaintext highlighter-rouge">List</code>-like interface, called a
<code class="language-plaintext highlighter-rouge">DList</code> (distributed list). Users treat the <code class="language-plaintext highlighter-rouge">DList</code> very similarly to how they would
a regular Scala <code class="language-plaintext highlighter-rouge">List</code>, and perform operations on it that get compiled down into
MapReduce jobs. Such operations include not only the familiar (and expected) <code class="language-plaintext highlighter-rouge">map</code>
and <code class="language-plaintext highlighter-rouge">reduce</code> combinators, but also our friends <code class="language-plaintext highlighter-rouge">foldMap</code> and <code class="language-plaintext highlighter-rouge">fold</code>. While <code class="language-plaintext highlighter-rouge">DList</code>’s
do not have a proper <code class="language-plaintext highlighter-rouge">Foldable</code> instance due to the difficulty of implementing <code class="language-plaintext highlighter-rouge">foldRight</code>
for the MapReduce, I find it to be a great example of the power of abstractions and
genericity abstract algebra and Scalaz provides to us as programmers.</p>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><a href="http://tmorris.net/posts/list-folds-bfpg/index.html">List Folds at BFPG</a></li>
  <li><a href="http://www.cs.nott.ac.uk/~gmh/fold.pdf">A tutorial on the universality and expressiveness of folds</a></li>
</ul>

<h2 id="getting-help">Getting Help</h2>

<p>If you have any questions/comments/concerns, feel free to hop onto the IRC channel on
Freenode at <code class="language-plaintext highlighter-rouge">#scalaz</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 15 Dec 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/12/15/towards-scalaz-2.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/12/15/towards-scalaz-2.html</guid>
      </item>
    
      <item>
        <title>Law Enforcement using Discipline</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>Some nine or ten months ago, <a href="http://github.com/non/spire">Spire</a>’s project structure underwent a major reorganization.
Simultaneously, the <a href="http://www.scalacheck.org/">Scalacheck</a> bindings were refactored, completely overhauling the law-checking infrastructure.</p>

<h2 id="requirements">Requirements</h2>

<p>The main goal was to make it easy to check that instances of Spire’s type classes adhere to the set of algebraic laws of the respective type classes.
<a href="https://github.com/scalaz/scalaz">Scalaz</a> also has such an infrastructure, so why not take that one?
The problem is that in Spire, the hierarchy of type classes is a little bit more complex:</p>

<p>On the one hand, there is a “generic” tower of type classes including <code class="language-plaintext highlighter-rouge">Semigroup</code>, <code class="language-plaintext highlighter-rouge">Monoid</code> and the like, where each successive type extends its predecessor.
On the other hand, this tower is replicated <em>twice</em> for their “additive” and “multiplicative” counterparts.
These classes are isomorphic, up to the semantics, and hence naming of their operations.</p>

<p>This distinction is quite useful, because now one can write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Semiring</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">MultiplicativeSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// ...
</span><span class="o">}</span>
</code></pre></div></div>

<p>without clashes between the additive and multiplicative binary operations.
Also, a semiring can now be quite naturally treated as an additive monoid and a multiplicative semigroup (but not as a generic semigroup, which would be ambiguous).
(One could consider this the <em>third</em> hierarchy of algebraic type classes in spire.)</p>

<p>When checking laws, we do not want to repeat the same laws over and over again.
Hence, we need some way to express that certain type classes share laws with others which are not necessarily in the same type hierarchy.</p>

<h2 id="interface">Interface</h2>

<p>The implementation fundamentally depends on Scalacheck.
To be more specific, it uses <code class="language-plaintext highlighter-rouge">Prop</code> as the elementary unit of testing.</p>

<p>Now, a set of named <code class="language-plaintext highlighter-rouge">Prop</code>s do not quite suffice as the “law” of a type class.
First, to avoid ambiguous naming, let us call the complete law of a type class (including dependencies), a “rule set”.</p>

<p>To satisfy our requirement of having dependencies from (potentially) different hierarchies, we will distinguish <em>parents</em> and <em>bases</em>.
A <em>parent</em> is a rule set of a type class in the same hierachy, whereas a <em>base</em> can come from everywhere.
This distinction is expressed with the use of path-dependent types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Laws</span> <span class="o">{</span>

  <span class="k">trait</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">name</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="nf">bases</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Laws</span><span class="k">#</span><span class="kt">RuleSet</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
    <span class="k">def</span> <span class="nf">parents</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">RuleSet</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
    <span class="k">def</span> <span class="nf">props</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Prop</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>

    <span class="c1">// ...
</span>  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>As we can see, <code class="language-plaintext highlighter-rouge">parents</code> uses type <code class="language-plaintext highlighter-rouge">RuleSet</code>, which constrains parents to the same outer <code class="language-plaintext highlighter-rouge">Laws</code> instance.
In contrast, <code class="language-plaintext highlighter-rouge">bases</code> uses the type <code class="language-plaintext highlighter-rouge">Laws#RuleSet</code> which means that bases can come from other instances of <code class="language-plaintext highlighter-rouge">Laws</code>.</p>

<p>When you define type classes, the general idea is to define one instance of <code class="language-plaintext highlighter-rouge">Laws</code> for each <em>hierarchy</em> of type classes.
Coming back to the Spire example, that could look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">GroupLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">semigroup</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"semigroup"</span>
    <span class="k">def</span> <span class="nf">props</span> <span class="k">=</span> <span class="c1">// ...
</span>  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">monoid</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"monoid"</span>
    <span class="k">def</span> <span class="nf">parents</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">semigroup</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">props</span> <span class="k">=</span> <span class="c1">// ...
</span>  <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">AdditiveLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">groupLaws</span><span class="k">:</span> <span class="kt">GroupLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">semigroup</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AdditiveSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"additive semigroup"</span>

    <span class="c1">// `.additive` converts an additive X to a generic X
</span>    <span class="k">def</span> <span class="nf">bases</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"additive"</span> <span class="o">→</span> <span class="nv">groupLaws</span><span class="o">.</span><span class="py">semigroup</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">additive</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="nf">monoid</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">name</span> <span class="k">=</span> <span class="s">"additive monoid"</span>

    <span class="k">def</span> <span class="nf">bases</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"additive"</span> <span class="o">→</span> <span class="nv">groupLaws</span><span class="o">.</span><span class="py">monoid</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">additive</span><span class="o">))</span>
    <span class="k">def</span> <span class="nf">parent</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">semigroup</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This now clearly expresses the intention:</p>

<ul>
  <li>A monoid is a semigroup.</li>
  <li>An additive semigroup should satisfy the laws of a semigroup.</li>
  <li>An additive monoid is an additive semigroup and should satisfy the laws of a monoid.</li>
</ul>

<p>Note that in the definitions inside <code class="language-plaintext highlighter-rouge">AdditiveLaws</code>, no properties have been restated.
The system will automatically take care that all the properties of the parents and the bases are being checked.</p>

<p>Obviously, this is not very interesting yet, because so far it could have been achieved by other means.
If you are interested in more complex examples, check the sources of Spire:
There are a couple of examples where the additive and multiplicative versions have extra checks which are not covered by the generic version.</p>

<h2 id="implementation">Implementation</h2>

<p>Now, the question is how to compute the set of all properties which need to be checked.
A naïve algorithm would just recursively traverse all bases and parents, and check the union of all the property sets.</p>

<p>However, this leads to unnecessary work.
Consider the rule set of an additive monoid.
There, the properties of semigroup would be included twice:
once via the semigroup base of the additive semigroup parent, and once via the semigroup parent of the monoid base.</p>

<p>While checking properties twice certainly does no damage, we still do not want to pay for that overhead.
Hence, a slightly smarter algorithm is used.
We compute the set of all properties of a certain class by taking the union of these sets:</p>

<ul>
  <li>the properties of the class itself</li>
  <li>recursively, the properties of all its parents (ignoring their bases)</li>
  <li>recursively, the set of all properties of its bases</li>
</ul>

<p>In order to present the user a more transparent output, the names of the properties are hierarchical.
When a base is pulled in as dependency, their properties are additionally prefixed with the name of the base.
This should make it very easy to see where exactly a property came from.</p>

<p>There is a slight complication, though.
Recall the definition of a semiring in spire, which is given above.
A semiring actually consists of two different semigroups of which we must check the laws separately.
At this point, it is not immediately clear what would happen with the presented algorithm.
With just a minor clarification it turns out that this is not actually a problem:
The rule set of a semiring specifies two bases (one for the additive component and one for the multiplicative component), and we only need to make sure that they have different names.
Laws pulled in via different bases are considered different, and are hence not conflated.</p>

<h2 id="usage">Usage</h2>

<p>Previously, this new law checking infrastructure was tailored to be used just in Spire.
Since it is useful outside of Spire, too, it has recently been generalized and pulled out into a separate project: <a href="https://github.com/typelevel/discipline">Discipline</a>.</p>

<p>In there, you can find a stripped-down example of the Spire use case.</p>

<p>Furthermore, there is integration with Specs2 and ScalaTest.
You just have to extend the <code class="language-plaintext highlighter-rouge">specs2.Discipline</code> (or <code class="language-plaintext highlighter-rouge">scalatest.Discipline</code>, respectively) trait, and write</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">checkAll</span><span class="o">(</span><span class="s">"Int"</span><span class="o">,</span> <span class="nc">RingLaws</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="py">ring</span> <span class="cm">/* put your own `RuleSet` here */</span><span class="o">)</span>
</code></pre></div></div>

<p>and rule sets are expanded and turned into individual tests automatically.
For a Specs2-based tests, this will result in the following output (similar for ScalaTest):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] ring laws must hold for Int
[info]
[info]  + ring.additive:group.base:group.associative
[info]  + ring.additive:group.base:group.identity
[info]  + ring.additive:group.base:group.inverse
[info]  + ring.multiplicative:monoid.base:monoid.associative
[info]  + ring.multiplicative:monoid.base:monoid.identity
[info]  + ring.distributive
</code></pre></div></div>

<p>Observe that the associativity law for semigroups shows up twice (additive and multiplicative), but not four times (as would have happened with the naïve algorithm).</p>

<p>In the future, we will investigate whether Scalaz can also be migrated towards Discipline, for a more unified approach to law checking.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 17 Nov 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/11/17/discipline.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/11/17/discipline.html</guid>
      </item>
    
      <item>
        <title>Treelog</title>
        
          <dc:creator>channingwalton</dc:creator>
                
        <description><![CDATA[<p><a href="https://twitter.com/lancewalton">Lance Walton’s</a> <a href="https://github.com/lancewalton/treelog">Treelog</a> is the result of a real problem that arose in a trading system that we were working on:</p>
<blockquote>
  <p>How can everything that happens to a trade be audited?</p>
</blockquote>

<p>The first (and tedious) answer is copius logging by writing to some kind of audit data type or simple logger.</p>

<p>There are a number of problems with this approach:</p>

<ul>
  <li>writing logging around computations often complicates the code as values must be extracted, recorded and then applied</li>
  <li>separating logic from the computation can lead to a mismatch between the log and the computation</li>
  <li>linear logs are very difficult to follow</li>
  <li>its not easy to control how much of a linear log to show a user if you do not know what is detail and what isn’t</li>
</ul>

<p>Treelog resolves these issues by making the log itself a tree, reflecting the computational tree it logs, and uses techniques described in the <a href="http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf">Typeclassopedia</a> to bring logging closer to the computation: the <code class="language-plaintext highlighter-rouge">Writer</code> Monad, a Monad Transformer, and a cunning Monoid.</p>

<p>Note that this post is a more technical description of how Treelog was written. For a quick introduction of use please refer to the [README].
I will also refer you to Eugene Yokota’s <a href="http://eed3si9n.com/learning-scalaz/">excellent Scalaz tutorial</a> to study the details of Scalaz where appropriate.</p>

<h2 id="logging-with-treelog">Logging with Treelog</h2>
<p>Here is an example which illustrates how Treelog is used (<a href="https://github.com/lancewalton/treelog#treelog-examples">more examples</a>):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">simple</span><span class="k">:</span> <span class="kt">DescribedComputation</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="s">"Calculating sum"</span> <span class="o">~&lt;</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">x</span> <span class="k">←</span> <span class="mi">11</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="s">"x = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">y</span> <span class="k">←</span> <span class="mi">2</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="s">"y = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">sum</span> <span class="k">←</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="s">"Sum is "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">sum</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DescribedComputation[Value]</code> is just a type alias for <code class="language-plaintext highlighter-rouge">EitherT[LogTreeWriter, String, Value]</code>. <code class="language-plaintext highlighter-rouge">EitherT</code>, a <a href="http://eed3si9n.com/learning-scalaz/Monad+transformers.html">Monad Transformer</a>, enables success and failure to be represented and will be covered below.</p>

<p>The log and value can be retrieved with <code class="language-plaintext highlighter-rouge">result.run.written</code> and <code class="language-plaintext highlighter-rouge">result.run.value</code> respectively. The written tree will look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Calculating sum
  x = 11
  y = 2
  Sum is 13
</code></pre></div></div>

<p>and the value will be <code class="language-plaintext highlighter-rouge">\/-(13)</code>, which is Scalaz’s version of <code class="language-plaintext highlighter-rouge">Right</code>.</p>

<h2 id="tree-nodes">Tree Nodes</h2>

<p>The nodes of the tree contain a <code class="language-plaintext highlighter-rouge">LogTreeLabel</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">success</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="nf">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="c1">// ...
</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">DescribedLogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">description</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">success</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">LogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">UndescribedLogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">success</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">LogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>The node is able to represent success or failure, may have a description, and a set of annotations. Annotations allow extra information to be carried in a Node which may be useful when working with the audit later. For our trading system that was other trades that were affected by the process as a side effect of processing a trade.</p>

<p>Treelog distinguishes between tree nodes that describe a computation, a <code class="language-plaintext highlighter-rouge">DescribedLogTreeLabel</code>, and an <code class="language-plaintext highlighter-rouge">UndescribedLogTreeLabel</code> which is a Tree with no description in the root. In the example above, the root node is a <code class="language-plaintext highlighter-rouge">DescribedLogTreeLabel</code> containing the text <code class="language-plaintext highlighter-rouge">Calculating sum</code>. This is an important distinction that informs the way trees must be combined by our Treelog monoid, which the <code class="language-plaintext highlighter-rouge">Writer</code> needs (see below).</p>

<p>Note that originally, <code class="language-plaintext highlighter-rouge">LogTreeLabel</code> was a case class defined like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">LogTreeLabel</span><span class="o">(</span><span class="n">description</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">success</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Annotation</span><span class="o">])</span>
</code></pre></div></div>

<p>This meant that <code class="language-plaintext highlighter-rouge">DescribedLogTreeLabel</code> and <code class="language-plaintext highlighter-rouge">UndescribedLogTreeLabel</code> were not necessary because the optional <code class="language-plaintext highlighter-rouge">description</code> carried the equivalent information. However, we found the formulation above easier to work with.</p>

<h2 id="syntactic-sugar">Syntactic Sugar</h2>

<p>Treelog makes use of some syntactic sugar inspired by <a href="http://blog.tmorris.net/posts/the-writer-monad-using-scala-example/">Tony Morris’s post</a> on <code class="language-plaintext highlighter-rouge">Writer</code>. In the example above, <code class="language-plaintext highlighter-rouge">~&gt;</code> is a method on an implicitly constructed class which takes any value <code class="language-plaintext highlighter-rouge">x: T</code> and returns a <code class="language-plaintext highlighter-rouge">DescribedComputation[T]</code>, representing the value <code class="language-plaintext highlighter-rouge">x</code> and a leaf node containing the description.</p>

<p>There is special support for <code class="language-plaintext highlighter-rouge">Boolean</code>s, <code class="language-plaintext highlighter-rouge">Option</code>s, <code class="language-plaintext highlighter-rouge">Either</code>s and <code class="language-plaintext highlighter-rouge">Traversable</code>s which you can learn about from the Treelog [README].</p>

<h2 id="writer-and-monoid"><code class="language-plaintext highlighter-rouge">Writer</code> and Monoid</h2>

<blockquote>
  <p>Writer allows us to do computations while making sure that all the log values are combined into one log value that then gets attached to the result. – <a href="http://learnyouahaskell.com/for-a-few-monads-more">LYAH</a></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">Writer</code>s allow us to write a log embedded within a computation.</p>

<p>Here is a simple example using Scalaz, see the references for more detailed examples.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">r</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">←</span> <span class="mf">3.</span><span class="nf">set</span><span class="o">(</span><span class="s">"Got a 3."</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">←</span> <span class="mf">5.</span><span class="nf">set</span><span class="o">(</span><span class="s">"Got a 5."</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">r</span><span class="o">.</span><span class="py">written</span><span class="o">)</span> <span class="c1">// Got a 3.Got a 5.
</span><span class="nf">println</span><span class="o">(</span><span class="nv">r</span><span class="o">.</span><span class="py">value</span><span class="o">)</span> <span class="c1">// 15
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Writer</code> uses a monoid for the written value (a <code class="language-plaintext highlighter-rouge">String</code> in this case) to combine the logs (concatenation for <code class="language-plaintext highlighter-rouge">String</code>s). For <code class="language-plaintext highlighter-rouge">List</code>s it is <code class="language-plaintext highlighter-rouge">:::</code> and <code class="language-plaintext highlighter-rouge">Nil</code>, etc.</p>

<h2 id="treelogs-monoid">Treelog’s Monoid</h2>

<p>Treelog uses a Scalaz <a href="http://eed3si9n.com/learning-scalaz/Writer.html">Writer</a>, <a href="http://eed3si9n.com/learning-scalaz/Tree.html">Tree</a> and a custom <a href="http://eed3si9n.com/learning-scalaz/Monoid.html">Monoid</a> implementation to record logs.</p>

<p>The monoid has to provide two things: a <code class="language-plaintext highlighter-rouge">zero</code> value, and a binary operation that combines two trees in a meaningful way. The <code class="language-plaintext highlighter-rouge">zero</code> value for Treelog is just a constant used internally to the `Monoid´ implementation and never leaks out since there is always at least one value being logged.</p>

<p>Combining trees is done as follows:</p>

<ul>
  <li>a <code class="language-plaintext highlighter-rouge">zero</code> tree with a tree is just the tree</li>
  <li>two undescribed trees become a new undescribed tree with the children of the right tree appended to the children of the left tree</li>
  <li>an undescribed tree <code class="language-plaintext highlighter-rouge">T1</code>, and a described tree, <code class="language-plaintext highlighter-rouge">T2</code>, becomes an undescribed tree with <em><code class="language-plaintext highlighter-rouge">T2</code> appended to the children of <code class="language-plaintext highlighter-rouge">T1</code></em></li>
  <li>a described tree, <code class="language-plaintext highlighter-rouge">T1</code>, and an undescribed tree, <code class="language-plaintext highlighter-rouge">T2</code>, is an undescribed tree with <em><code class="language-plaintext highlighter-rouge">T1</code> prepended to the children of <code class="language-plaintext highlighter-rouge">T2</code></em></li>
  <li>two described trees are combined by creating an undescribed tree with the two trees as children</li>
</ul>

<p>Note that the result is always an undescribed tree since there is no meaningful way to combine descriptions of child nodes. In the example above the tree contains two leaves: “Got a 3” and “Got a 5”. Concatenating those descriptions isn’t as meaningful as “Summing a and b”, which could be done like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">r</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="s">"Summing a and b"</span> <span class="o">~&lt;</span> <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">←</span> <span class="mf">3.</span><span class="nf">set</span><span class="o">(</span><span class="s">"Got a 3."</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">←</span> <span class="mf">5.</span><span class="nf">set</span><span class="o">(</span><span class="s">"Got a 5."</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</code></pre></div></div>

<p>The <a href="https://github.com/lancewalton/treelog/blob/5e36e0652b575d0102f45b1c284f68a02f148b04/src/test/scala/QuadraticRootsExample.scala">quadratic roots</a> example is a good one to see this.</p>

<h2 id="success-and-failure--eithert">Success and Failure – <code class="language-plaintext highlighter-rouge">EitherT</code></h2>

<p>The purpose of Treelog is to audit a computation, return the log and result, and indicate whether the computation was successful or not. The Writer with the Monoid described above satisfies the first two requirements, but not the third. To add success and failure, the writer needs to be combined with <code class="language-plaintext highlighter-rouge">Either</code>. What we need is a Monad Transformer.</p>

<blockquote>
  <p>Monad Transformers are special types that allow us to roll two monads into a single one that shares the behaviour of both. – <a href="http://en.wikibooks.org/wiki/Haskell/Monad_transformers">Haskell Wikibook</a></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">EitherT</code> is a monad transformer that combines some monad with <code class="language-plaintext highlighter-rouge">Either</code>, which is exactly what is needed. It is constructed with three types: <code class="language-plaintext highlighter-rouge">EitherT[M, A, B]</code> where <code class="language-plaintext highlighter-rouge">M</code> is the monad, <code class="language-plaintext highlighter-rouge">A</code> is the failure type and <code class="language-plaintext highlighter-rouge">B</code> is the success type. In Treelog, <code class="language-plaintext highlighter-rouge">M</code> is a <code class="language-plaintext highlighter-rouge">Writer</code>, <code class="language-plaintext highlighter-rouge">A</code> is a <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">B</code> is the type of the result.</p>

<p>Logtree includes the methods <code class="language-plaintext highlighter-rouge">def failure[V](description: String): DescribedComputation[V]</code> and <code class="language-plaintext highlighter-rouge">def success[V](value: V, description: String): DescribedComputation[V]</code> to support failure and success. They ensure that the failure case is included in the tree and that the nodes in the tree now reflect that the computation has failed.</p>

<p>Here is an example from Treelog:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">foo</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">11.</span><span class="n">right</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">val</span> <span class="nv">bar</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">Int</span> <span class="o">=</span> <span class="s">"fubar"</span><span class="o">.</span><span class="py">left</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">leftEithers</span><span class="k">:</span> <span class="kt">DescribedComputation</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="s">"Calculating left either sum"</span> <span class="o">~&lt;</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">x</span> <span class="k">←</span> <span class="n">foo</span> <span class="o">~&gt;?</span> <span class="o">(</span><span class="s">"x = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">y</span> <span class="k">←</span> <span class="n">bar</span> <span class="o">~&gt;?</span> <span class="o">(</span><span class="s">"y = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">sum</span> <span class="k">←</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="n">v</span> <span class="k">⇒</span> <span class="s">"Sum is "</span> <span class="o">+</span> <span class="n">v</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">sum</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="nv">leftEitherWriter</span><span class="k">:</span> <span class="kt">LogTreeWriter</span><span class="o">[</span><span class="kt">String</span> <span class="kt">\/</span> <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">leftEithers</span><span class="o">.</span><span class="py">run</span>
<span class="nf">println</span><span class="o">(</span><span class="nv">leftEithers</span><span class="o">.</span><span class="py">run</span><span class="o">.</span><span class="py">written</span><span class="o">.</span><span class="py">shows</span><span class="o">)</span>
</code></pre></div></div>

<p>To retrieve the underying value back from <code class="language-plaintext highlighter-rouge">EitherT</code>, we call <code class="language-plaintext highlighter-rouge">run</code> which returns the <code class="language-plaintext highlighter-rouge">Writer</code> containing Scalaz’s version of <code class="language-plaintext highlighter-rouge">Either</code> (which is more useful than Scala’s built-in <code class="language-plaintext highlighter-rouge">Either</code>).</p>

<p>The written value is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Failed: Calculating left either sum
  x = 11
  Failed: fubar

Failure: Calculating left either sum
</code></pre></div></div>

<p>So the written log indicates that the whole computation failed, and the result is <code class="language-plaintext highlighter-rouge">-\/</code>, the <code class="language-plaintext highlighter-rouge">Left</code> for a Scalaz <code class="language-plaintext highlighter-rouge">Either</code>, containing “Failure: Calculating left either sum”.</p>

<h2 id="in-practice">In Practice</h2>

<p>Treelog is being used in earnest in a trading system, and the results have been a resounding success. And the level of accurate detail the system is able to show users has been invaluable in reducing support questions, which is always welcome.</p>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><a href="http://debasishg.blogspot.co.uk/2011/07/monad-transformers-in-scala.html">Monad Transformers in Scala</a></li>
  <li><a href="http://www.slideshare.net/StackMob/monad-transformers-in-the-wild">Monad Transformers in the Wild</a></li>
</ul>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 18 Oct 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/10/18/treelog.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/10/18/treelog.html</guid>
      </item>
    
      <item>
        <title>Towards Scalaz (Part 1)</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>A lot of people see Scalaz as a hard fringe, ivory tower,
not suited for real-world applications library, which is
unfortunate. The goal of this blog post series is to introduce
various components of Scalaz, and hopefully through this
allow folks to gain an understanding towards the power of
Scalaz.</p>

<p>As a prerequisite, I assume knowledge of type classes as they
are implemented and used in Scala.</p>

<h2 id="part-1-learning-to-add">Part 1: Learning to Add</h2>

<p>Our motivation for the inaugural post of the series will be
summing a <code class="language-plaintext highlighter-rouge">List</code> of something. Lets start out with <code class="language-plaintext highlighter-rouge">Int</code>,
which is simple enough.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">l</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>And this works (kind of, it fails on empty <code class="language-plaintext highlighter-rouge">List</code>s but we’ll get to that).
But what if we want to sum a <code class="language-plaintext highlighter-rouge">List[Double]</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumDoubles</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nv">l</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>The code is the same, modulo the type parameter. In fact, the
code would be the same whether it is <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Double</code>, or <code class="language-plaintext highlighter-rouge">BigInt</code>.
Being the good programmers that we are, let’s make this generic
in that respect with the help of <code class="language-plaintext highlighter-rouge">scala.math.Numeric</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumNumeric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">l</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">plus</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="problem">Problem</h3>
<p>Awesome. We can now sum <code class="language-plaintext highlighter-rouge">List[Int]</code>, <code class="language-plaintext highlighter-rouge">List[Double]</code>, <code class="language-plaintext highlighter-rouge">List[BigInt]</code>,
and many more.</p>

<p>But let’s give this a bit more thought - what if we wanted to
“sum” a <code class="language-plaintext highlighter-rouge">List[String]</code> - that is, we concatenate all the <code class="language-plaintext highlighter-rouge">String</code>s
together to create one large <code class="language-plaintext highlighter-rouge">String</code> ?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumStrings</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nv">l</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>This looks exactly like summing <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Double</code>s! This however
does not work with our <code class="language-plaintext highlighter-rouge">sumNumeric</code> - there is no (sane) way to define
a <code class="language-plaintext highlighter-rouge">Numeric[String]</code>.</p>

<p>Another way to look at this is that we only use the <code class="language-plaintext highlighter-rouge">plus</code> method
on <code class="language-plaintext highlighter-rouge">Numeric</code>, never any of the other methods that also make sense
for numeric types. So while our function works for summing a List
of numeric types, it does not work for anything else that is not
numeric but can still be “added” (<code class="language-plaintext highlighter-rouge">String</code> and string concatenation,
<code class="language-plaintext highlighter-rouge">List[A]</code> and <code class="language-plaintext highlighter-rouge">List#++</code>).</p>

<h3 id="making-it-generic">Making it generic</h3>
<p>So what do we want? We want a type class that only requires instances
to be able to “add” two <code class="language-plaintext highlighter-rouge">A</code>s to get another <code class="language-plaintext highlighter-rouge">A</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And let’s define an instance of <code class="language-plaintext highlighter-rouge">Addable</code> for all <code class="language-plaintext highlighter-rouge">Numeric</code> types and <code class="language-plaintext highlighter-rouge">String</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Addable</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">numericIsAddable</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">A</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">stringIsAddable</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And here’s our shiny new generic summer function!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">l</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">plus</span><span class="o">)</span>
</code></pre></div></div>

<p>And now this works for <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Double</code>, <code class="language-plaintext highlighter-rouge">String</code>, and many more.</p>

<p>A good exercise at this point is to define an <code class="language-plaintext highlighter-rouge">Addable</code> instance for <code class="language-plaintext highlighter-rouge">List[A]</code>.</p>

<h3 id="making-an-exception">Making an Exception</h3>
<p>What happens when we pass in an empty <code class="language-plaintext highlighter-rouge">List</code> to our summer function though?
We get an exception! How do we prevent this? A common answer I get is
“Oh I know it won’t happen” – this is not ideal, we want to guarantee safety
as much as possible without having to rely on human judgement.</p>

<p>How then do we write a safer summer function? Lets turn to an alternative
way of implementing sum on <code class="language-plaintext highlighter-rouge">List[Int]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old, bad version
</span><span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">l</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>

<span class="c1">// Shiny, new version
</span><span class="k">def</span> <span class="nf">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">l</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>What happens now when we pass an empty <code class="language-plaintext highlighter-rouge">List</code> into the sum function? We get 0,
not an exception! Note that before all we gave the program was a binary
operation (what <code class="language-plaintext highlighter-rouge">Addable</code> defines), where now we give a binary option <em>and</em> a
“zero” or starting value (the 0). As it stands, we cannot write this with
<code class="language-plaintext highlighter-rouge">Addable</code> since it has no “zero”.</p>

<p>It may be tempting to just add a <code class="language-plaintext highlighter-rouge">zero</code> method to <code class="language-plaintext highlighter-rouge">Addable</code>, but then we may run
into the same issues we had with <code class="language-plaintext highlighter-rouge">Numeric</code> later on – we don’t <em>always</em> need
a “zero”, sometimes a binary operation is good enough. So instead, let’s create
an <code class="language-plaintext highlighter-rouge">AddableWithZero</code> type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that while you dont see the <code class="language-plaintext highlighter-rouge">plus</code> method in here, the fact
it <code class="language-plaintext highlighter-rouge">extends Addable</code> without implementing the <code class="language-plaintext highlighter-rouge">plus</code> method propagates the need to
implement that method, so programmers who want to create an <code class="language-plaintext highlighter-rouge">AddableWithZero[A]</code> instance
need to implement both.</p>

<p>Programmers can now write functions that depend only on <code class="language-plaintext highlighter-rouge">Addable</code>, or perhaps if they
need a bit more power use <code class="language-plaintext highlighter-rouge">AddableWithZero</code>. Types that have <code class="language-plaintext highlighter-rouge">AddableWithZero</code> instances
also have <code class="language-plaintext highlighter-rouge">Addable</code> instances automatically due to subtyping.</p>

<p>Lets move our <code class="language-plaintext highlighter-rouge">Addable</code> instances to the <code class="language-plaintext highlighter-rouge">AddableWithZero</code> object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">AddableWithZero</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">numericIsAddableZero</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">A</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
      <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">A</span><span class="o">.</span><span class="py">zero</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">stringIsAddableZero</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="k">def</span> <span class="nf">zero</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And finally, our shiny new generic sum function!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">l</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">zero</span><span class="o">)(</span><span class="nv">A</span><span class="o">.</span><span class="py">plus</span><span class="o">)</span>
</code></pre></div></div>

<p>Hurrah!</p>

<h3 id="plot-twist">Plot Twist</h3>
<p>It turns out that our <code class="language-plaintext highlighter-rouge">Addable</code> and <code class="language-plaintext highlighter-rouge">AddableWithZero</code> type classes is not just us being
sly and clever, but an actual thing! They are called <code class="language-plaintext highlighter-rouge">Semigroup</code> and
<code class="language-plaintext highlighter-rouge">Monoid</code> (respectively), taken from the wonderful field of abstract algebra. Abstract
algebra is a field dedicated to studying algebraic structures as opposed
to just numbers as we may be used to. The field looks into what properties
and operations various structures have in common, such as integers and
matrices. For instance, we can add two integers, as well as two matrices of the same size.
This is analogous to how we noticed the <code class="language-plaintext highlighter-rouge">plus</code> worked on not only <code class="language-plaintext highlighter-rouge">Numeric</code>
but <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">List[A]</code> as well! This is the kind of generecity we’re looking for.</p>

<p>Here’s what <code class="language-plaintext highlighter-rouge">sumGeneric</code> looks like in Scalaz land.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Monoid</span>

<span class="k">def</span> <span class="nf">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">l</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="nv">A</span><span class="o">.</span><span class="py">zero</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">A</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>Thankfully we dont have to create our own versions of <code class="language-plaintext highlighter-rouge">Semigroup</code> and <code class="language-plaintext highlighter-rouge">Monoid</code> –
Scalaz has one for us! In fact, the developers of Scalaz have been kind enough to define
several <code class="language-plaintext highlighter-rouge">Monoid</code> instances for common types such as <code class="language-plaintext highlighter-rouge">Numeric</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">List[A]</code>, etc.
There are also instances for tuples – if we have a tuple, say of type <code class="language-plaintext highlighter-rouge">(A, B, C)</code>,
and all three types have <code class="language-plaintext highlighter-rouge">Monoid</code> instances themselves, then the whole tuple has an
instance where the <code class="language-plaintext highlighter-rouge">zero</code> is the tuple <code class="language-plaintext highlighter-rouge">(A.zero, B.zero, C.zero)</code> and the <code class="language-plaintext highlighter-rouge">plus</code> is
appending corresponding pairs between the two tuples. Look for instances that may already
be defined before defining your own on existing types.</p>

<div class="side-note">
  If you are interested in learning more about numeric programming, check out
  the <a href="https://github.com/non/spire">spire</a> library, as well as the
  accompanying post about <a href="/blog/2013/07/07/generic-numeric-programming.html">
  generic numeric programming</a>.
</div>

<h3 id="law-abiding-citizen">Law-Abiding Citizen</h3>
<p>To close this post off, I confess one thing: defining a <code class="language-plaintext highlighter-rouge">Monoid</code> (and <code class="language-plaintext highlighter-rouge">Semigroup</code>) instance
should not be done without some thought. It is not enough that you simply have a zero and
a binary operation – to truly have a <code class="language-plaintext highlighter-rouge">Monoid</code> or <code class="language-plaintext highlighter-rouge">Semigroup</code> certain laws must be obeyed.
These laws are as follows:</p>

<p>Call the <code class="language-plaintext highlighter-rouge">plus</code> operation $+$ and the <code class="language-plaintext highlighter-rouge">zero</code> value $0$. Arbitrary values of type <code class="language-plaintext highlighter-rouge">A</code> will be
referred to as $a$, $b$, etc.</p>

<p>The <code class="language-plaintext highlighter-rouge">Semigroup</code> law requires $+$ to be associative. That is:</p>

<div style="text-align:center;">
	$(a + b) + c = a + (b + c)$
</div>

<p>In addition to the <code class="language-plaintext highlighter-rouge">Semigroup</code> law for the binary operation, the <code class="language-plaintext highlighter-rouge">Monoid</code> law relates
$+$ and $0$:</p>

<div style="text-align:center;">
  $(a + 0) = (0 + a) = a$
</div>

<p>To check these laws, Scalaz provides <a href="https://github.com/scalaz/scalaz/tree/v7.0.4/scalacheck-binding">ScalaCheck</a>
bindings to help you, but that is a topic for another day.</p>

<p>Note that a particular type can have several <code class="language-plaintext highlighter-rouge">Semigroup</code> or <code class="language-plaintext highlighter-rouge">Monoid</code>s that make sense.
For instance, <code class="language-plaintext highlighter-rouge">Int</code> has a <code class="language-plaintext highlighter-rouge">Monoid</code> on $(+, 0)$ as well as on $(*, 1)$. Convince yourself
(using the above laws) that this makes sense.</p>

<p>This raises the question of how we get both $+$ and $*$ <code class="language-plaintext highlighter-rouge">Monoid</code>s for <code class="language-plaintext highlighter-rouge">Int</code> without
making <code class="language-plaintext highlighter-rouge">scalac</code> freak out about ambiguous implicit values. The answer is “tagged types”,
again a topic for another day.</p>

<h2 id="getting-help">Getting Help</h2>

<p>If you have any questions/comments/concerns, feel free to hop onto the IRC channel on
Freenode at <code class="language-plaintext highlighter-rouge">#scalaz</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/10/13/towards-scalaz-1.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/10/13/towards-scalaz-1.html</guid>
      </item>
    
      <item>
        <title>How to use Spire's Ops macros in your own project</title>
        
          <dc:creator>non</dc:creator>
                
        <description><![CDATA[<h2 id="what-are-spires-ops-macros">What are Spire’s Ops macros?</h2>

<p>Spire’s type classes abstract over very basic operators like <code class="language-plaintext highlighter-rouge">+</code> and
<code class="language-plaintext highlighter-rouge">*</code>.  These operations are normally very fast. This means that any
extra work that happens on a per-operation basis (like boxing or
object allocation) will cause generic code to be slower than its
direct equivalent.</p>

<p>Efficient, generic numeric programming is Spire’s raison d’être. We
have developed a set of Ops macros to avoid unnecessary object
instantiations at compile-time. This post explains how, and
illustrates how you can use these macros in your code!</p>

<h2 id="how-implicit-operators-on-type-classes-usually-work">How implicit operators on type classes usually work</h2>

<p>When using type classes in Scala, we rely on implicit conversions to
“add” operators to an otherwise generic type.</p>

<p>In this example, <code class="language-plaintext highlighter-rouge">A</code> is the generic type, <code class="language-plaintext highlighter-rouge">Ordering</code> is the type
class, and <code class="language-plaintext highlighter-rouge">&gt;</code> is the implicit operator. <code class="language-plaintext highlighter-rouge">foo1</code> is the code that the
programmer writes, and <code class="language-plaintext highlighter-rouge">foo4</code> is a translation of that code after
implicits are resolved, and syntactic sugar is expanded.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.math.Ordering</span>
<span class="k">import</span> <span class="nn">Ordering.Implicits._</span>

<span class="k">def</span> <span class="nf">foo1</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">foo2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">foo3</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">infixOrderingOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="o">)(</span><span class="n">ev</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">foo4</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nv">ev</span><span class="o">.</span><span class="py">Ops</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<p>(This is actually slightly wrong. The expansion to <code class="language-plaintext highlighter-rouge">foo4</code> won’t happen
until runtime, when <code class="language-plaintext highlighter-rouge">infixOrderingOps</code> is called. But it helps
illustrate the point.)</p>

<p>Notice that we instantiate an <code class="language-plaintext highlighter-rouge">ev.Ops</code> instance for every call to
<code class="language-plaintext highlighter-rouge">&gt;</code>. This is not a big deal in many cases, but for a call that is
normally quite fast it will add up when done many (e.g. millions) of
times.</p>

<p>It is possible to work around this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bar</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">ev</span><span class="o">.</span><span class="py">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ev</code> parameter contains the method we actually want (<code class="language-plaintext highlighter-rouge">gt</code>), so
instead of instantiating <code class="language-plaintext highlighter-rouge">ev.Ops</code> this code calls <code class="language-plaintext highlighter-rouge">ev.gt</code> directly.
But this approach is ugly. Compare these two methods:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">qux1</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Field</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="o">((</span><span class="n">x</span> <span class="n">pow</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">y</span> <span class="n">pow</span> <span class="mi">2</span><span class="o">)).</span><span class="py">sqrt</span>

<span class="k">def</span> <span class="nf">qux2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Field</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">ev</span><span class="o">.</span><span class="py">sqrt</span><span class="o">(</span><span class="nv">ev</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="nv">ev</span><span class="o">.</span><span class="py">pow</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nv">ev</span><span class="o">.</span><span class="py">pow</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">2</span><span class="o">)))</span>
</code></pre></div></div>

<p>If you have trouble reading <code class="language-plaintext highlighter-rouge">qux2</code>, you are not alone.</p>

<p>At this point, it looks like we can either write clean, readable code
(<code class="language-plaintext highlighter-rouge">qux1</code>), or code defensively to avoid object allocations (<code class="language-plaintext highlighter-rouge">qux2</code>).
Most programmers will just choose one or the other (probably the
former) and go on with their lives.</p>

<p>However, since this issue affects Spire deeply, we spent a bit more
time looking at this problem to see what could be done.</p>

<h2 id="having-our-cake-and-eating-it-too">Having our cake and eating it too</h2>

<p>Let’s look at another example, to compare how the “nice” and “fast”
code snippets look after implicits are resolved:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">niceBefore</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ring</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="n">z</span>

<span class="k">def</span> <span class="nf">niceAfter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">RingOps</span><span class="o">(</span><span class="k">new</span> <span class="nc">RingOps</span><span class="o">(</span><span class="n">x</span><span class="o">)(</span><span class="n">ev</span><span class="o">).+(</span><span class="n">y</span><span class="o">))(</span><span class="n">ev</span><span class="o">).*(</span><span class="n">z</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">fast</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">ev</span><span class="o">.</span><span class="py">times</span><span class="o">(</span><span class="nv">ev</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span>
</code></pre></div></div>

<p>As we can see, <code class="language-plaintext highlighter-rouge">niceAfter</code> and <code class="language-plaintext highlighter-rouge">fast</code> are actually quite similar. If
we wanted to transform <code class="language-plaintext highlighter-rouge">niceAfter</code> into <code class="language-plaintext highlighter-rouge">fast</code>, we’d just have to:</p>

<ol>
  <li>
    <p>Figure out the appropriate name for symbolic operators. In this
example, <code class="language-plaintext highlighter-rouge">+</code> becomes <code class="language-plaintext highlighter-rouge">plus</code> and <code class="language-plaintext highlighter-rouge">*</code> becomes <code class="language-plaintext highlighter-rouge">times</code>.</p>
  </li>
  <li>
    <p>Rewrite the object instantiation and method call, calling the
method on <code class="language-plaintext highlighter-rouge">ev</code> instead and passing <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> as arguments. In
this example, <code class="language-plaintext highlighter-rouge">new Ops(x)(ev).foo(y)</code> becomes <code class="language-plaintext highlighter-rouge">ev.foo(x, y)</code>.</p>
  </li>
</ol>

<p>In a nutshell, this transformation is what Spire’s Ops macros do.</p>

<h2 id="using-the-ops-macros">Using the Ops macros</h2>

<p>Your project must use Scala 2.10+ to be able to use macros.</p>

<p>To use Spire’s Ops macros, you’ll need to depend on the <code class="language-plaintext highlighter-rouge">spire-macros</code>
package. If you use SBT, you can do this by adding the following line
to <code class="language-plaintext highlighter-rouge">build.sbt</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"org.spire-math"</span> <span class="o">%%</span> <span class="s">"spire-macros"</span> <span class="o">%</span> <span class="s">"0.6.1"</span>
</code></pre></div></div>

<p>You will also need to enable macros at the declaration site of your
ops classes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>
</code></pre></div></div>

<h2 id="lets-see-an-example">Let’s see an example</h2>

<p>Consider <code class="language-plaintext highlighter-rouge">Sized</code>, a type class that abstracts over the notion of
having a size. Type class instances for <code class="language-plaintext highlighter-rouge">Char</code>, <code class="language-plaintext highlighter-rouge">Map</code>, and <code class="language-plaintext highlighter-rouge">List</code> are
provided in the companion object. Of course, users can also provide
their own instances.</p>

<p>Here’s the code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="nf">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nf">size</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="nf">nonEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="nf">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">sizeCompare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">size</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">compare</span> <span class="nf">size</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Sized</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">charSized</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">toInt</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">mapSized</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">size</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">listSized</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">length</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="nv">a</span><span class="o">.</span><span class="py">isEmpty</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">sizeCompare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">0</span>
      <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
      <span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span>
      <span class="nf">case</span> <span class="o">(</span><span class="k">_</span> <span class="o">::</span> <span class="n">xt</span><span class="o">,</span> <span class="k">_</span> <span class="o">::</span> <span class="n">yt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">sizeCompare</span><span class="o">(</span><span class="n">xt</span><span class="o">,</span> <span class="n">yt</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>(Notice that <code class="language-plaintext highlighter-rouge">Sized[List[A]]</code> overrides some of the “default”
implementations to be more efficient, since taking the full length of
a list is an O(n) operation.)</p>

<p>We’d like to be able to call these methods directly on a generic type
<code class="language-plaintext highlighter-rouge">A</code> when we have an implicit instance of <code class="language-plaintext highlighter-rouge">Sized[A]</code> available. So
let’s define a <code class="language-plaintext highlighter-rouge">SizedOps</code> class, using Spire’s Ops macros:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.macrosk.Ops</span>
<span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>

<span class="k">object</span> <span class="nc">Implicits</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">SizedOps</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">size</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">macro</span> <span class="nv">Ops</span><span class="o">.</span><span class="py">unop</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="k">def</span> <span class="nf">isEmpty</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">macro</span> <span class="nv">Ops</span><span class="o">.</span><span class="py">unop</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
    <span class="k">def</span> <span class="nf">nonEmpty</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">macro</span> <span class="nv">Ops</span><span class="o">.</span><span class="py">unop</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
    <span class="k">def</span> <span class="nf">sizeCompare</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">macro</span> <span class="nv">Ops</span><span class="o">.</span><span class="py">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s it!</p>

<p>Here’s what it would look like to use this type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Implicits._</span>

<span class="k">def</span> <span class="nf">findSmallest</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nv">as</span><span class="o">.</span><span class="py">reduceLeft</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">if</span> <span class="o">((</span><span class="n">x</span> <span class="n">sizeCompare</span> <span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nf">compact</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">as</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">nonEmpty</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">totalSize</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="nv">as</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="nv">_</span><span class="o">.</span><span class="py">size</span><span class="o">)</span>
</code></pre></div></div>

<p>Not bad, eh?</p>

<h2 id="the-fine-print">The fine print</h2>

<p>Of course, there’s always some fine-print.</p>

<p>In this case, the implicit class <strong>must</strong> use the same parameter names
as above. The constructor parameter to <code class="language-plaintext highlighter-rouge">SizedOps</code> <strong>must</strong> be called
<code class="language-plaintext highlighter-rouge">lhs</code> and the method parameter (if any) <strong>must</strong> be called
<code class="language-plaintext highlighter-rouge">rhs</code>. Also, unary operators (methods that take no parameters, like
<code class="language-plaintext highlighter-rouge">size</code>) <strong>must</strong> have parenthesis.</p>

<p>How the macros handle classes with multiple constructor parameters, or
multiple method parameters? They don’t. We haven’t needed to support
these kinds of exotic classes, but it would probably be easy to extend
Spire’s Ops macros to support other shapes as well.</p>

<p>If you fail to follow these rules, or if your class has the wrong
shape, your code will fail to compile. So don’t worry. If your code
compiles, it means you got it right!</p>

<h2 id="symbolic-names">Symbolic names</h2>

<p>The previous example illustrates rewriting method calls to avoid
allocations, but what about mapping symbolic operators to method
names?</p>

<p>Here’s an example showing the mapping from <code class="language-plaintext highlighter-rouge">*</code> to <code class="language-plaintext highlighter-rouge">times</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">CanMultiply</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Implicits</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">MultiplyOps</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">CanMultiply</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">*</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">macro</span> <span class="nv">Ops</span><span class="o">.</span><span class="py">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Example</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Implicits._</span>

  <span class="k">def</span> <span class="nf">gak</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">CanMultiply</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="nv">as</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Currently, the Ops macros have a large (but Spire-specific)
<a href="https://github.com/non/spire/blob/9eaa5c34549b7fe85c223f207f0790873075c048/macros/src/main/scala/spire/macros/Ops.scala#L143">mapping</a>
from symbols to names. However, your project may want to use different names
(or different symbols). What then?</p>

<p>For now, you are out of luck. In Spire 0.7.0, we plan to make it
possible to use your own mapping. This should make it easier for other
libraries that make heavy use of implicit symbolic operators
(e.g. Scalaz) to use these macros as well.</p>

<h2 id="other-considerations">Other considerations</h2>

<p>You might wonder how the Ops macros interact with
specialization. Fortunately, macros are expanded before the
specialization phase. This means you don’t need to worry about it! If
your type class is specialized, and you invoke the implicit from a
specialized (or non-generic) context, the result will be a specialized
call.</p>

<p>(Of course, using Scala’s specialization is tricky, and deserves its
own blog post. The good news is that type classes are some of the
easiest structures to specialize correctly in Scala.)</p>

<p>Evaluating the macros at compile-time also means that if there are
problems with the macro, you’ll find out about those at compile-time
as well. While we expect that many projects will benefit from the Ops
macros, they were designed specifically for Spire so it’s possible
that your project will discover problems, or need new features.</p>

<p>If you do end up using these macros,
<a href="https://groups.google.com/forum/#!forum/spire-math">let us know how</a>
they work for you. If you have problems, please open an
<a href="https://github.com/non/spire/issues">issue</a>, and if you have bug
fixes (or new features) feel free to open a
<a href="https://github.com/non/spire/pulls">pull request</a>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>We are used to thinking about abstractions having a cost. So we often
end up doing mental accounting: “Is it worth making this generic? Can
I afford this syntactic sugar? What will the runtime impact of this
code be?” These condition us to expect that code can either be
beautiful or fast, but not both.</p>

<p>By removing the cost of implicit object instantiation, Spire’s Ops
macros raise the abstraction ceiling. They allow us to make free use
of type classes without compromising performance. Our goal is to close
the gap between direct and generic performance, and to encourage the
widest possible use of generic types and type classes in Scala.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 13 Oct 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/10/13/spires-ops-macros.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/10/13/spires-ops-macros.html</guid>
      </item>
    
      <item>
        <title>Using scalaz.Unapply</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>Once you’ve started really taking advantage of Scalaz’s typeclasses
for generic programming, you might have noticed a need to write
typelambdas to use some of your neat abstractions, or use syntax like
<code class="language-plaintext highlighter-rouge">traverse</code> or <code class="language-plaintext highlighter-rouge">kleisli</code> with a strangely-shaped type as an argument.
Here’s a simple generalization, a <code class="language-plaintext highlighter-rouge">List</code>-based <code class="language-plaintext highlighter-rouge">traverse</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Applicative</span><span class="o">,</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">syntax</span><span class="o">.</span><span class="py">applicative</span><span class="o">.</span><span class="py">_</span>

<span class="k">def</span> <span class="nf">sequenceList</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">xs</span><span class="o">.</span><span class="py">foldRight</span><span class="o">(</span><span class="nv">List</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="py">point</span><span class="o">[</span><span class="kt">F</span><span class="o">])((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">^(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)(</span><span class="k">_</span> <span class="o">::</span> <span class="k">_</span><span class="o">))</span>
</code></pre></div></div>

<p>This works fine for a while.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.std.option._</span>
<span class="k">import</span> <span class="nn">scalaz.std.option._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nf">some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="nf">some</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nf">some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="n">none</span><span class="o">))</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</code></pre></div></div>

<h2 id="the-problem">The problem</h2>

<p>The type of the input in the above example, <code class="language-plaintext highlighter-rouge">List[Option[Int]]</code>, can be
neatly destructured into the <code class="language-plaintext highlighter-rouge">F</code> and <code class="language-plaintext highlighter-rouge">A</code> type params needed by
<code class="language-plaintext highlighter-rouge">sequenceList</code>.  It has the “shape” <code class="language-plaintext highlighter-rouge">F[x]</code>, so <code class="language-plaintext highlighter-rouge">F</code> can be picked out by
Scala easily.</p>

<p>Consider something else with a convenient <code class="language-plaintext highlighter-rouge">Applicative</code> instance,
though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.</span><span class="o">\/</span>
<span class="k">import</span> <span class="nn">scalaz.$bslash$div</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nf">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="py">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="py">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">no</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">for</span> <span class="kt">method</span> 
  <span class="n">sequenceList</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">evidence$1</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="n">exist</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span> <span class="n">can</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="nf">arguments</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]])</span>
 <span class="o">---</span> <span class="n">because</span> <span class="o">---</span>
<span class="n">argument</span> <span class="n">expression</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">compatible</span> <span class="kt">with</span> <span class="kt">formal</span> <span class="kt">parameter</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">?F</span><span class="o">]</span>

              <span class="nf">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="py">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="py">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
              <span class="o">^</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">?F</code> meaning it couldn’t figure out that you meant <code class="language-plaintext highlighter-rouge">({type λ[α]
= NonEmptyList[String] \/ α})#λ</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="kt">\/</span> <span class="kt">α</span><span class="o">})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">Int</span>
                  <span class="o">](</span><span class="nc">List</span><span class="o">(\/.</span><span class="py">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="py">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
        <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>The problem is that <code class="language-plaintext highlighter-rouge">NonEmptyList[String] \/ Int</code> has the shape
<code class="language-plaintext highlighter-rouge">F[A, B]</code>, with <code class="language-plaintext highlighter-rouge">F</code> of kind <code class="language-plaintext highlighter-rouge">* -&gt; * -&gt; *</code> after a fashion, whereas the
<code class="language-plaintext highlighter-rouge">F</code> it wants must have kind <code class="language-plaintext highlighter-rouge">* -&gt; *</code>, and Scala kinds aren’t curried
at all.</p>

<h2 id="finding-an-unapply-instance">Finding an <code class="language-plaintext highlighter-rouge">Unapply</code> instance</h2>

<p><code class="language-plaintext highlighter-rouge">Unapply</code>, though, <em>does</em> have implicit instances matching the
<code class="language-plaintext highlighter-rouge">F[A, B]</code> shape, <code class="language-plaintext highlighter-rouge">unapplyMAB1</code> and <code class="language-plaintext highlighter-rouge">unapplyMAB2</code>, in its companion so
effectively always visible.  What’s special about them is that their
type parameters match the “shape” you’re working with, <code class="language-plaintext highlighter-rouge">F[A, B]</code>.</p>

<p>You should
<a href="https://github.com/scalaz/scalaz/blob/v7.0.3/core/src/main/scala/scalaz/Unapply.scala#L210">look at their source</a>
to follow along.</p>

<p>Let’s see if one of them works.  For implicit resolution to finish,
it’s important that <em>exactly</em> one of them works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.Unapply</span>
<span class="k">import</span> <span class="nn">scalaz.Unapply</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Unapply</span><span class="o">.</span><span class="py">unapplyMAB1</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
<span class="nc">TC0</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">α</span>,<span class="kt">Int</span><span class="o">]]</span>
              <span class="nv">Unapply</span><span class="o">.</span><span class="py">unapplyMAB1</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
                                 <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Unapply</span><span class="o">.</span><span class="py">unapplyMAB2</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Applicative</span>,
                     <span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]]{</span>
        <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">scalaz</span><span class="o">.\/[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">X</span><span class="o">];</span>
        <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">Int</span>
      <span class="o">}</span> <span class="k">=</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">5402</span><span class="n">af61</span>
</code></pre></div></div>

<p>Here, the type <code class="language-plaintext highlighter-rouge">res7.M</code> represents the typelambda being passed to
<code class="language-plaintext highlighter-rouge">sequenceList</code>.  You can see that work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">[</span><span class="kt">res7.M</span>, <span class="kt">res7.A</span><span class="o">](</span>
                   <span class="nc">List</span><span class="o">(\/.</span><span class="py">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="py">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">res7.M</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">res7.A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res8</span> <span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">\/</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
        <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">res8</code> conformance test shows that Scala can still reduce the
path-dependent <code class="language-plaintext highlighter-rouge">res7.M</code> and <code class="language-plaintext highlighter-rouge">res7.A</code> types at this level, outside
<code class="language-plaintext highlighter-rouge">sequenceList</code>.</p>

<h2 id="searching-for-the-right-shape">Searching for the right shape</h2>

<p>Implicit resolution can pick the call to <code class="language-plaintext highlighter-rouge">unapplyMAB2</code> partly because
it can pick all of its type parameters without weird typelambda
structures.  But in Scalaz, we use typeclasses to guide its choice.</p>

<p>Why didn’t <code class="language-plaintext highlighter-rouge">unapplyMAB1</code> work?  In this case, you can trust <code class="language-plaintext highlighter-rouge">scalac</code>
to say exactly the right thing: it looked for
<code class="language-plaintext highlighter-rouge">Applicative[[α]scalaz.\/[α,Int]]</code>, and didn’t find one.  Sure enough,
<code class="language-plaintext highlighter-rouge">\/</code> being right-biased means we don’t offer that instance.</p>

<p>Incidentally, if you were to introduce that instance, you’d break code
relying on right-biased <code class="language-plaintext highlighter-rouge">Unapply</code> resolution to work.</p>

<p><code class="language-plaintext highlighter-rouge">unapplyMAB2</code> needs evidence of <code class="language-plaintext highlighter-rouge">TC[({type λ[α] = M0[A0, α]})#λ]</code>.
But that’s okay, because we have that, where <code class="language-plaintext highlighter-rouge">TC=Applicative</code>,
<code class="language-plaintext highlighter-rouge">M0=\/</code>, and <code class="language-plaintext highlighter-rouge">A0=NonEmptyList[String]</code>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Applicative</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">\/</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">α</span><span class="o">]]</span>
         <span class="k">=</span> <span class="nv">scalaz</span><span class="o">.</span><span class="py">DisjunctionInstances2$$anon$1</span><span class="k">@</span><span class="mf">2f</span><span class="mi">658816</span>
</code></pre></div></div>

<p>Scala doesn’t need to figure out any typelambda itself for this to
work; we did everything by putting the typelambda right into
<code class="language-plaintext highlighter-rouge">unapplyMAB2</code>’s evidence requirement, so it just has to find the
conforming implicit value.</p>

<h2 id="using-unapply-generically">Using <code class="language-plaintext highlighter-rouge">Unapply</code> generically</h2>

<p>Now you can write a <code class="language-plaintext highlighter-rouge">sequenceList</code> wrapper that works for <code class="language-plaintext highlighter-rouge">\/</code> and
many other shapes, including user-provided shapes in the form of new
<code class="language-plaintext highlighter-rouge">Unapply</code> implicit instances.  If you’re using Scala 2.9 (still?!) you
need to add <code class="language-plaintext highlighter-rouge">-Ydependent-method-types</code> to <code class="language-plaintext highlighter-rouge">scalacOptions</code> to write
this function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sequenceListU</span><span class="o">[</span><span class="kt">FA</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">FA</span><span class="o">])</span>
                     <span class="o">(</span><span class="k">implicit</span> <span class="n">U</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">FA</span><span class="o">]</span>
                     <span class="o">)</span><span class="k">:</span> <span class="kt">U.M</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">U.A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nf">sequenceList</span><span class="o">(</span><span class="nv">U</span><span class="o">.</span><span class="py">leibniz</span><span class="o">.</span><span class="py">subst</span><span class="o">(</span><span class="n">xs</span><span class="o">))(</span><span class="nv">U</span><span class="o">.</span><span class="py">TC</span><span class="o">)</span>
</code></pre></div></div>

<p>Instead of <code class="language-plaintext highlighter-rouge">xs</code> being <code class="language-plaintext highlighter-rouge">List[F[A]]</code>, it’s <code class="language-plaintext highlighter-rouge">List[FA]</code>, and that’s
destructured into <code class="language-plaintext highlighter-rouge">U.M</code> and <code class="language-plaintext highlighter-rouge">U.A</code>.  The latter are path-dependent
types on <code class="language-plaintext highlighter-rouge">U</code>, the conventional name of the <code class="language-plaintext highlighter-rouge">Unapply</code> parameter.  We
have also followed the convention of naming the <code class="language-plaintext highlighter-rouge">Unapply</code>-taking
variant function ending with a <code class="language-plaintext highlighter-rouge">U</code>.</p>

<p>And that works great!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nf">sequenceListU</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="py">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="py">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
   <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>Of course, there’s that strange-looking function body to consider,
still.</p>

<h2 id="using-the-u-evidence">Using the <code class="language-plaintext highlighter-rouge">U</code> evidence</h2>

<p>The type equalities of the original <code class="language-plaintext highlighter-rouge">U.M</code> and <code class="language-plaintext highlighter-rouge">U.A</code> to the original
types can be seen where <code class="language-plaintext highlighter-rouge">res8</code> is refined to <code class="language-plaintext highlighter-rouge">res9</code> above.  But only
the <em>caller</em> of the function knows those equalities, because it
produced and supplied the <code class="language-plaintext highlighter-rouge">unapplyMAB2</code> call, which has a structural
type containing those equalities.</p>

<p>The body of <code class="language-plaintext highlighter-rouge">sequenceListU</code> doesn’t know those things.  In particular,
it <em>still</em> can’t pick type parameters to pass to <code class="language-plaintext highlighter-rouge">sequenceList</code>
without a little help.</p>

<p>The <code class="language-plaintext highlighter-rouge">leibniz</code> member is a reified type equality of <code class="language-plaintext highlighter-rouge">FA === U.M[U.A]</code>,
meaning those are the same at the type level, even though Scala can’t
see it in this context.  It represents genuine evidence that those two
types are equal, and is much more powerful than scala-library’s own
<code class="language-plaintext highlighter-rouge">=:=</code>.  We’re using the core Leibniz operator, <code class="language-plaintext highlighter-rouge">subst</code>, directly to
prove that, <em>as a consequence of that type equality</em>, <code class="language-plaintext highlighter-rouge">List[FA] ===
List[U.M[U.A]]</code> is <em>also</em> a type equality, and that therefore this
[constant-time] coercion is valid.  This lifting is applicable in all
contexts, not just covariant ones like <code class="language-plaintext highlighter-rouge">List</code>’s.  Take a look at
<a href="https://github.com/scalaz/scalaz/blob/v7.0.3/core/src/main/scala/scalaz/Leibniz.scala">the full API</a>
for more, though you’ll typically just need to come up with the right
type parameter for <code class="language-plaintext highlighter-rouge">subst</code>.</p>

<p>You can’t ask for an <code class="language-plaintext highlighter-rouge">Unapply</code> and <em>also</em> ask for an
<code class="language-plaintext highlighter-rouge">Applicative[U.M]</code>; Scala won’t allow it.  So, because we needed to
resolve the typeclass anyway to find the <code class="language-plaintext highlighter-rouge">Unapply</code> implicit to use, we
just cart it along with the <code class="language-plaintext highlighter-rouge">U</code> and give it to the function, which
almost always needs to use it anyway.  Because it’s not implicitly
available, you usually need to grab it, <code class="language-plaintext highlighter-rouge">U.TC</code>, and use it directly.</p>

<h2 id="using-in-scalazsyntax">Using in <code class="language-plaintext highlighter-rouge">scalaz.syntax</code></h2>

<p><code class="language-plaintext highlighter-rouge">map</code> comes from functor syntax; it’s not a method on <code class="language-plaintext highlighter-rouge">Function1</code>.  So
how come this works?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; import scalaz.std.function._
import scalaz.std.function._

scala&gt; ((_:Int) + 42) map (_ * 33)
res13: Int =&gt; Int = &lt;function1&gt;

scala&gt; res13(1)
res14: Int = 1419
</code></pre></div></div>

<p>When you import syntax, as <code class="language-plaintext highlighter-rouge">Functor</code> syntax was imported with
<code class="language-plaintext highlighter-rouge">scalaz.syntax.applicative._</code> above, you get at least two conversions:
the plain one, like <code class="language-plaintext highlighter-rouge">ToFunctorOps[F[_],A]</code>, which works if you have
the right shape, and the fancy one, <code class="language-plaintext highlighter-rouge">ToFunctorOpsUnapply[FA]</code>, which
uses an <code class="language-plaintext highlighter-rouge">Unapply</code> to effectively invoke <code class="language-plaintext highlighter-rouge">ToFunctorOps</code> as in the
above.  The latter is lower-priority, so Scala will pick the former if
the value has the <code class="language-plaintext highlighter-rouge">F[A]</code> shape.</p>

<p>That gives access to all the methods in <code class="language-plaintext highlighter-rouge">FunctorOps</code>, and other ops
classes, with only one special <code class="language-plaintext highlighter-rouge">U</code>-taking method.  If you have several
functions operating on the same value type, or you can make that type
similar with Leibnizian equality as implicit arguments to your
methods, I suggest grouping them in this way, too, to cut down on
boilerplate.</p>

<h2 id="provide-both-anyway">Provide both anyway</h2>

<p>We sometimes get asked “why not just provide the <code class="language-plaintext highlighter-rouge">Unapply</code> version of
the function or ops?”</p>

<p>We do it, and suggest it for your own code, despite the confusion,
because it’s easier to work with real type equalities than with
Leibnizian equality, which you can do in your “real” function
implementation, and as seen in <code class="language-plaintext highlighter-rouge">res8</code> above, the path-dependent type
resolution can leave funny artifacts in the inferred result.  Here’s
an extreme example from
<a href="https://groups.google.com/d/msg/scalaz/9zAIGETrePI/o1rBsOcWJWAJ">an earlier demonstration</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">itt</span> <span class="k">=</span> <span class="nc">IdentityT</span> <span class="n">lift</span> <span class="n">it</span>
<span class="n">itt</span><span class="k">:</span> <span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">Identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
                                                       <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Identity</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="err">;</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
                                                     <span class="kt">Int</span><span class="o">]]</span>
                 <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">Identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
                                          <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Identity</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="err">;</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
                                        <span class="kt">X</span><span class="o">]</span><span class="err">;</span>
                  <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
               <span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">IdentityT</span><span class="o">(</span><span class="nc">IdentityT</span><span class="o">(</span><span class="nc">Identity</span><span class="o">(</span><span class="mi">42</span><span class="o">)))</span>
</code></pre></div></div>

<h2 id="credits">Credits</h2>

<p><a href="https://twitter.com/retronym">Jason Zaugg</a> implemented Scalaz
<code class="language-plaintext highlighter-rouge">Unapply</code>, based on
<a href="https://issues.scala-lang.org/browse/SI-2712?focusedCommentId=55239&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-55239">ideas</a>
from <a href="https://twitter.com/milessabin">Miles Sabin</a> and
<a href="https://github.com/pchiusano">Paul Chiusano</a>.</p>

<p>Leibnizian equality was implemented for Scalaz by
<a href="https://github.com/ekmett">Edward Kmett</a>.</p>

<p><a href="https://twitter.com/larsr_h">Lars Hupel</a>’s talk
(<a href="https://speakerdeck.com/larsrh/seven-at-one-blow-new-and-polished-features-in-scalaz-7">slides</a>,
<a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=KzoqOVD7mvE">video</a>)
on the features in the then-upcoming Scalaz 7 at nescala 2013,
including <code class="language-plaintext highlighter-rouge">Unapply</code>, gave me the missing “guided by typeclasses”
detail, inspiring me to tell more people about the whole thing at the
conference, and then, much later, write it down here.</p>

<p><em>This article was tested with Scala 2.10.2 &amp; Scalaz 7.0.3.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 11 Sep 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/09/11/using-scalaz-Unapply.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/09/11/using-scalaz-Unapply.html</guid>
      </item>
    
      <item>
        <title>An Intro to Generic Numeric Programming with Spire</title>
        
          <dc:creator>tixxit</dc:creator>
                
        <description><![CDATA[<p>In this post I’d like to introduce you to what I have been calling <em>generic
numeric programming</em>.</p>

<h2 id="what-is-generic-numeric-programming">What is Generic Numeric Programming?</h2>

<p>What do we mean by generic numeric programming? Let’s take a simple example; we
want to add 2 numbers together. However, we don’t want to restrict ourselves to
a particular type, like <code class="language-plaintext highlighter-rouge">Int</code> or <code class="language-plaintext highlighter-rouge">Double</code>, instead we just want to work with
some <em>generic</em> type <code class="language-plaintext highlighter-rouge">A</code> that can be added. For instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>Of course, this won’t compile since <code class="language-plaintext highlighter-rouge">A</code> has no method <code class="language-plaintext highlighter-rouge">+</code>. What we are really
saying is that we want <code class="language-plaintext highlighter-rouge">A</code> to be some type that <em>behaves like a number</em>. The
usual OO way to achieve this is by creating an interface that defines our
desired behaviour. This is less than ideal, but if we were to go this route,
our <code class="language-plaintext highlighter-rouge">add</code> function might look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="nf">+</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">add</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>We’ve created an interface that defines our <code class="language-plaintext highlighter-rouge">+</code> method, and then bound our type
parameter <code class="language-plaintext highlighter-rouge">A</code> to subsume this interface. The main problem with this is that we
can’t directly use types out of our control, like those that come in the
standard library (ie. <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Long</code>, <code class="language-plaintext highlighter-rouge">Double</code>, <code class="language-plaintext highlighter-rouge">BigInt</code>, etc). The only option
would be to wrap these types, which means extra allocations and either explicit
or implicit conversions, neither of which are good options.</p>

<p>A better approach is to use type classes. A discussion on type classes is out
of the scope of this post, but they let us express that the type <code class="language-plaintext highlighter-rouge">A</code> must have
some desired behaviour, without inheritence. Using the type class pattern, we
could write something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// Both arguments must be provided. Addable works with the type A, but
</span>  <span class="c1">// does not extend it.
</span>  <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="c1">// This class adds the + operator to any type A that is Addable,
// by delegating to that Addable's `plus` method.
</span><span class="k">implicit</span> <span class="k">class</span> <span class="nc">AddableOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">+</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">ev</span><span class="o">.</span><span class="py">plus</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// We use a context bound to require that A has an Addable instance.
</span><span class="k">def</span> <span class="nf">add</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Addable</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>We can then easily add implementations for any numeric type, regardless if we
control it or not, or even if it is a primitive type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">object</span> <span class="nc">IntIsAddable</span> <span class="k">extends</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>

<span class="nf">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>This is, more or less, the approach Spire takes.</p>

<h2 id="why-be-generic">Why be Generic?</h2>

<p>Why be generic? The flippant answer I could give is: why not? I do hope that
after reading this, that is an acceptable answer to you, but I know that’s not
what you came here for.</p>

<p>The first reason is the obvious one; sometimes you want to run the same
algorithm, but with different number types. Euclid’s GCD algorithm is the same
whether you are using <code class="language-plaintext highlighter-rouge">Byte</code>, <code class="language-plaintext highlighter-rouge">Short</code>, <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Long</code>, or <code class="language-plaintext highlighter-rouge">BigInt</code>. Why implement
it only for 1, when you could do it for all 5? Worse; why implement it 5
times, when you need only implement it once?</p>

<p>Another reason is that you want to push certain trade-offs, such as speed vs
precision to the user of your library, rather than making the decision for
them. <code class="language-plaintext highlighter-rouge">Double</code> is fast, but has a fixed precision. <code class="language-plaintext highlighter-rouge">BigDecimal</code> is slow, but
can have much higher precision. Which one do you use? When in doubt, let
someone else figure it out!</p>

<p>A last great reason is that it let’s you write less tests and can make
testing much less hairy.</p>

<h3 id="one-algorithm-many-types">One Algorithm, Many Types</h3>

<p>So, what does a generic version of Euclid’s GCD algorithm look like? Spire
strives to make generic numeric code look more or less like what you’d write
for a direct implementation. So, let’s let you compare; first up, the direct
implementation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">euclidGcd</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
  <span class="k">else</span> <span class="nf">euclidGcd</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>With Spire, we can use the <code class="language-plaintext highlighter-rouge">spire.math.Integral</code> type class to rewrite this as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math.Integral</span>
<span class="k">import</span> <span class="nn">spire.implicits._</span>

<span class="k">def</span> <span class="nf">euclidGcd</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Integral</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
  <span class="k">else</span> <span class="nf">euclidGcd</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>The 2 methods are almost identical, save the <code class="language-plaintext highlighter-rouge">Integral</code> context bound.
<code class="language-plaintext highlighter-rouge">Integral</code> gives us many methods we expect integers to have, like addition,
multiplication, and euclidean division (quotient + remainder).</p>

<p>Because Spire provides default implicit instances of <code class="language-plaintext highlighter-rouge">Integral</code> for all of the
integral types that come in the Scala standard library, we can immediately use
<code class="language-plaintext highlighter-rouge">euclidGcd</code> to find the GCD of many integer types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">euclidGcd</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">96</span><span class="o">)</span>
<span class="nf">euclidGcd</span><span class="o">(</span><span class="mi">42L</span><span class="o">,</span> <span class="mi">96L</span><span class="o">)</span>
<span class="nf">euclidGcd</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">96</span><span class="o">))</span>
</code></pre></div></div>

<p>This is much better than writing 5 different versions of the same algorithm!
With Spire, you can actually do away with <code class="language-plaintext highlighter-rouge">euclidGcd</code> altogether, as <code class="language-plaintext highlighter-rouge">gcd</code>
comes with <code class="language-plaintext highlighter-rouge">Integral</code> anyways:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">spire</span><span class="o">.</span><span class="py">math</span><span class="o">.</span><span class="py">gcd</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</code></pre></div></div>

<h3 id="performance-vs-precision">Performance vs Precision</h3>

<p>Another benefit of generic numeric programming, is that you can push the choice
of numeric type off to someone else. Rather than hardcode a method or data
structure using <code class="language-plaintext highlighter-rouge">Double</code>, you can simple require some <code class="language-plaintext highlighter-rouge">Fractional</code> type.</p>

<p>I actually first found a need for generic numeric programming after I had
implemented a swath of algorithms with double precision floating point
arithmetic, only to find out that the minor precision errors were causing
serious correctness issues. The obvious fix was to just to use an exact type,
like <code class="language-plaintext highlighter-rouge">spire.math.Rational</code>, which would’ve worked for many of my purposes.
However, many of the algorithms actually worked fine with doubles or even
integers, where as others required exact n-roots (provided by a number type
like <code class="language-plaintext highlighter-rouge">spire.math.Real</code>). Being more precise meant everything got slower, even
when it didn’t need to be. Being less precise meant some algorithms would
occasionally return wrong answers. Abstracting out the actual number type
used meant I didn’t have to worry about these issues. I could make the choice
later, when I knew a bit more about my data, performance and precision
requirements.</p>

<p>We can illustrate this using a simple algorithm to compute the mean of some
numbers.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math._</span>
<span class="k">import</span> <span class="nn">spire.implicits._</span>

<span class="c1">// Note: It is generally better to use an incremental mean.
</span><span class="k">def</span> <span class="nf">mean</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Fractional</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">A*</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">reduceLeft</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span> <span class="o">/</span> <span class="nv">xs</span><span class="o">.</span><span class="py">size</span>
</code></pre></div></div>

<p>Here, we don’t care what type <code class="language-plaintext highlighter-rouge">A</code> is, as long as it can be summed and divided. 
If we’re working with approximate measurements, perhaps finding the mean of a
list of <code class="language-plaintext highlighter-rouge">Double</code>s is good enough:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">mean</span><span class="o">(</span><span class="mf">0.5</span><span class="o">,</span> <span class="mf">1.5</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">)</span> 
<span class="c1">// = 0.6666666666666666
</span></code></pre></div></div>

<p>Or perhaps we’d like an exact answer back instead:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math.Rational</span>

<span class="nf">mean</span><span class="o">(</span><span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
<span class="c1">// = Rational(2, 3)
</span></code></pre></div></div>

<p>The main thing here is that as a user of the <code class="language-plaintext highlighter-rouge">mean</code> function, I get to choose
whether I’d prefer the speed of <code class="language-plaintext highlighter-rouge">Double</code> or the precision or <code class="language-plaintext highlighter-rouge">Rational</code>. The
algorithm itself looks no different, so why not give the user the choice?</p>

<h3 id="better-testing">Better Testing</h3>

<p>One of the best things is that if you write test code that abstracts over the
number type, then you can re-use your tests for many different types. Spire
makes great use of this, to ensure instances of our type classes obey the rules
of algebra and that the number types in Spire (Rational, Complex, UInt, etc)
are fundamentally correct.</p>

<p>There is another benefit though – you can ignore the subtleties of floating
point arithmetic in your tests if you want! If your code works with any number
type, then you can test with an exact type such as <code class="language-plaintext highlighter-rouge">spire.math.Rational</code> or
<code class="language-plaintext highlighter-rouge">spire.math.Real</code>. No more epsilons and NaNs. You shouldn’t let this excuse you
from writing numerically stable code, but it may save you many false negatives
in your build system, while also making you more confident that the fundamentals
are correct.</p>

<p>This is a big topic, deserving of its own blog post (you know who you are), so
I’ll leave this here.</p>

<h2 id="what-abstractions-exist">What Abstractions Exist?</h2>

<p>We’ve already seen <code class="language-plaintext highlighter-rouge">Integral</code>, which can be used wherever you need something
that acts like an integer. We also saw the modulus operator, <code class="language-plaintext highlighter-rouge">x % y</code>, but not
integer division. Spire differentiates between <em>integer division</em> and <em>exact
division</em>. You perform integer division with <code class="language-plaintext highlighter-rouge">x /~ y</code>. To see it in action,
let’s use an overly complicated function to negate an integer:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math._</span>
<span class="k">import</span> <span class="nn">spire.implicits._</span>

<span class="k">def</span> <span class="nf">negate</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Integral</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="o">-(</span><span class="mi">42</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span> <span class="o">/~</span> <span class="mi">42</span><span class="o">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>Instances of <code class="language-plaintext highlighter-rouge">Integral</code> exist for <code class="language-plaintext highlighter-rouge">Byte</code>, <code class="language-plaintext highlighter-rouge">Short</code>, <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Long</code> and <code class="language-plaintext highlighter-rouge">BigInt</code>.</p>

<p>Another type class Spire provides is <code class="language-plaintext highlighter-rouge">Fractional[A]</code>, which is used for things
that have “exact” division. “Exact” is in quotes, since <code class="language-plaintext highlighter-rouge">Double</code> or
<code class="language-plaintext highlighter-rouge">BigDecimal</code> division isn’t really exact, but it’s close enough that we give 
them a pass. <code class="language-plaintext highlighter-rouge">Fractional</code> also provides <code class="language-plaintext highlighter-rouge">x.sqrt</code> and <code class="language-plaintext highlighter-rouge">x nroot k</code> for taking the
roots of a number.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">distance</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Fractional</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="o">).</span><span class="py">sqrt</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">Fractional[A] &lt;: Integral[A]</code>, so anything you can do with
<code class="language-plaintext highlighter-rouge">Integral</code>, you can do with <code class="language-plaintext highlighter-rouge">Fractional[A]</code> too. Here, we can use <code class="language-plaintext highlighter-rouge">distance</code>
to calculate the length of the hypotenuse with <code class="language-plaintext highlighter-rouge">Double</code>s, <code class="language-plaintext highlighter-rouge">Float</code>s,
<code class="language-plaintext highlighter-rouge">BigDecimal</code>s, or some of Spire’s number types like <code class="language-plaintext highlighter-rouge">Real</code> or <code class="language-plaintext highlighter-rouge">Rational</code>.</p>

<p>Lastly, you often have cases where you just don’t care if <code class="language-plaintext highlighter-rouge">/</code> means exact or
integer division, or whether you are taking the square root of an <code class="language-plaintext highlighter-rouge">Int</code> or a
<code class="language-plaintext highlighter-rouge">Double</code>. For this kind of catch-all work Spire provides <code class="language-plaintext highlighter-rouge">Numeric[A]</code>.</p>

<h2 id="why-spire">Why Spire?</h2>

<p>If you’ve already hit the types of problems solved by generic numeric
programming, then you may have seen that <code class="language-plaintext highlighter-rouge">scala.math</code> also provides <code class="language-plaintext highlighter-rouge">Numeric</code>,
<code class="language-plaintext highlighter-rouge">Integral</code>, and <code class="language-plaintext highlighter-rouge">Fractional</code>, so why use Spire? Well, we originally created
Spire largely due to the problems with the type classes as they exist in Scala.</p>

<p>To start, Scala’s versions aren’t specialized, so they only worked with boxed
versions of primitive types. The operators in Scala also required boxing, which
means you need to trade-off performance for readability. They also aren’t very
useful for a lot of numeric programming; what about nroots, trig functions,
unsigned types, etc?</p>

<p>Spire also provides many more useful (and specialized) type classes. Some are
ones you’d expect, like <code class="language-plaintext highlighter-rouge">Eq</code> and <code class="language-plaintext highlighter-rouge">Order</code>, while others define more basic
algebras than <code class="language-plaintext highlighter-rouge">Numeric</code> and friends, like <code class="language-plaintext highlighter-rouge">Ring</code>, <code class="language-plaintext highlighter-rouge">Semigroup</code>, <code class="language-plaintext highlighter-rouge">VectorSpace</code>,
etc.</p>

<p>There are many useful number types that are missing from Scala in Spire, such
as <code class="language-plaintext highlighter-rouge">Rational</code>, <code class="language-plaintext highlighter-rouge">Complex</code>, <code class="language-plaintext highlighter-rouge">UInt</code>, etc.</p>

<p>Spire was written by people who actually use it. I somewhat feel like Scala’s
Numeric and friends weren’t really used much after they were created, other
than for Scala’s NumericRange support (ie. <code class="language-plaintext highlighter-rouge">1.2 to 2.4 by 0.1</code>). They miss
many little creature comforts whose need becomes apparent after using Scala’s
type classes for a bit.</p>

<h3 id="spire-is-fast">Spire is Fast</h3>

<p>One of Spire’s goals is that the performance of generic code shouldn’t suffer.
Ideally, the generic code should be as fast as the direct implementation. Using
the GCD implementation above as an example, we can compare Spire vs. Scala vs.
a direct implementation. I’ve put the
<a href="https://gist.github.com/tixxit/5695365">benchmarking code up as a Gist</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcdDirect:        29.981   1.00 x gcdDirect
gcdSpire:         30.094   1.00 x gcdDirect
gcdSpireNonSpec:  36.903   1.23 x gcdDirect
gcdScala:         38.989   1.30 x gcdDirect
</code></pre></div></div>

<p>For another example, we can look at the code to
<a href="https://gist.github.com/tixxit/5695365">find the mean of an array</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>meanDirect:        10.592   **1.00 x gcdDirect**
meanSpire:         10.638   **1.00 x gcdDirect**
meanSpireNonSpec:  13.434   **1.26 x gcdDirect** 
meanScala:         19.388   **1.83 x gcdDirect**
</code></pre></div></div>

<p>Spire achieves these goals fairly simply. All our type classes are
<code class="language-plaintext highlighter-rouge">@specialized</code>, so when using primitives types you can avoid boxing. We then use macros to remove
the boxing normally required for the operators by the implicit conversions.</p>

<p>Using <code class="language-plaintext highlighter-rouge">@specialized</code>, both <code class="language-plaintext highlighter-rouge">gcdSpire</code> and <code class="language-plaintext highlighter-rouge">meanSpire</code> aren’t noticably slower
than the direct implementation. We can see the slow down caused by dropping
<code class="language-plaintext highlighter-rouge">@specialized</code> in <code class="language-plaintext highlighter-rouge">gcdSpireNonSpec</code> and <code class="language-plaintext highlighter-rouge">meanSpireNonSpec</code>. The difference
between <code class="language-plaintext highlighter-rouge">gcdSpireNonSpec</code> and <code class="language-plaintext highlighter-rouge">gcdScala</code> is because Spire doesn’t allocate an
object for the <code class="language-plaintext highlighter-rouge">%</code> operator (using macros to remove the allocation). The
difference is even more pronounced between <code class="language-plaintext highlighter-rouge">meanSpireNonSpec</code> and <code class="language-plaintext highlighter-rouge">meanScala</code>.</p>

<h3 id="more-than-just-numeric-integral-and-fractional">More than just <code class="language-plaintext highlighter-rouge">Numeric</code>, <code class="language-plaintext highlighter-rouge">Integral</code>, and <code class="language-plaintext highlighter-rouge">Fractional</code></h3>

<p>The 3 type classes highlighted in this post are just the tip of the iceberg.
Spire provides a whole slew of type classes in <code class="language-plaintext highlighter-rouge">spire.algebra</code>. This package
contains type classes representing a wide variety of algebraic structures,
such as <code class="language-plaintext highlighter-rouge">Monoid</code>, <code class="language-plaintext highlighter-rouge">Group</code>, <code class="language-plaintext highlighter-rouge">Ring</code>, <code class="language-plaintext highlighter-rouge">Field</code>, <code class="language-plaintext highlighter-rouge">VectorSpace</code>, and more. The 3 type
classes discussed above provide a good starting point, but if you use Spire in
your project, you will probably find yourself using <code class="language-plaintext highlighter-rouge">spire.algebra</code> more and
more often. If you’d like to learn more, you can <a href="http://www.youtube.com/watch?v=xO9AoZNSOH4">watch my talk on abstract
algebra in Scala</a>.</p>

<p>As an example of using the algebra package, <code class="language-plaintext highlighter-rouge">spire.math.Integral</code> is simply
defined as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.algebra.</span><span class="o">{</span> <span class="nc">EuclideanRing</span><span class="o">,</span> <span class="nc">IsReal</span> <span class="o">}</span>

<span class="k">trait</span> <span class="nc">Integral</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">EuclideanRing</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
                     <span class="k">with</span> <span class="nc">IsReal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="c1">// Includes Order[A] with Signed[A].
</span>                     <span class="k">with</span> <span class="nc">ConvertableFrom</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
                     <span class="k">with</span> <span class="nc">ConvertableTo</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Whereas <code class="language-plaintext highlighter-rouge">spire.math.Fractional</code> is just:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.algebra.</span><span class="o">{</span> <span class="nc">Field</span><span class="o">,</span> <span class="nc">NRoot</span> <span class="o">}</span>

<span class="k">trait</span> <span class="nc">Fractional</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Integral</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Field</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">NRoot</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<h3 id="many-new-number-types">Many New Number Types</h3>

<p>Spire also adds many new useful number types. Here’s an incomplete list:</p>

<ul>
  <li><strong>spire.math.Rational</strong> is a fast, exact number type for working with
rational numbers,</li>
  <li><strong>spire.math.Complex[A]</strong> is a parametric number type for complex numbers,</li>
  <li><strong>spire.math.Number</strong> is a boxed number type that strives for flexibility
of use,</li>
  <li><strong>spire.math.Interval</strong> is a number type for interval arithmetic,</li>
  <li><strong>spire.math.Real</strong> is a number type for exact geometric computation that
provides exact n-roots, as well as exact division,</li>
  <li><strong>spire.math.{UByte,UShort,UInt,ULong}</strong> unsigned integer types, and</li>
  <li><strong>spire.math.Natural</strong> an arbitrary precision unsigned integer type.</li>
</ul>

<h3 id="better-readability">Better Readability</h3>

<p>Spire also provides better operator integration with <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Double</code>. For
instance, <code class="language-plaintext highlighter-rouge">2 * x</code> or <code class="language-plaintext highlighter-rouge">x * 2</code> will just work for any <code class="language-plaintext highlighter-rouge">x</code> whose type has an
<code class="language-plaintext highlighter-rouge">Ring</code>. On the other hand, Scala requires something like
<code class="language-plaintext highlighter-rouge">implicitly[Numeric[A]].fromInt(2) * x</code> which is much less readable. This
also goes for working with fractions; <code class="language-plaintext highlighter-rouge">x * 0.5</code> will just work, if <code class="language-plaintext highlighter-rouge">x</code> has a
<code class="language-plaintext highlighter-rouge">Field</code>.</p>

<h2 id="try-it-out">Try It Out!</h2>

<p>Spire has a basic algebra that let’s us work generically with numeric types. It
does this without sacrificing readability or performance. It also provides many
more useful abstractions and concrete number types. This means you can write
less code, write less tests, and worry less about concerns like performance vs.
precision. If this appeals to you, then you should try it out!</p>

<p>There is some basic information on getting up-and-running with Spire in SBT on
<a href="https://github.com/non/spire">Spire’s project page</a>. If you have any further
questions, comments, suggestions, criticism or witticisms you can say what you
want to say on the <a href="https://groups.google.com/forum/#!forum/spire-math">Spire mailing list</a>
or on IRC on Freenode in <code class="language-plaintext highlighter-rouge">#spire-math</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 07 Jul 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/07/07/generic-numeric-programming.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/07/07/generic-numeric-programming.html</guid>
      </item>
    
      <item>
        <title>Deriving Type Class Instances</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<h2 id="motivating-example">Motivating example</h2>

<p>Assume that you have a <code class="language-plaintext highlighter-rouge">case class</code> representing vectors in three-dimensional space:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector3D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>Now you want to implement addition on this class.
Currently, you have to do that manually:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">+</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Vector3D</span> <span class="o">=</span>
  <span class="nc">Vector3D</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">x</span> <span class="o">+</span> <span class="nv">that</span><span class="o">.</span><span class="py">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="py">y</span> <span class="o">+</span> <span class="nv">that</span><span class="o">.</span><span class="py">y</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="py">z</span> <span class="o">+</span> <span class="nv">that</span><span class="o">.</span><span class="py">z</span><span class="o">)</span>
</code></pre></div></div>

<p>If you are writing some code involving three-dimensional vectors, chances are that you also have to deal with two-dimensional ones:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector2D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">+</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Vector2D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Vector2D</span> <span class="o">=</span>
    <span class="nc">Vector2D</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="py">x</span> <span class="o">+</span> <span class="nv">that</span><span class="o">.</span><span class="py">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="py">y</span> <span class="o">+</span> <span class="nv">that</span><span class="o">.</span><span class="py">y</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Observe that the hand-written implementation of <code class="language-plaintext highlighter-rouge">+</code> is quite repetitive.
We want to avoid that sort of boilerplate code as much as possible.</p>

<p>In this post, we will introduce an abstraction over the <em>addition</em> operation, namely <em>semigroups</em>,
and introduce a macro-based facility which allows you to get the implementation of <code class="language-plaintext highlighter-rouge">+</code> for free.
In the end, the only thing you will have to write is this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">vector2DSemigroup</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector2D</span><span class="o">]</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">vector3DSemigroup</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector3D</span><span class="o">]</span>
</code></pre></div></div>

<p>That is still a little bit of boilerplate, right? How about:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Semigroup.auto._</span>
</code></pre></div></div>

<p>This will give you <code class="language-plaintext highlighter-rouge">Semigroup</code> instances for <em>all</em> of your data types – with zero boilerplate!</p>

<p>But first, let us introduce all the related concepts properly.</p>

<h2 id="abstracting-all-the-things">Abstracting all the things</h2>

<div class="side-note">
  If you are already familiar with type classes in general and algebraic structures in particular, you can safely skip this and the next section.
  Keep in mind though that we are dealing with classes for types of kind $*$ only. Type classes for $* \rightarrow *$ are different and not supported.
</div>

<p>Type classes are an incredibly useful abstraction mechanism, originally introduced in Haskell.
If you have been using some of the typelevel.scala libraries already, you probably know how type classes and their instances are represented in Scala: as traits and implicits.
In the following section, we will get started with an example type class from abstract algebra, which is implemented in <em>spire</em>.</p>

<h2 id="group-theory">Group theory</h2>

<p>Group theory is a very important field of research in mathematics and has a very broad range of applications, especially in computer science.
One of the most fundamental structures is a <em>semigroup</em>, which consists of a set of elements equipped with one operation (often called <em>append</em>, <em>mplus</em>, or similarly; in textbooks you will often find $\circ$ or $\oplus$).
Additionally, the operation has to obey the <em>law of associativity</em>, meaning that for any three values $s_1, s_2,$ and $s_3$, it does not matter if you append $s_1$ and $s_2$ first and then append $s_3$, or append $s_2$ and $s_3$ first and then append $s_1$ and the result of that.
In other words, the precise order in which the steps of a larger operation are executed does not matter.
A good analogy here is when flattening a list:
On the surface, you just do not care if it proceeds by splitting the list recursively or if the concatenation is done sequentially by folding.</p>

<div class="side-note">
  In fact, some list operations actually require associativity. From the Scaladoc of the <code>fold</code> method on <code>Seq</code>:
  <blockquote>
    Folds the elements of this collection or iterator using the specified associative binary operator.
    The order in which operations are performed on elements is unspecified and may be nondeterministic. 
  </blockquote>
  This allows a particular collection implementation to use whichever order is most efficient.
</div>

<p>Lists are already a good example for a semigroup: Any <code class="language-plaintext highlighter-rouge">List[T]</code> is a semigroup, with the semigroup operation being list concatenation!
A <code class="language-plaintext highlighter-rouge">Map[K, V]</code> is a semigroup too, given that <code class="language-plaintext highlighter-rouge">V</code> is a semigroup.
The operation is just “merging” two maps, and if you have two duplicate keys, you can use the semigroup operation for <code class="language-plaintext highlighter-rouge">V</code>.</p>

<p>Enough examples. We can represent the concept of a semigroup in Scala using a trait:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">s1</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">s2</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Obviously, we can also implement a semigroup for base types like <code class="language-plaintext highlighter-rouge">Int</code>. An instance could look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">intInstance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">s1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">s2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In other words, we just use the built-in addition function.</p>

<div class="side-note">If you want to know more about applications of abstract algebra in programming, especially in <em>spire</em>, head over to YouTube and watch <a href="http://www.youtube.com/watch?v=xO9AoZNSOH4">an introduction by Tom Switzer</a>.</div>

<h2 id="composing-instances">Composing instances</h2>

<p>Now suppose you are working with three-dimensional images.
Most likely, you will encounter a data structure for vectors (or points), which we recall from above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector3D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>And since you know your maths, you also know that vectors can be added, and that vector addition forms a semigroup!
Hence, a semigroup instance for <code class="language-plaintext highlighter-rouge">Vector3D</code> is the next logical step.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">vectorInstance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Vector3D</span><span class="o">(</span><span class="nv">u</span><span class="o">.</span><span class="py">x</span> <span class="o">+</span> <span class="nv">v</span><span class="o">.</span><span class="py">x</span><span class="o">,</span> <span class="nv">u</span><span class="o">.</span><span class="py">y</span> <span class="o">+</span> <span class="nv">v</span><span class="o">.</span><span class="py">y</span><span class="o">,</span> <span class="nv">u</span><span class="o">.</span><span class="py">z</span> <span class="o">+</span> <span class="nv">v</span><span class="o">.</span><span class="py">z</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, that was a bit tedious, right? We would love to have a way the compiler could write that instance for us.
(I mean, it already generates reasonable defaults for <code class="language-plaintext highlighter-rouge">equals</code>, <code class="language-plaintext highlighter-rouge">hashCode</code> and <code class="language-plaintext highlighter-rouge">toString</code>, so why not for that?)</p>

<p>In any case, you can see a pattern here: Each element of the case class is added separately.
Here, we could have even delegated the addition to our <code class="language-plaintext highlighter-rouge">intInstance</code> from above.</p>

<p>In essence, what we need is a way to combine smaller instances (e.g. for <code class="language-plaintext highlighter-rouge">Int</code>) into larger instances (e.g. for <code class="language-plaintext highlighter-rouge">Vector3D</code> consisting of three <code class="language-plaintext highlighter-rouge">Int</code>s).
Luckily, this is completely mechanic. As an exercise, try writing the following instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">tupleInstance</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">t1</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">t2</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="representing-data-types">Representing data types</h2>

<p>Once we know how to produce an instance for a pair, we can apply that two times and obtain an instance for a triple.
However, there are still two problems here:</p>

<ol>
  <li>We would like an instance for <code class="language-plaintext highlighter-rouge">Vector3D</code>, but we have an instance for <code class="language-plaintext highlighter-rouge">(Int, Int, Int)</code>.</li>
  <li>This is still a lie. We actually have an instance for <code class="language-plaintext highlighter-rouge">(Int, (Int, Int))</code>.</li>
</ol>

<p>Let us address these problems now. The following sections assume familiarity with <code class="language-plaintext highlighter-rouge">HList</code>s, as implemented in <em>shapeless</em>.</p>

<div class="side-note">
  If you are not familiar with <code>HList</code>s yet,
  watch Miles Sabin's <a href="http://www.youtube.com/watch?v=GDbNxL8bqkY">talk about <em>shapeless</em></a> at the Northeast Scala Symposium 2012.
  There's also a <a href="http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/">blog series</a> exploring type-level programming in general by Mark Harrah.
</div>

<p>Now, we want to generate an instance for <code class="language-plaintext highlighter-rouge">Vector3D</code> and countless other data types.
That means that we cannot just special-case for every possible data type, but we have to abstract over them.
The trick is actually quite simple:
For the purposes of automatic instance derivation, we temporarily convert data types into a canonical <em>representation</em> using <code class="language-plaintext highlighter-rouge">HList</code>s, where each case class parameter corresponds to an element in the <code class="language-plaintext highlighter-rouge">HList</code>.</p>

<p>In our example, that representation is <code class="language-plaintext highlighter-rouge">Int :: Int :: Int :: HNil</code>.
Yes, that type is completely equivalent to <code class="language-plaintext highlighter-rouge">Vector3D</code>, and you can implement the conversion functions straightforwardly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">to</span><span class="o">(</span><span class="n">vec</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span> <span class="o">=</span>
  <span class="nv">vec</span><span class="o">.</span><span class="py">x</span> <span class="o">::</span> <span class="nv">vec</span><span class="o">.</span><span class="py">y</span> <span class="o">::</span> <span class="nv">vec</span><span class="o">.</span><span class="py">z</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="k">def</span> <span class="nf">from</span><span class="o">(</span><span class="n">hlist</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">???</span> <span class="c1">// fun exercise!
</span></code></pre></div></div>

<p>Because we are lazy, we let a macro automatically generate the <code class="language-plaintext highlighter-rouge">to</code> and <code class="language-plaintext highlighter-rouge">from</code> methods.
We will see in the second part of the series how that works.
For now, just assume that you can invoke some method, magic happens, and you get the conversions out.</p>

<h2 id="using-the-representation">Using the representation</h2>

<p>At this point, we have a canonical representation for arbitrary case classes.
We will also assume that there are <code class="language-plaintext highlighter-rouge">Semigroup</code> instances for each of its elements.
Now we would like to combine those base instances into an instance for the representation.
We need two implicits for that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">nilInstance</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">HNil</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">HNil</span><span class="o">)</span> <span class="k">=</span> <span class="nc">HNil</span>
  <span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">consInstance</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="k">implicit</span> <span class="k">val</span> <span class="nv">H</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">H</span><span class="o">],</span> <span class="n">T</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="c1">// actual implementation doesn't matter that much
</span>    <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The key insight is that the compiler can come up with an instance for <code class="language-plaintext highlighter-rouge">Int :: Int :: Int :: HNil</code>, just because these two implicits are in scope.</p>

<p>Now we just need a way to get an instance for <code class="language-plaintext highlighter-rouge">Vector3D</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">subst</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">to</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">from</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">append</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
      <span class="nf">from</span><span class="o">(</span><span class="nv">instance</span><span class="o">.</span><span class="py">append</span><span class="o">(</span><span class="nf">to</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nf">to</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Easy enough, right?
To get our much-wanted <code class="language-plaintext highlighter-rouge">Semigroup[Vector3D]</code>, we ask the compiler to make an instance its <code class="language-plaintext highlighter-rouge">HList</code> representation, conjure the conversion functions and plug all that stuff into the <code class="language-plaintext highlighter-rouge">subst</code> machine. Voilà, done!
Add some teaspoons of macros, and we are able to write</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Semigroup</span><span class="o">.</span><span class="py">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
</code></pre></div></div>

<p>Are we done yet? No. We can go even further.</p>

<h2 id="abstracting-over-type-classes">Abstracting over type classes</h2>

<p><code class="language-plaintext highlighter-rouge">Semigroup</code> is not the only type class around. For example, there is a whole tower of classes from group theory for varying use cases. Then there are some type classes from <em>scalaz</em>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Show</code> provides a way to convert a value to a <code class="language-plaintext highlighter-rouge">String</code></li>
  <li><code class="language-plaintext highlighter-rouge">Equal</code> for type-safe equality</li>
  <li><code class="language-plaintext highlighter-rouge">Order</code> provides total ordering on values</li>
</ul>

<p>… and many more!</p>

<p>Another key insight is that <em>all</em> of those classes are able to deal with <code class="language-plaintext highlighter-rouge">HLists</code> and also support the <code class="language-plaintext highlighter-rouge">subst</code> operation.
Hence, one could be tempted to write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Show</span><span class="o">.</span><span class="py">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
<span class="nv">Equal</span><span class="o">.</span><span class="py">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
<span class="c1">// and more
</span></code></pre></div></div>

<p>I hate duplication, though. I do not want to implement the <code class="language-plaintext highlighter-rouge">derive</code> macro over and over again.
Now, if only there was a way to abstract over common functionality of types …</p>

<h2 id="a-type-class-called-typeclass">A type class called “TypeClass”</h2>

<p>“What,” I hear you saying, “the <code class="language-plaintext highlighter-rouge">TypeClass</code> type class? You can’t be serious!”</p>

<p>I am serious.</p>

<p>We use type classes to abstract over types.
<code class="language-plaintext highlighter-rouge">Semigroup</code> abstracts over types which offer some sort of addition functionality.</p>

<p>However, type classes are themselves just types in Scala.
Thus, we can use type classes to abstract over type classes.
We are defining a type class which abstracts over type classes whose instances can be combined to form larger instances.</p>

<p>So, without further ado:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">nil</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">cons</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">H</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">H</span><span class="o">],</span> <span class="n">T</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">subst</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">to</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">from</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This should actually be not too surprising. We already know exactly how to implement <code class="language-plaintext highlighter-rouge">TypeClass[Semigroup]</code>.
If we put this implementation into the companion object of <code class="language-plaintext highlighter-rouge">Semigroup</code>, it will be available for the macro to use.</p>

<h2 id="wrapping-it-up">Wrapping it up</h2>

<p>How can this actually be used?
The work can be roughly divided between three roles:</p>

<ol>
  <li>
    <p>The macro author, who has to implement all the nitty-gritty details of the derivation process.</p>

    <p>That is already done and implemented in <em>shapeless</em>.
The upcoming 2.0.0 release will contain all the necessary bits and pieces, but requires at least Scala 2.10.2 (it will not work for 2.10.1 or earlier).
If you are brave, try the latest snapshot version which is available on Sonatype.</p>
  </li>
  <li>
    <p>The library author, who defines type classes, fundamental instances thereof, and of course the necessary <code class="language-plaintext highlighter-rouge">TypeClass</code> instances.</p>

    <p>These are usually contained in the libraries you use, but the last part will additionally require a bridge library.
But fear not, those bridge libraries already exist, at least for the typelevel.scala libraries, and can be readily added as dependency for your build.
Head over to the <a href="https://github.com/typelevel/shapeless-contrib#readme">GitHub project</a>, we will keep you posted for when a new version comes out.
We also plan to put a compatibility chart on this site.</p>
  </li>
  <li>
    <p>The library user, who defines data types and wants to get instances without all the boilerplate.</p>

    <p>This is the simplest task of all: All you have to do is to put</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">myInstance</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector3D</span><span class="o">]</span>
<span class="c1">// or
</span><span class="k">import</span> <span class="nn">Semigroup.auto._</span>
</code></pre></div>    </div>

    <p>somewhere into your scope, and you are done!</p>

    <p>Providing “explicit” implicit declarations for each type class instance provides the tightest control over your implicit scope and ensures you only have the instances that you want.
Importing <code class="language-plaintext highlighter-rouge">auto</code> reduces the boilerplate to the absolute minimum, which is often desirable, but might result in more instances being materialized than you expect.
Which to choose is partly a matter of taste and partly a function of the size and complexity of the scopes you are importing in to:
large or complex scopes might favour explicit declarations; tighter, simpler scopes might favour <code class="language-plaintext highlighter-rouge">auto</code>.</p>
  </li>
</ol>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 24 Jun 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/06/24/deriving-instances-1.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/06/24/deriving-instances-1.html</guid>
      </item>
    
      <item>
        <title>Inaugurating the typelevel.scala blog</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>This Twitter conversation happened today:</p>

<div>
  <blockquote><p>@<a href="https://twitter.com/d6">d6</a> do you have a blog on numerics, marcos, and performance?</p>&mdash; eugene yokota (@eed3si9n) <a href="https://twitter.com/eed3si9n/status/319711014620897280">April 4, 2013</a></blockquote>
  <blockquote><p>@<a href="https://twitter.com/eed3si9n">eed3si9n</a> Not currently. Maybe I should start one?</p>&mdash; Eiríkr Åsheim (@d6) <a href="https://twitter.com/d6/status/319804225607585794">April 4, 2013</a></blockquote>
  <blockquote><p>@<a href="https://twitter.com/d6">d6</a> @<a href="https://twitter.com/eed3si9n">eed3si9n</a> *cough* <a href="http://t.co/07ye9z78Qc" title="http://typelevel.org/blog/">typelevel.org/blog/</a> *cough*</p>&mdash; Tom Switzer (@tixxit) <a href="https://twitter.com/tixxit/status/319805809586495489">April 4, 2013</a></blockquote>
</div>

<p>So, here it is, the typelevel.scala blog!</p>

<h2 id="what-is-it-about">What is it about?</h2>

<p>As you might already know, typelevel.scala is a collection of libraries which provide a great amount of abstraction.
Here, we would like to show how to use them in your code, provide examples, collect learning resources, and explore implementation details.</p>

<h2 id="who-writes-here">Who writes here?</h2>

<p>Everyone who would like to! Contributions are welcome.
If you want to share something about Scalaz, Shapeless, Spire, or Scala topics in general (e.g. type classes), case studies, examples, or other related content, please do not hesitate to contact us.
This blog (and in fact, the whole web site) is built using Jekyll on GitHub pages, so you can just fork the <a href="https://github.com/typelevel/typelevel.github.com">repository</a>, add a post, and create a pull request.</p>

<h2 id="stay-tuned">Stay tuned!</h2>

<p>We hope that this blog will be filled with content soon.
To make sure that you don’t miss anything, follow <a href="https://twitter.com/typelevel">@typelevel</a> on Twitter or subscribe to the <a href="/blog/feed.rss">RSS feed</a>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 04 Apr 2013 00:00:00 +0000</pubDate>
        <link>https://typelevel.org/blog/2013/04/04/inauguration.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/04/04/inauguration.html</guid>
      </item>
    
  </channel>
</rss>

